<haxe>
	<class path="org.puremvc.haxe.multicore.interfaces.INotifier" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/INotifier.hx" interface="1">
		<sendNotification public="1">
			<f a="notificationName:?body:?type">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Send a [INotification].
	 * 
	 * <p>Convenience method to prevent having to construct new 
	 * notification instances in our implementation code.</p>
	 ]]></haxe_doc>
		</sendNotification>
		<initializeNotifier public="1">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Initialize this INotifier instance.
	 * 
	 * <p>This is how a Notifier gets its multitonKey. 
	 * Calls to sendNotification or to access the
	 * facade will fail until after this method 
	 * has been called.</p>
	 ]]></haxe_doc>
		</initializeNotifier>
		<haxe_doc><![CDATA[
 * The interface definition for a PureMVC Notifier.
 * 
 * <p>[MacroCommand, Command, Mediator] and [Proxy]
 * all have a need to send [Notifications]. </p>
 * 
 * <p>The [INotifier] interface provides a common method called
 * [sendNotification] that relieves implementation code of 
 * the necessity to actually construct [Notifications].</p>
 * 
 * <p>The [Notifier] class, which all of the above mentioned classes
 * extend, also provides an initialized reference to the [Facade]
 * Singleton, which is required for the convienience method
 * for sending [Notifications], but also eases implementation as these
 * classes have frequent [Facade] interactions and usually require
 * access to the facade anyway.</p>
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.observer.Notifier" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/patterns/observer/Notifier.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<MULTITON_MSG line="80" static="1"><c path="String"/></MULTITON_MSG>
		<sendNotification public="1" line="42">
			<f a="notificationName:?body:?type">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Send an [INotification]s.
	 * 
	 * <p>Keeps us from having to construct new notification 
	 * instances in our implementation code.</p>
	 ]]></haxe_doc>
		</sendNotification>
		<initializeNotifier public="1" line="62">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Initialize this INotifier instance.
	 *
	 * <p>This is how a Notifier gets its multitonKey. 
	 * Calls to sendNotification or to access the
	 * facade will fail until after this method 
	 * has been called.</p>
	 * 
	 * <p>Mediators, Commands or Proxies may override 
	 * this method in order to send notifications
	 * or access the Multiton Facade instance as
	 * soon as possible. They CANNOT access the facade
	 * in their constructors, since this method will not
	 * yet have been called.</p> 
	 ]]></haxe_doc>
		</initializeNotifier>
		<facade public="1" get="getFacade" set="null"><c path="org.puremvc.haxe.multicore.interfaces.IFacade"/></facade>
		<getFacade line="70"><f a=""><c path="org.puremvc.haxe.multicore.interfaces.IFacade"/></f></getFacade>
		<multitonKey><c path="String"/></multitonKey>
		<new public="1" line="32"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
 * A Base [INotifier] implementation.
 * 
 * <p>[MacroCommand, Command, Mediator] and [Proxy] 
 * all have a need to send [Notifications].</p>
 *
 * <p>The [INotifier] interface provides a common method called
 * [sendNotification] that relieves implementation code of 
 * the necessity to actually construct [Notifications].</p>
 * 
 * <p>The [Notifier] class, which all of the above mentioned classes
 * extend, provides an initialized reference to the [Facade]
 * Singleton, which is required for the convienience method
 * for sending [Notifications], but also eases implementation as these
 * classes have frequent [Facade] interactions and usually require
 * access to the facade anyway.</p>
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IMediator" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/IMediator.hx" interface="1">
		<implements path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<getMediatorName public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Get the [IMediator] instance name
	 </haxe_doc>
		</getMediatorName>
		<getViewComponent public="1">
			<f a=""><d/></f>
			<haxe_doc>
	 * Get the [IMediator]'s view component.
	 </haxe_doc>
		</getViewComponent>
		<setViewComponent public="1">
			<f a="viewComponent">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the [IMediator]'s view component.
	 </haxe_doc>
		</setViewComponent>
		<listNotificationInterests public="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>
	 * List [INotification] interests.
	 </haxe_doc>
		</listNotificationInterests>
		<handleNotification public="1">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Handle an [INotification].
	 </haxe_doc>
		</handleNotification>
		<onRegister public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the [View] when the [Mediator] is registered
	 </haxe_doc>
		</onRegister>
		<onRemove public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the [View] when the [Mediator] is removed
	 </haxe_doc>
		</onRemove>
		<haxe_doc><![CDATA[
 * The interface definition for a PureMVC Mediator.
 *
 * <p>In PureMVC, [IMediator] implementors assume these responsibilities:</p>
 * <ul>
 * <li>Implement a common method which returns a list of all [INotification]s 
 * the [IMediator] has interest in.</li>
 * <li>Implement a common notification (callback) method.</li>
 * </ul>
 * <p>Additionally, [IMediator]s typically:</p>
 * <ul>
 * <li>Act as an intermediary between one or more view components such as text boxes or 
 * list controls, maintaining references and coordinating their behavior.</li>
 * <li>In Flash-based apps, this is often the place where event listeners are
 * added to view components, and their handlers implemented.</li>
 * <li>Respond to and generate [INotifications], interacting with of 
 * the rest of the PureMVC app.</li>
 * </ul>
 * <p>When an [IMediator] is registered with the [IView], 
 * the [IView] will call the [IMediator]'s 
 * [listNotificationInterests] method. The [IMediator] will 
 * return an [Array] of [INotification] names which 
 * it wishes to be notified about.</p>
 * 
 * <p>The [IView] will then create an [Observer] object 
 * encapsulating that [IMediator]'s ([handleNotification]) method
 * and register it as an Observer for each [INotification] name returned by 
 * [listNotificationInterests].</p>
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.mediator.Mediator" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/patterns/mediator/Mediator.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.observer.Notifier"/>
		<implements path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
		<NAME public="1" line="26" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[
	 * The name of the [Mediator]. 
	 * 
	 * <p>Typically, a [Mediator] will be written to serve
	 * one specific control or group controls and so,
	 * will not have a need to be dynamically named.</p>
	 ]]></haxe_doc>
		</NAME>
		<getMediatorName public="1" line="42">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[
	 * Get the name of the [Mediator].
	 * <p>Override in subclass!</p>
	 ]]></haxe_doc>
		</getMediatorName>
		<setViewComponent public="1" line="50">
			<f a="viewComponent">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the [IMediator]'s view component.
	 </haxe_doc>
		</setViewComponent>
		<getViewComponent public="1" line="58">
			<f a=""><d/></f>
			<haxe_doc>
	 * Get the [Mediator]'s view component.
	 </haxe_doc>
		</getViewComponent>
		<listNotificationInterests public="1" line="67">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>
	 * List the [INotification] names this
	 * [Mediator] is interested in being notified of.
	 </haxe_doc>
		</listNotificationInterests>
		<handleNotification public="1" line="79">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Handle [INotification]s.
	 * 
	 * <P>Typically this will be handled in a switch statement,
	 * with one 'case' entry per [INotification]
	 * the [Mediator] is interested in.
	 ]]></haxe_doc>
		</handleNotification>
		<onRegister public="1" line="87">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the View when the Mediator is registered
	 </haxe_doc>
		</onRegister>
		<onRemove public="1" line="94">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the View when the Mediator is removed
	 </haxe_doc>
		</onRemove>
		<mediatorName><c path="String"/></mediatorName>
		<viewComponent><d/></viewComponent>
		<new public="1" line="31">
			<f a="?mediatorName:?viewComponent">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A base [IMediator] implementation. 
 </haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.utilities.statemachine.StateMachine" params="" file="../../../pmvc_haxe_multicore_utilities_statemachine/src/org/puremvc/haxe/multicore/utilities/statemachine/StateMachine.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.mediator.Mediator"/>
		<NAME public="1" line="21" static="1"><c path="String"/></NAME>
		<ACTION public="1" line="26" static="1">
			<c path="String"/>
			<haxe_doc>
	 * Action Notification name. 
	 </haxe_doc>
		</ACTION>
		<CHANGED public="1" line="31" static="1">
			<c path="String"/>
			<haxe_doc>
	 *  Changed Notification name  
	 </haxe_doc>
		</CHANGED>
		<CANCEL public="1" line="36" static="1">
			<c path="String"/>
			<haxe_doc>
	 *  Cancel Notification name  
	 </haxe_doc>
		</CANCEL>
		<registerState public="1" line="55">
			<f a="state:?initial">
				<c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Registers the entry and exit commands for a given state.
	 </haxe_doc>
		</registerState>
		<removeState public="1" line="68">
			<f a="stateName">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Remove a state mapping.
	 * 
	 * <p>Removes the entry and exit commands for a given state 
	 * as well as the state mapping itself.</p>
	 ]]></haxe_doc>
		</removeState>
		<transitionTo line="85">
			<f a="nextState">
				<c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Transitions to the given state from the current state.
	 *
	 * <p>Sends the exiting notification for the current state 
	 * and the entering notification for the new state.</p>
	 *
	 * <p>Both the exiting notification for the current state
	 * and the entering notification for the next state
	 * will have a reference to the next state in the note
	 * body.</p>
	 ]]></haxe_doc>
		</transitionTo>
		<currentState public="1" get="getCurrentState" set="setCurrentState"><c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/></currentState>
		<getCurrentState line="148">
			<f a=""><c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/></f>
			<haxe_doc>
	 * Get the current state.
	 </haxe_doc>
		</getCurrentState>
		<setCurrentState line="156">
			<f a="state">
				<c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/>
				<c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/>
			</f>
			<haxe_doc>
	 * Set the current state.
	 </haxe_doc>
		</setCurrentState>
		<states>
			<c path="Hash"><c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/></c>
			<haxe_doc>
	 * Map of States objects by name.
	 </haxe_doc>
		</states>
		<initial>
			<c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/>
			<haxe_doc>
	 * The initial state of the FSM.
	 </haxe_doc>
		</initial>
		<canceled>
			<e path="Bool"/>
			<haxe_doc>
	 * The transition has been canceled.
	 </haxe_doc>
		</canceled>
		<new public="1" line="41">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * A Finite State Machine implimentation.
 * 
 * <p>Handles regisistration and removal of state definitions, 
 * which include optional entry and exit commands for each 
 * state.</p>
 ]]></haxe_doc>
	</class>
	<class path="xinf.event.Event" params="T" file="../../../xinf/src/xinf/event/Event.hx">
		<type public="1" set="null"><c path="xinf.event.EventKind"><c path="xinf.event.Event.T"/></c></type>
		<origin public="1"><t path="haxe.PosInfos"/></origin>
		<preventBubble public="1"><e path="Bool"/></preventBubble>
		<target public="1"><c path="xinf.ony.Element"/></target>
		<toString public="1" line="23"><f a=""><c path="String"/></f></toString>
		<new public="1" line="18"><f a="t">
	<c path="xinf.event.EventKind"><c path="xinf.event.Event.T"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc> 
	Base class for all events.
	The type argument (T) has to be set to a child class of Event.
</haxe_doc>
	</class>
	<class path="xinf.event.EventKind" params="T" file="../../../xinf/src/xinf/event/EventKind.hx">
		<name public="1" set="null"><c path="String"/></name>
		<bubble public="1" set="null"><e path="Bool"/></bubble>
		<toString public="1" line="22"><f a=""><c path="String"/></f></toString>
		<new public="1" line="16"><f a="name:?bubble">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	An EventKind instance uniquely identifies a certain kind of Events
	(like, eg, MOUSE_DOWN). It couples the kind to a certain class of Event,
	and a unique string identifier.
</haxe_doc>
	</class>
	<class path="xinf.event.MouseEvent" params="" file="../../../xinf/src/xinf/event/MouseEvent.hx">
		<extends path="xinf.event.Event"><c path="xinf.event.MouseEvent"/></extends>
		<MOUSE_DOWN public="1" line="12" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.MouseEvent"/></c></MOUSE_DOWN>
		<MOUSE_UP public="1" line="13" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.MouseEvent"/></c></MOUSE_UP>
		<MOUSE_MOVE public="1" line="14" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.MouseEvent"/></c></MOUSE_MOVE>
		<MOUSE_OVER public="1" line="15" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.MouseEvent"/></c></MOUSE_OVER>
		<MOUSE_OUT public="1" line="16" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.MouseEvent"/></c></MOUSE_OUT>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<button public="1"><c path="Int"/></button>
		<targetId public="1"><t path="Null"><c path="Int"/></t></targetId>
		<shiftMod public="1"><e path="Bool"/></shiftMod>
		<altMod public="1"><e path="Bool"/></altMod>
		<ctrlMod public="1"><e path="Bool"/></ctrlMod>
		<new public="1" line="27"><f a="_type:_x:_y:?_button:?targetId:?shiftMod:?altMod:?ctrlMod">
	<c path="xinf.event.EventKind"><c path="xinf.event.MouseEvent"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	
</haxe_doc>
	</class>
	<typedef path="xinf.erno.NativeObject" params="" file="../../../xinf/src/xinf/erno/Renderer.hx" module="xinf.erno.Renderer">
		<d/>
		<haxe_doc><![CDATA[
		NativeObject is a typedef that is defined depending on the runtime you compile for.
		<ul>
			<li>for Xinfinity, it is = $xinf.inity.GLObject$</li>
			<li>for Flash, it is = $flash.display.DisplayObject$</li>
			<li>for JavaScript, it is = $js.HtmlDom$</li>
		</ul>
		
		It is used to embed native objects into xinf content, 
		similar to $xinf.erno.NativeContainer$
		
		<br/><br/>
		
		(ignore the following, I haven't figured how to patch haxedoc to accept this construct).
	]]></haxe_doc>
	</typedef>
	<typedef path="xinf.erno.NativeContainer" params="" file="../../../xinf/src/xinf/erno/Renderer.hx" module="xinf.erno.Renderer">
		<d/>
		<haxe_doc><![CDATA[
		NativeContainer is a typedef that is defined depending on the runtime you compile for.
		<ul>
			<li>for Xinfinity, it is = $xinf.inity.GLObject$</li>
			<li>for Flash, it is = $flash.display.DisplayObjectContainer$</li>
			<li>for JavaScript, it is = $js.HtmlDom$</li>
		</ul>
		
		It is used to embed xinf content into native objects, 
		similar to $xinf.erno.NativeObject$
		
		(ignore the following, I haven't figured how to patch haxedoc to accept this construct).
	]]></haxe_doc>
	</typedef>
	<class path="xinf.erno.Renderer" params="" file="../../../xinf/src/xinf/erno/Renderer.hx" interface="1">
		<startObject public="1">
			<f a="id">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Start an object definition. 
		
		Must be matched with a corresponding endObject().
		You can define only one object at a time. The ID must be globally unique, and
		should be acquired with $xinf.erno.Runtime::getNextId$.
		If no object with the ID exists, it will be created. If it does exist,
		it will be cleared. Until a matching endObject() is called, the object
		is the "current object".
	</haxe_doc>
		</startObject>
		<endObject public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		End an object definition.
	</haxe_doc>
		</endObject>
		<destroyObject public="1">
			<f a="id">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Forget about an object, free associated resources.
	</haxe_doc>
		</destroyObject>
		<showObject public="1">
			<f a="id">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Show the object with the specified ID inside the current object.
		(For Object-model renderers, this does something like addChild/appendChild.)
	</haxe_doc>
		</showObject>
		<setTransform public="1">
			<f a="id:x:y:a:b:c:d">
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		(Re-)Set the transformation of the object with the specified ID.
	</haxe_doc>
		</setTransform>
		<setTranslation public="1">
			<f a="id:x:y">
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		(Re-)Set the translation of the object with the specified ID.
	</haxe_doc>
		</setTranslation>
		<clipRect public="1">
			<f a="w:h">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the clipping rectangle (mask) of the current object. If this
		is never called within an object definition, contents will not be
		clipped.
	</haxe_doc>
		</clipRect>
		<setFill public="1">
			<f a="?paint">
				<e path="xinf.erno.Paint"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the fill paint for following drawing operations. If you specify [null],
		or leave away the argument, shapes won't be filled.
	</haxe_doc>
		</setFill>
		<setStroke public="1">
			<f a="?paint:width:?capsStyle:?joinStyle:?miterLimit:?dashArray:?dashOffset">
				<e path="xinf.erno.Paint"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Array"><c path="Int"/></c>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the stroke (line) paint, width, and other stroke styles for following drawing operations. 
		If you specify None for paint,
		or [0] width, shapes' won't be stroked.
	</haxe_doc>
		</setStroke>
		<startShape public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Start a shape definition. A shape can consist of multiple polygons (paths) that are potentially
		overlapping.
		Every [startShape] must be matched with a [endShape], within a shape definition only calls
		to [startPath] and [endPath] may be used (and those allowed within these).
	</haxe_doc>
		</startShape>
		<endShape public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		End the current shape definition. Can be thought to fill/stroke the defined shape
		with the currently set styles.
	</haxe_doc>
		</endShape>
		<startPath public="1">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Start a path definition. Must only be called in between calls to [startShape]/[endShape], and
		be matched with an [endPath]. A path is a single polygon within a shape. The path
		will start at the specified coordinates ([x],[y]). Within a path definition the only
		allowed calls are [lineTo], [quadraticTo], [cubicTo] and [close].
	</haxe_doc>
		</startPath>
		<endPath public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		End the current path definition.
	</haxe_doc>
		</endPath>
		<close public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Close the currently defined path. May only occur between calls to [startPath]/[endPath].
	</haxe_doc>
		</close>
		<lineTo public="1">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a line to the specified absolute coordinates ([x],[y]) to the currently defined path.
		
		May only occur between calls to [startPath]/[endPath].
	</haxe_doc>
		</lineTo>
		<quadraticTo public="1">
			<f a="x1:y1:x:y">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a quadratic Bezier curve to the specified absolute coordinates ([x],[y]) 
		to the currently defined path, using ([x1],[y1]) as the curve control point.
		
		May only occur between calls to [startPath]/[endPath].
	</haxe_doc>
		</quadraticTo>
		<cubicTo public="1">
			<f a="x1:y1:x2:y2:x:y">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a cubic Bezier curve to the specified absolute coordinates ([x],[y]) 
		to the currently defined path, using ([x1],[y1]) and ([x2],[y2]) as curve control points.
		
		May only occure between calls to [startPath]/[endPath].
	</haxe_doc>
		</cubicTo>
		<arcTo public="1">
			<f a="x1:y1:rx:ry:rotation:largeArc:sweep:x:y">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds an elliptical arc, as definined by the SVG spec:
		
		"... from the current point to (x, y). 
		The size and orientation of the ellipse are defined by two radii (rx, ry) 
		and an x-axis-rotation, which indicates how the ellipse as a whole is 
		rotated relative to the current coordinate system. The center (cx, cy) 
		of the ellipse is calculated automatically to satisfy the constraints 
		imposed by the other parameters. large-arc-flag and sweep-flag contribute 
		to the automatic calculations and help determine how the arc is drawn."

	</haxe_doc>
		</arcTo>
		<rect public="1">
			<f a="x:y:w:h">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Draws a rectangle with the current fill and stroke styles within the current
		object. The rectangle's upper left corner will be at ([x],[y]), and it will
		be [w] units wide and [h] units high.
	</haxe_doc>
		</rect>
		<roundedRect public="1">
			<f a="x:y:w:h:rx:ry">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Draws a rounded rectangle, just like rect() but with a rounding of rx/ry radius.
	</haxe_doc>
		</roundedRect>
		<ellipse public="1">
			<f a="x:y:rx:ry">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Draws a ellipse with the current fill and stroke styles within the current
		object. The center will be at ([x],[y]), and it will
		have a x-radius of [rx] and y-radius of [ry] units.
	</haxe_doc>
		</ellipse>
		<text public="1">
			<f a="x:y:text:format">
				<c path="Float"/>
				<c path="Float"/>
				<c path="String"/>
				<c path="xinf.erno.TextFormat"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Draws a string of text at coordinates ([x],[y]) within the current object,
		using the given font style (family, weight, slant and size) and the
		current fill color. The string may contain '\n's to span multiple lines.
	</haxe_doc>
		</text>
		<image public="1">
			<f a="img:inRegion:outRegion">
				<c path="xinf.erno.ImageData"/>
				<a>
					<y><c path="Float"/></y>
					<x><c path="Float"/></x>
					<w><c path="Float"/></w>
					<h><c path="Float"/></h>
				</a>
				<a>
					<y><c path="Float"/></y>
					<x><c path="Float"/></x>
					<w><c path="Float"/></w>
					<h><c path="Float"/></h>
				</a>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Draw the specified [inRegion] of the given <a href="ImageData.html">ImageData</a> 
		object to the given [outRegion]. 
		FIXME: make inRegion/outRegion optional, potentially swap (so that one can leave
		away only inRegion).
	]]></haxe_doc>
		</image>
		<startNative public="1">
			<f a="o">
				<t path="xinf.erno.NativeContainer"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Start redefining the contents of the given $xinf.erno.NativeContainer$.
		Similar to [startObject()], this clears the given container, and must be matched
		by a corresponding [endNative()]. [startNative]/[endNative] allow you to use a
		Xinferno Renderer to fill a runtime-specific graphic object.
	</haxe_doc>
		</startNative>
		<endNative public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		End the content definition of a native container.
	</haxe_doc>
		</endNative>
		<native public="1">
			<f a="o">
				<t path="xinf.erno.NativeObject"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add the given $xinf.erno.NativeObject$ to the current object.
		This allows you to embed native content (i.e., arbitrary DisplayObjects in Flash,
		or arbitrary HTML content for JavaScript) within xinferno content.
	</haxe_doc>
		</native>
		<haxe_doc>
	The xinferno Renderer interface describes the drawing protocol used within $wiki XinfErno Xinferno$.
</haxe_doc>
	</class>
	<class path="xinf.xml.Serializable" params="" file="../../../xinf/src/xinf/xml/Serializable.hx" interface="1">
		<fromXml public="1">
			<f a="xml">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		De-serialize the object from the given Xml.
		
		You'll usually not call this. Instead, use
		$xinf.xml.Document$.instantiate or .load.
	</haxe_doc>
		</fromXml>
		<haxe_doc>
	An interface for objects that are (de-)serializable
	from/to XML.
	
	In reality, serialization is not currently supported.
	This interface will be extended with a toXml() function
	then.
</haxe_doc>
	</class>
	<class path="xinf.xml.Node" params="" file="../../../xinf/src/xinf/xml/Node.hx">
		<implements path="xinf.xml.Serializable"/>
		<constructed><e path="Bool"/></constructed>
		<parentElement public="1" set="null">
			<c path="xinf.xml.XMLElement"/>
			<haxe_doc>
		The parent Element of this Node, if the
		Node is attached.
	</haxe_doc>
		</parentElement>
		<ownerDocument public="1" set="null">
			<c path="xinf.xml.Document"/>
			<haxe_doc>
		The Document that ultimately contains this
		Node. In Xinf, there is currently only one
		document. See $xinf.ony.Root$. A node is
		always associated to a Document.
	</haxe_doc>
		</ownerDocument>
		<mChildren set="null"><c path="Array"><c path="xinf.xml.Node"/></c></mChildren>
		<childNodes public="1" get="dynamic" set="null">
			<t path="Iterable"><c path="xinf.xml.Node"/></t>
			<haxe_doc>
		An iterator of the child Nodes contained in	this Node.
	</haxe_doc>
		</childNodes>
		<get_childNodes line="54"><f a=""><t path="Iterable"><c path="xinf.xml.Node"/></t></f></get_childNodes>
		<fromXml public="1" line="74">
			<f a="xml">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		De-serialize the node content and attributes
		from the given Xml.
		
		You'll usually not call this. Instead, use
		$xinf.xml.Document$.instantiate or .load.
	</haxe_doc>
		</fromXml>
		<toXml public="1" line="81"><f a=""><c path="Xml"/></f></toXml>
		<onLoad public="1" line="96">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Called after the Document has been fully loaded
		(not including external references like images)
		and the Node structure is set up. Provides a 
		hook for deriving classes to initialize things
		that depend on the document structure to be
		fully set up.
		
		This also calls onLoad on any child nodes.
	</haxe_doc>
		</onLoad>
		<setOwnerDocument line="102"><f a="doc">
	<c path="xinf.xml.Document"/>
	<e path="Void"/>
</f></setOwnerDocument>
		<acquired line="108"><f a="newChild">
	<c path="xinf.xml.Node"/>
	<e path="Void"/>
</f></acquired>
		<appendChild public="1" line="120">
			<f a="newChild">
				<c path="xinf.xml.Node"/>
				<c path="xinf.xml.Node"/>
			</f>
			<haxe_doc>
		Appends the Node [newChild] to the end
		of the list of children of this node.
	</haxe_doc>
		</appendChild>
		<insertBefore public="1" line="131">
			<f a="newChild:refChild">
				<c path="xinf.xml.Node"/>
				<c path="xinf.xml.Node"/>
				<c path="xinf.xml.Node"/>
			</f>
			<haxe_doc>
		Inserts the Node [newChild] into the list of
		children of this node, immediately before
		[refChild].
	</haxe_doc>
		</insertBefore>
		<removeChild public="1" line="151">
			<f a="oldChild">
				<c path="xinf.xml.Node"/>
				<c path="xinf.xml.Node"/>
			</f>
			<haxe_doc>
		Removes the Node [oldChild] from the list of children.
	</haxe_doc>
		</removeChild>
		<added public="1" line="163">
			<f a="parent">
				<c path="xinf.xml.Node"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Hook DOCME </haxe_doc>
		</added>
		<removed public="1" line="167">
			<f a="parent">
				<c path="xinf.xml.Node"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Hook DOCME </haxe_doc>
		</removed>
		<cloneNode public="1" line="175">
			<f a="deep">
				<e path="Bool"/>
				<c path="xinf.xml.Node"/>
			</f>
			<haxe_doc>
		Creates a 1-to-1 clone of this Node.
		If [deep] is true, any children will be
		cloned, too. Else, the new Node is empty.
	</haxe_doc>
		</cloneNode>
		<copyProperties line="190"><f a="to">
	<d/>
	<e path="Void"/>
</f></copyProperties>
		<getTypedParent public="1" params="T" line="198">
			<f a="type">
				<c path="Class"><c path="getTypedParent.T"/></c>
				<c path="getTypedParent.T"/>
			</f>
			<haxe_doc>
		Convenience function, return the parentElement
		of this Node typed to the class [type], or [null]
		if the parent is not of that type.
	</haxe_doc>
		</getTypedParent>
		<construct line="203"><f a=""><e path="Bool"/></f></construct>
		<destruct line="212"><f a=""><e path="Bool"/></f></destruct>
		<toString public="1" line="227">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Create a human-readable String representation
		of this node, mostly for debugging purposes.
		The string will be the class name of this individual
		instance.
	</haxe_doc>
		</toString>
		<new public="1" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Create a new, empty Node.
		
		FIXME: should be associated to the root document?
	</haxe_doc>
		</new>
		<haxe_doc>
	A generic Node, as in an XML document, but
	also the base class for all xinf's SVG-like
	$xinf.ony.Element$s.
	
	While this is oriented on the SVG uDOM, there
	are some differences. There is currently no
	namespace support; parentNode is parentElement
	here; xinf currently doesn't support any
	other node types than $xinf.xml.Element$,
	and there is no textContent.

	This might change when xinf supports 
	(re-)serialization of XML content. The
	Interface described here should stay the same.

	$SVG svgudom#dom__Node Node in SVG uDOM$
</haxe_doc>
	</class>
	<class path="xinf.event.EventDispatcher" params="" file="../../../xinf/src/xinf/event/EventDispatcher.hx" interface="1">
		<addEventListener public="1" params="T"><f a="type:h">
	<c path="xinf.event.EventKind"><c path="addEventListener.T"/></c>
	<f a="">
		<c path="addEventListener.T"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="addEventListener.T"/>
		<e path="Void"/>
	</f>
</f></addEventListener>
		<removeEventListener public="1" params="T"><f a="type:h">
	<c path="xinf.event.EventKind"><c path="removeEventListener.T"/></c>
	<f a="">
		<c path="removeEventListener.T"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
</f></removeEventListener>
		<dispatchEvent public="1" params="T"><f a="e">
	<c path="xinf.event.Event"><c path="dispatchEvent.T"/></c>
	<e path="Void"/>
</f></dispatchEvent>
		<postEvent public="1" params="T"><f a="e:?pos">
	<c path="xinf.event.Event"><c path="postEvent.T"/></c>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></postEvent>
	</class>
	<class path="xinf.traits.TraitAccess" params="" file="../../../xinf/src/xinf/traits/TraitAccess.hx" interface="1">
		<getTrait public="1" params="T"><f a="name:type:?presentation">
	<c path="String"/>
	<d/>
	<e path="Bool"/>
	<c path="getTrait.T"/>
</f></getTrait>
		<setTrait public="1" params="T"><f a="name:value">
	<c path="String"/>
	<c path="setTrait.T"/>
	<c path="setTrait.T"/>
</f></setTrait>
		<getStyleTrait public="1" params="T"><f a="name:type:?inherit:?presentation">
	<c path="String"/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="getStyleTrait.T"/>
</f></getStyleTrait>
		<setStyleTrait public="1" params="T"><f a="name:value">
	<c path="String"/>
	<c path="setStyleTrait.T"/>
	<c path="setStyleTrait.T"/>
</f></setStyleTrait>
		<setTraitFromString public="1"><f a="name:value:to">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setTraitFromString>
		<setTraitFromDynamic public="1"><f a="name:value:to">
	<c path="String"/>
	<d/>
	<d/>
	<e path="Void"/>
</f></setTraitFromDynamic>
	</class>
	<class path="neko.Lib" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/Lib.hx">
		<load public="1" line="32" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
		Load and return a Neko primitive from a NDLL library.
	</haxe_doc>
		</load>
		<loadLazy public="1" line="36" static="1"><f a="lib:prim:nargs">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<d/>
</f></loadLazy>
		<print public="1" line="47" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output.
	</haxe_doc>
		</print>
		<println public="1" line="54" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output followed by a newline character.
	</haxe_doc>
		</println>
		<rethrow public="1" line="62" static="1">
			<f a="e">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Rethrow an exception. This is useful when manually filtering an exception in order
		to keep the previous exception stack.
	</haxe_doc>
		</rethrow>
		<serialize public="1" line="70" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize using native Neko serialization. This will return a Binary string that can be
		stored for long term usage. The serialized data is optimized for speed and not for size.
	</haxe_doc>
		</serialize>
		<unserialize public="1" line="77" static="1">
			<f a="s">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a string using native Neko serialization. See [serialize].
	</haxe_doc>
		</unserialize>
		<localUnserialize public="1" line="88" static="1">
			<f a="s">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a string using native Neko serialization. See [serialize].
		This function assume that all the serialized data was serialized with current
		module, even if the module name was different. This can happen if you are unserializing
		some data into mod_neko that was serialized on a different server using a different
		file path.
	</haxe_doc>
		</localUnserialize>
		<nekoToHaxe public="1" line="98" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Converts a Neko value to its haXe equivalent. Used for wrapping String and Arrays raw values into haXe Objects.
	</haxe_doc>
		</nekoToHaxe>
		<haxeToNeko public="1" line="130" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Converts a Neko value to its haXe equivalent. Used to unwrap String and Arrays Objects into raw Neko values.
	</haxe_doc>
		</haxeToNeko>
		<getClasses public="1" line="165" static="1">
			<f a=""><d/></f>
			<haxe_doc>
		Returns an object containing all compiled packages and classes.
	</haxe_doc>
		</getClasses>
		<stringReference public="1" line="172" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a string referencing the data contains in bytes.
	</haxe_doc>
		</stringReference>
		<bytesReference public="1" line="179" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>
		Returns bytes referencing the content of a string.
	</haxe_doc>
		</bytesReference>
		<__serialize line="183" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></__serialize>
		<__unserialize line="184" static="1"><f a=":">
	<unknown/>
	<a>
		<loadprim><f a="p:n">
	<unknown/>
	<unknown/>
	<unknown/>
</f></loadprim>
		<loadmodule><f a="m:l">
	<unknown/>
	<unknown/>
	<unknown/>
</f></loadmodule>
	</a>
	<unknown/>
</f></__unserialize>
	</class>
	<class path="EReg" params="" file="C:\Program Files\Motion-Twin\haxe/std/EReg.hx">
		<regexp_new_options line="337" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></regexp_new_options>
		<regexp_match line="338" static="1"><f a=":::">
	<d/>
	<unknown/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></regexp_match>
		<regexp_matched line="339" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="String"/>
</f></regexp_matched>
		<regexp_matched_pos line="340" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<a>
		<pos><c path="Int"/></pos>
		<len><c path="Int"/></len>
	</a>
</f></regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><e path="Bool"/></global>
		<match public="1" line="81">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" line="117">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" line="141">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" line="167">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" line="198">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" line="218">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" line="257">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" line="323">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" line="52">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new regular expression with pattern [r] and
		options [opt].
	</haxe_doc>
		</new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="xinf.traits.TraitDefinition" params="" file="../../../xinf/src/xinf/traits/TraitDefinition.hx" interface="1">
		<parse public="1"><f a="value">
	<c path="String"/>
	<d/>
</f></parse>
		<fromDynamic public="1"><f a="value">
	<d/>
	<d/>
</f></fromDynamic>
		<getDefault public="1"><f a=""><d/></f></getDefault>
		<write public="1"><f a="value">
	<d/>
	<c path="String"/>
</f></write>
		<interpolate public="1"><f a="a:b:f">
	<d/>
	<d/>
	<c path="Float"/>
	<d/>
</f></interpolate>
		<distance public="1"><f a="a:b">
	<d/>
	<d/>
	<c path="Float"/>
</f></distance>
		<add public="1"><f a="a:b">
	<d/>
	<d/>
	<d/>
</f></add>
	</class>
	<class path="xinf.traits.TypedTrait" params="T" file="../../../xinf/src/xinf/traits/TypedTrait.hx">
		<implements path="xinf.traits.TraitDefinition"/>
		<type><d/></type>
		<parse public="1" line="18"><f a="value">
	<c path="String"/>
	<d/>
</f></parse>
		<write public="1" line="22"><f a="value">
	<d/>
	<c path="String"/>
</f></write>
		<fromDynamic public="1" line="26"><f a="value">
	<d/>
	<d/>
</f></fromDynamic>
		<getDefault public="1" line="34"><f a=""><d/></f></getDefault>
		<interpolate public="1" line="39"><f a="a:b:f">
	<d/>
	<d/>
	<c path="Float"/>
	<d/>
</f></interpolate>
		<distance public="1" line="43"><f a="a:b">
	<d/>
	<d/>
	<c path="Float"/>
</f></distance>
		<add public="1" line="47"><f a="a:b">
	<d/>
	<d/>
	<d/>
</f></add>
		<new public="1" line="10"><f a="type">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.traits.StringTrait" params="" file="../../../xinf/src/xinf/traits/StringTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="String"/></extends>
		<def><c path="String"/></def>
		<new public="1" line="10"><f a="?def">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.xml.XMLElement" params="" file="../../../xinf/src/xinf/xml/XMLElement.hx">
		<extends path="xinf.xml.Node"/>
		<implements path="xinf.event.EventDispatcher"/>
		<implements path="xinf.traits.TraitAccess"/>
		<TRAITS line="34" static="1"><a>
	<name><c path="xinf.traits.StringTrait"/></name>
	<id><c path="xinf.traits.StringTrait"/></id>
	<base><c path="xinf.traits.StringTrait"/></base>
</a></TRAITS>
		<AttrReg line="275" static="1"><c path="EReg"/></AttrReg>
		<_traits><d/></_traits>
		<_ptraits><d/></_ptraits>
		<_cache><d/></_cache>
		<listeners><c path="Hash"><c path="List"><f a="">
	<d/>
	<e path="Void"/>
</f></c></c></listeners>
		<base public="1" get="dynamic" set="dynamic">
			<c path="String"/>
			<haxe_doc>
		The current base URL/URI/IRI for this element.
		Can be set to specify a different base URL,
		possibly relative to an "inherited" base.
		
		$SVG struct#XMLBaseAttribute xml:base$
	</haxe_doc>
		</base>
		<get_base line="49"><f a=""><c path="String"/></f></get_base>
		<set_base line="60"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_base>
		<id public="1" get="dynamic" set="dynamic">
			<c path="String"/>
			<haxe_doc> Standard XML unique name ("id" attribute).
	
		As there is no namespace support at the moment,
		this recognized both "id" and "xml:id", with
		(not-standard-conformantly) the later attribute 
		taking precedence.
		
		FIXME: should update the document's index when changed.
	
		$SVG struct#xmlIDAttribute xml:id$
	</haxe_doc>
		</id>
		<get_id line="74"><f a=""><c path="String"/></f></get_id>
		<set_id line="75"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_id>
		<name public="1" get="dynamic" set="dynamic">
			<c path="String"/>
			<haxe_doc> textual name of the Element
		("name" attribute) </haxe_doc>
		</name>
		<get_name line="80"><f a=""><c path="String"/></f></get_name>
		<set_name line="81"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_name>
		<getTagName public="1" line="104">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Return the element's XML tag name.
		
		FIXME: this needs rework. currently, tagName must be
		set "manually" by deriving classes. $xinf.xml.Binding$
		could/should take care of that.
	</haxe_doc>
		</getTagName>
		<clearTraitsCache public="1" line="140">
			<f a=""><e path="Void"/></f>
			<haxe_doc>****************</haxe_doc>
		</clearTraitsCache>
		<cacheTrait params="T" line="144"><f a="name:v:type">
	<c path="String"/>
	<d/>
	<c path="Class"><c path="cacheTrait.T"/></c>
	<c path="cacheTrait.T"/>
</f></cacheTrait>
		<getTrait public="1" params="T" line="158">
			<f a="name:type:?presentation">
				<c path="String"/>
				<d/>
				<e path="Bool"/>
				<c path="getTrait.T"/>
			</f>
			<haxe_doc> see $xinf.traits.TraitAccess$.getTrait </haxe_doc>
		</getTrait>
		<setTrait public="1" params="T" line="191">
			<f a="name:value">
				<c path="String"/>
				<c path="setTrait.T"/>
				<c path="setTrait.T"/>
			</f>
			<haxe_doc> see $xinf.traits.TraitAccess::setTrait$ </haxe_doc>
		</setTrait>
		<setPresentationTrait public="1" line="197"><f a="name:value">
	<c path="String"/>
	<d/>
	<d/>
</f></setPresentationTrait>
		<setStyleTrait public="1" params="T" line="208">
			<f a="name:value">
				<c path="String"/>
				<c path="setStyleTrait.T"/>
				<c path="setStyleTrait.T"/>
			</f>
			<haxe_doc> see $xinf.traits.TraitAccess::setStyleTrait$
	
		On xinf.xml.XMLElement, there is no difference
		between get/setStyleTrait and get/setTrait,
		but $xinf.style.StyledElement$ makes the
		difference. </haxe_doc>
		</setStyleTrait>
		<getStyleTrait public="1" params="T" line="213">
			<f a="name:type:?inherit:?presentation">
				<c path="String"/>
				<d/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="getStyleTrait.T"/>
			</f>
			<haxe_doc> see $xinf.traits.TraitAccess::getStyleTrait$ </haxe_doc>
		</getStyleTrait>
		<setTraitFromString public="1" line="218">
			<f a="_name:value:to">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc> see $xinf.traits.TraitAccess::setTraitFromString$ </haxe_doc>
		</setTraitFromString>
		<setTraitFromDynamic public="1" line="237">
			<f a="_name:value:to">
				<c path="String"/>
				<d/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc> see $xinf.traits.TraitAccess::setTraitFromDynamic$ </haxe_doc>
		</setTraitFromDynamic>
		<setTraitsFromObject public="1" line="255">
			<f a="o">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc> Set the traits of this Element from the 
		dynamic object [o].  
		Uses $xinf.style.StyleParser::fromObject$,
		so the field values of [o] can be of any
		type that can be converted by the respective
		$xinf.traits.TraitDefinition$. Usually,
		this includes String and the native type
		of the Trait. 
	</haxe_doc>
		</setTraitsFromObject>
		<setTraitsFromXml public="1" line="265">
			<f a="xml">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Set the traits of this object from the
		given Xml's attribute values.
		
		Namespaces are currently ignored.
		Internally, this uses $xinf.xml.XMLElement::setTraitFromString$.
	</haxe_doc>
		</setTraitsFromXml>
		<normalizeAttributeName line="276"><f a="_name">
	<c path="String"/>
	<c path="String"/>
</f></normalizeAttributeName>
		<getTraitDefinition line="284">
			<f a="_name">
				<c path="String"/>
				<c path="xinf.traits.TraitDefinition"/>
			</f>
			<haxe_doc> Return the TraitDefinition of the trait named [_name],
		or [null] if this Element doesn't have such a trait.
	</haxe_doc>
		</getTraitDefinition>
		<getClassTrait line="295"><f a="cl:name">
	<c path="Class"><d/></c>
	<c path="String"/>
	<c path="xinf.traits.TraitDefinition"/>
</f></getClassTrait>
		<addEventListener public="1" params="T" line="305">
			<f a="type:h">
				<c path="xinf.event.EventKind"><c path="addEventListener.T"/></c>
				<f a="">
					<c path="addEventListener.T"/>
					<e path="Void"/>
				</f>
				<f a="">
					<c path="addEventListener.T"/>
					<e path="Void"/>
				</f>
			</f>
			<haxe_doc> see $xinf.event.EventDispatcher::addEventListener$ </haxe_doc>
		</addEventListener>
		<removeEventListener public="1" params="T" line="317">
			<f a="type:h">
				<c path="xinf.event.EventKind"><c path="removeEventListener.T"/></c>
				<f a="">
					<c path="removeEventListener.T"/>
					<e path="Void"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc> see $xinf.event.EventDispatcher::removeEventListener$ </haxe_doc>
		</removeEventListener>
		<removeAllListeners public="1" params="T" line="328">
			<f a="type">
				<c path="xinf.event.EventKind"><c path="removeAllListeners.T"/></c>
				<e path="Bool"/>
			</f>
			<haxe_doc> Convenience function to remove all listeners
		of the given [type]. 
	</haxe_doc>
		</removeAllListeners>
		<dispatchEvent public="1" params="T" line="336">
			<f a="e">
				<c path="xinf.event.Event"><c path="dispatchEvent.T"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc> see $xinf.event.EventDispatcher::dispatchEvent$
	
		Do not use this function directly, instead use [postEvent()].
	</haxe_doc>
		</dispatchEvent>
		<postEvent public="1" params="T" line="349">
			<f a="e:?pos">
				<c path="xinf.event.Event"><c path="postEvent.T"/></c>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc> see $xinf.event.EventDispatcher::postEvent$ </haxe_doc>
		</postEvent>
		<typedChildren public="1" params="T" line="357"><f a="cl">
	<c path="Class"><c path="typedChildren.T"/></c>
	<t path="Iterator"><c path="typedChildren.T"/></t>
</f></typedChildren>
		<getElementByName public="1" line="374"><f a="name">
	<c path="String"/>
	<c path="xinf.xml.XMLElement"/>
</f></getElementByName>
		<getTypedElementByName public="1" params="T" line="382"><f a="name:cl">
	<c path="String"/>
	<c path="Class"><c path="getTypedElementByName.T"/></c>
	<c path="getTypedElementByName.T"/>
</f></getTypedElementByName>
		<new public="1" line="88">
			<f a="?traits">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Create a new, empty Element.
		
		If [traits] is given, it will be set using $xinf.traits.TraitAccess.setTraitsFromObject()$.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Element, like a tag in an XML document, but
	also the base class for all Xinfony 
	$xinf.ony.Element$s.
	
	Element provides the basics to implement
	$xinf.traits.TraitAccess$ and $xinf.event.EventDispatcher$.
</haxe_doc>
	</class>
	<class path="xinf.style.StyledElement" params="" file="../../../xinf/src/xinf/style/StyledElement.hx">
		<extends path="xinf.xml.XMLElement"/>
		<ws_split line="130" static="1"><c path="EReg"/></ws_split>
		<styleClasses><c path="Hash"><e path="Bool"/></c></styleClasses>
		<_matchedStyle><d/></_matchedStyle>
		<setStyleTrait public="1" params="T" line="40">
			<f a="name:value">
				<c path="String"/>
				<c path="setStyleTrait.T"/>
				<c path="setStyleTrait.T"/>
			</f>
			<haxe_doc>
		Set the style trait [name] to [value]. 
		Similar to $xinf.xml.Element$.setTrait, but also
		calls styleChanged().
	</haxe_doc>
		</setStyleTrait>
		<getStyleTrait public="1" params="T" line="70">
			<f a="name:type:?inherit:?presentation">
				<c path="String"/>
				<d/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="getStyleTrait.T"/>
			</f>
			<haxe_doc><![CDATA[
		Return the value of the "style trait" [name]. Style traits
		differ from normal traits in a few aspects:
		<ul>
			<li>they can come from $xinf.style.StyleSheet$s
				</li>
			<li>they can have $xinf.traits.SpecialTraitValue$s
				</li>
			<li>they can be inherited (when [inherit] is true or omitted,
				or the trait has the special type $xinf.traits.Inherit$)
				</li>
			<li>their value is cached, so access should be relatively 
				efficient even when the value is determined by inheritance.
				</li>
		</ul>
		
		DOCME: move this doc somewhere else?
	]]></haxe_doc>
		</getStyleTrait>
		<hasOwnStyleTrait public="1" params="T" line="120"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasOwnStyleTrait>
		<styleChanged public="1" line="169">
			<f a="?attribute">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Hook function. Derived classes can override this to do 
		something when the element's style changes (like redraw).
		
		In reality, it is not strictly always called when the
		style would change-- notably, if the style comes from
		a StyleSheet, and either the StyleSheet changes or
		this element would match different selectors (because
		it changed in the display hierarchy), or similar things,
		it will *not* be called, in the current implementation.
		
		Note, however, that setting any trait with setStyleTrait,
		or changing a StyledElement's style classes does indeed 
		trigger a call to styleChanged.
	</haxe_doc>
		</styleChanged>
		<updateClassStyle line="188"><f a=""><e path="Void"/></f></updateClassStyle>
		<addStyleClass public="1" line="203">
			<f a="name">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add the style class [name], and re-match against ownerDocument's StyleSheet.
	</haxe_doc>
		</addStyleClass>
		<removeStyleClass public="1" line="211">
			<f a="name">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Remove the style class [name], and re-match against ownerDocument's StyleSheet.
	</haxe_doc>
		</removeStyleClass>
		<hasStyleClass public="1" line="219">
			<f a="name">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Return [true] if [name] is in the list of style classes.
	</haxe_doc>
		</hasStyleClass>
		<getStyleClasses public="1" line="226">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Return an iterator of the list of style classes.
	</haxe_doc>
		</getStyleClasses>
		<matchSelector public="1" line="234">
			<f a="s">
				<e path="xinf.style.Selector"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Return [true] if the object matches
		the given Selector [s], false otherwise.
	</haxe_doc>
		</matchSelector>
		<new public="1" line="29">
			<f a="traits">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Create a new StyledElement with initially empty style classes.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Element with style.
	
	Keeps a list of associated style classes, and automatically
	matches against the ownerDocument's StyleSheet.
	
	Recognizes the "style" attribute when parsing from XML.
</haxe_doc>
	</class>
	<class path="neko.NekoMath__" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/NekoMath__.hx">
		<PI static="1"><unknown/></PI>
		<NaN static="1"><c path="Float"/></NaN>
		<POSITIVE_INFINITY static="1"><c path="Float"/></POSITIVE_INFINITY>
		<NEGATIVE_INFINITY static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<abs line="34" static="1"><unknown/></abs>
		<min line="35" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></min>
		<max line="36" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></max>
		<sin line="37" static="1"><unknown/></sin>
		<cos line="38" static="1"><unknown/></cos>
		<atan2 line="39" static="1"><unknown/></atan2>
		<tan line="40" static="1"><unknown/></tan>
		<exp line="41" static="1"><unknown/></exp>
		<log line="42" static="1"><unknown/></log>
		<sqrt line="43" static="1"><unknown/></sqrt>
		<round line="44" static="1"><unknown/></round>
		<floor line="45" static="1"><unknown/></floor>
		<ceil line="46" static="1"><unknown/></ceil>
		<atan line="47" static="1"><unknown/></atan>
		<asin line="48" static="1"><unknown/></asin>
		<acos line="49" static="1"><unknown/></acos>
		<pow line="50" static="1"><unknown/></pow>
		<__rnd static="1"><unknown/></__rnd>
		<_rand_float line="53" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></_rand_float>
		<_rand_int line="54" static="1"><unknown/></_rand_int>
		<random line="55" static="1"><f a=""><unknown/></f></random>
		<isNaN line="57" static="1"><f a="f">
	<unknown/>
	<unknown/>
</f></isNaN>
		<isFinite line="58" static="1"><f a="f">
	<unknown/>
	<e path="Bool"/>
</f></isFinite>
	</class>
	<class path="neko.Boot" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/Boot.hx">
		<__tmp_str line="29" static="1"><f a=""><c path="Int"/></f></__tmp_str>
		<__enum_str line="33" static="1"><f a="e">
	<d/>
	<c path="Int"/>
</f></__enum_str>
		<__interfLoop line="55" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__interfLoop>
		<__instanceof line="70" static="1"><f a="o:cl">
	<a>
		<__name__><unknown/></__name__>
		<__enum__><t path="#Dynamic"/></__enum__>
		<__ename__><unknown/></__ename__>
		<__class__><unknown/></__class__>
	</a>
	<t path="#Dynamic"/>
	<e path="Bool"/>
</f></__instanceof>
		<__serialize line="88" static="1"><f a="o">
	<a>
		<__enum__><a><__ename__><a><length><c path="Int"/></length></a></__ename__></a></__enum__>
		<__class__><a><__name__><a><length><c path="Int"/></length></a></__name__></a></__class__>
	</a>
	<c path="Array"><unknown/></c>
</f></__serialize>
		<__tagserialize line="108" static="1"><f a="o">
	<a>
		<tag><unknown/></tag>
		<__enum__><a><__ename__><a><length><c path="Int"/></length></a></__ename__></a></__enum__>
	</a>
	<c path="Array"><unknown/></c>
</f></__tagserialize>
		<__unserialize line="117" static="1"><f a="v">
	<c path="Array"><unknown/></c>
	<unknown/>
</f></__unserialize>
		<__init line="140" static="1"><f a=""><e path="Void"/></f></__init>
	</class>
	<class path="Math" params="" file="C:\Program Files\Motion-Twin\haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="xinf.ony.traits.TransformTrait" params="" file="../../../xinf/src/xinf/ony/traits/TransformTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="xinf.geom.Transform"/></extends>
		<D2R line="47" static="1"><c path="Float"/></D2R>
		<R2D line="48" static="1"><c path="Float"/></R2D>
		<splitNumbers line="56" static="1"><c path="EReg"/></splitNumbers>
		<translate line="57" static="1"><c path="EReg"/></translate>
		<rotate line="58" static="1"><c path="EReg"/></rotate>
		<matrix line="59" static="1"><c path="EReg"/></matrix>
		<scale line="60" static="1"><c path="EReg"/></scale>
		<skewX line="61" static="1"><c path="EReg"/></skewX>
		<skewY line="62" static="1"><c path="EReg"/></skewY>
		<transform line="64" static="1"><c path="EReg"/></transform>
		<parseTransformList public="1" line="66" static="1"><f a="text">
	<c path="String"/>
	<c path="xinf.geom.Transform"/>
</f></parseTransformList>
		<parseSingle public="1" line="84" static="1"><f a="text">
	<c path="String"/>
	<c path="xinf.geom.Transform"/>
</f></parseSingle>
		<new public="1" line="19"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="xinf.ony.type.Display" params="" file="../../../xinf/src/xinf/ony/type/Display.hx">
		<None><haxe_doc> do not display the element in question, or any of it's children </haxe_doc></None>
		<Inline><haxe_doc> display the element in question normally </haxe_doc></Inline>
		<haxe_doc>
	Defines wether something should be displayed or not.
	
	Not all possible values of the SVG "display" property are
	supported, but only None and Inline make sense for Xinf
	(currently, at least).

	$SVG painting#DisplayProperty the "display" property$
</haxe_doc>
	</enum>
	<class path="xinf.traits.EnumTrait" params="T" file="../../../xinf/src/xinf/traits/EnumTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="xinf.traits.EnumTrait.T"/></extends>
		<enumClass><d/></enumClass>
		<def><c path="xinf.traits.EnumTrait.T"/></def>
		<sfx><c path="String"/></sfx>
		<new public="1" line="12"><f a="enumClass:?suffix:?def">
	<d/>
	<c path="String"/>
	<c path="xinf.traits.EnumTrait.T"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="xinf.ony.type.Visibility" params="" file="../../../xinf/src/xinf/ony/type/Visibility.hx">
		<Visible/>
		<Hidden/>
		<haxe_doc>
	Defines wether something should be visible or not.
	
	Contrary to $xinf.ony.type.Display$, Visibility only
	applies to the one element in question, not it's children
	(although it is inherited). That means, e.g., 
	if a $xinf.ony.Group$ has visibility [Hidden], 
	any children that specify visibility [Visible] 
	will still be shown.

	The "collapse" value is currently not supported.

	$SVG painting#VisibilityProperty the "visibility" property$
</haxe_doc>
	</enum>
	<class path="xinf.traits.FloatTrait" params="" file="../../../xinf/src/xinf/traits/FloatTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="Float"/></extends>
		<numeric line="8" static="1"><c path="EReg"/></numeric>
		<def><c path="Float"/></def>
		<new public="1" line="12"><f a="?def">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.traits.BoundedFloatTrait" params="" file="../../../xinf/src/xinf/traits/BoundedFloatTrait.hx">
		<extends path="xinf.traits.FloatTrait"/>
		<numeric line="8" static="1"><c path="EReg"/></numeric>
		<min><t path="Null"><c path="Float"/></t></min>
		<max><t path="Null"><c path="Float"/></t></max>
		<new public="1" line="13"><f a="?min:?max:?def">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.traits.PaintTrait" params="" file="../../../xinf/src/xinf/ony/traits/PaintTrait.hx">
		<extends path="xinf.traits.TypedTrait"><e path="xinf.ony.type.Paint"/></extends>
		<url line="12" static="1"><c path="EReg"/></url>
		<hexcolor line="13" static="1"><c path="EReg"/></hexcolor>
		<rgbcolor line="14" static="1"><c path="EReg"/></rgbcolor>
		<rgbpercentcolor line="15" static="1"><c path="EReg"/></rgbpercentcolor>
		<colorNames static="1"><c path="Hash"><e path="xinf.ony.type.Paint"/></c></colorNames>
		<getColorNames public="1" line="19" static="1"><f a=""><c path="Hash"><e path="xinf.ony.type.Paint"/></c></f></getColorNames>
		<intToString line="277" static="1"><f a="v:?radix:?l">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></intToString>
		<fromRGBInt public="1" line="302" static="1">
			<f a="c">
				<c path="Int"/>
				<e path="xinf.ony.type.Paint"/>
			</f>
			<haxe_doc> Set the R, G and B components from an integer (like 0x00ff00 for green) </haxe_doc>
		</fromRGBInt>
		<def><e path="xinf.ony.type.Paint"/></def>
		<new public="1" line="213"><f a="?def">
	<e path="xinf.ony.type.Paint"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="xinf.ony.type.Paint" params="" file="../../../xinf/src/xinf/ony/type/Paint.hx">
		<URLReference a="url">
			<c path="String"/>
			<haxe_doc> use the PaintServer specified by [url]. 
		Currently, only references by id to Gradients
		in the current Document are supported 
	</haxe_doc>
		</URLReference>
		<RGBColor a="r:g:b">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<haxe_doc> use the solid RGB color described.
	</haxe_doc>
		</RGBColor>
		<None><haxe_doc> do not stroke/fill the shape in question at all
	</haxe_doc></None>
		<haxe_doc>
	A Paint specifies the Color, or reference to a PaintServer
	to use for filling or stroking a shape.

	$SVG painting#SpecifyingPaint Specifying paint in SVG$
</haxe_doc>
	</enum>
	<class path="xinf.ony.type.Length" params="" file="../../../xinf/src/xinf/ony/type/Length.hx">
		<TYPE_UNKNOWN public="1" line="26" static="1"><c path="String"/></TYPE_UNKNOWN>
		<TYPE_NUMBER public="1" line="27" static="1"><c path="String"/></TYPE_NUMBER>
		<TYPE_PERCENTAGE public="1" line="28" static="1"><c path="String"/></TYPE_PERCENTAGE>
		<TYPE_EMS public="1" line="29" static="1"><c path="String"/></TYPE_EMS>
		<TYPE_EXS public="1" line="30" static="1"><c path="String"/></TYPE_EXS>
		<TYPE_PX public="1" line="31" static="1"><c path="String"/></TYPE_PX>
		<TYPE_CM public="1" line="32" static="1"><c path="String"/></TYPE_CM>
		<TYPE_MM public="1" line="33" static="1"><c path="String"/></TYPE_MM>
		<TYPE_IN public="1" line="34" static="1"><c path="String"/></TYPE_IN>
		<TYPE_PT public="1" line="35" static="1"><c path="String"/></TYPE_PT>
		<TYPE_PC public="1" line="36" static="1"><c path="String"/></TYPE_PC>
		<pixSize line="43" static="1"><c path="Float"/></pixSize>
		<unitType public="1" get="getUnitType" set="null"><c path="String"/></unitType>
		<value public="1" get="getValue" set="setValue"><c path="Float"/></value>
		<valueInSpecifiedUnits public="1"><c path="Float"/></valueInSpecifiedUnits>
		<DOMString public="1" get="getDOMString" set="setDOMString"><c path="String"/></DOMString>
		<orig><a>
	<value><c path="Float"/></value>
	<type><c path="String"/></type>
</a></orig>
		<newValueSpecifiedUnits public="1" line="56"><f a="unitType:i">
	<c path="String"/>
	<c path="Float"/>
	<e path="Void"/>
</f></newValueSpecifiedUnits>
		<convertToSpecifiedUnits public="1" line="81"><f a="newType:?data">
	<c path="String"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></convertToSpecifiedUnits>
		<getUnitType public="1" line="212"><f a=""><c path="String"/></f></getUnitType>
		<getValue public="1" line="215"><f a=""><c path="Float"/></f></getValue>
		<setValue public="1" line="218"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></setValue>
		<toString public="1" line="223"><f a=""><c path="String"/></f></toString>
		<getDOMString public="1" line="226"><f a=""><c path="String"/></f></getDOMString>
		<setDOMString public="1" line="233"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></setDOMString>
		<typeValid line="258"><f a="ut">
	<c path="String"/>
	<e path="Bool"/>
</f></typeValid>
		<new public="1" line="47"><f a="?s:?v">
	<c path="String"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	An SVG-like Length value, a distance measurement.

	This is currently mostly a stub, to allow for 
	parsing length values with units. Conversion
	is not correct.
	
	Proper documentation will follow here when it
	is properly implemented.

	$SVG types#DataTypeLength SVG Length$
	$SVG coords#Units SVG Units$
</haxe_doc>
	</class>
	<class path="xinf.ony.traits.LengthTrait" params="" file="../../../xinf/src/xinf/ony/traits/LengthTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="xinf.ony.type.Length"/></extends>
		<def><c path="xinf.ony.type.Length"/></def>
		<new public="1" line="13"><f a="?def">
	<c path="xinf.ony.type.Length"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="xinf.ony.type.JoinStyle" params="" file="../../../xinf/src/xinf/ony/type/JoinStyle.hx">
		<RoundJoin/>
		<MiterJoin/>
		<BevelJoin/>
		<haxe_doc>
	Specifies the shape to be used at the corners
	of shapes when they are stroked.
	
	$SVG painting#StrokeLinejoinProperty stroke-linecap$
</haxe_doc>
	</enum>
	<enum path="xinf.ony.type.CapsStyle" params="" file="../../../xinf/src/xinf/ony/type/CapsStyle.hx">
		<SquareCaps/>
		<RoundCaps/>
		<ButtCaps/>
		<haxe_doc>
	Specifies the shape to be used at the end
	of open subpaths when they are stroked.
	
	$SVG painting#StrokeLinecapProperty stroke-linecap$
</haxe_doc>
	</enum>
	<class path="xinf.ony.traits.IntListTrait" params="" file="../../../xinf/src/xinf/ony/traits/IntListTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="xinf.ony.type.IntList"/></extends>
		<new public="1" line="11"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.traits.IntTrait" params="" file="../../../xinf/src/xinf/traits/IntTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="Int"/></extends>
		<numeric line="8" static="1"><c path="EReg"/></numeric>
		<def><c path="Int"/></def>
		<new public="1" line="12"><f a="?def">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.traits.StringListTrait" params="" file="../../../xinf/src/xinf/ony/traits/StringListTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="xinf.ony.type.StringList"/></extends>
		<new public="1" line="11"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.ony.traits.StringChoiceTrait" params="" file="../../../xinf/src/xinf/ony/traits/StringChoiceTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="String"/></extends>
		<choices><c path="Array"><c path="String"/></c></choices>
		<new public="1" line="12"><f a="choices">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="xinf.ony.type.TextAnchor" params="" file="../../../xinf/src/xinf/ony/type/TextAnchor.hx">
		<Start/>
		<Middle/>
		<End/>
	</enum>
	<class path="xinf.ony.Element" params="" file="../../../xinf/src/xinf/ony/Element.hx">
		<extends path="xinf.style.StyledElement"/>
		<TRAITS line="43" static="1"><a>
	<visibility><c path="xinf.traits.EnumTrait"><e path="xinf.ony.type.Visibility"/></c></visibility>
	<transform><c path="xinf.ony.traits.TransformTrait"/></transform>
	<textanchor><c path="xinf.traits.EnumTrait"><e path="xinf.ony.type.TextAnchor"/></c></textanchor>
	<strokewidth><c path="xinf.ony.traits.LengthTrait"/></strokewidth>
	<strokeopacity><c path="xinf.traits.BoundedFloatTrait"/></strokeopacity>
	<strokemiterlimit><c path="xinf.traits.FloatTrait"/></strokemiterlimit>
	<strokelinejoin><c path="xinf.traits.EnumTrait"><e path="xinf.ony.type.JoinStyle"/></c></strokelinejoin>
	<strokelinecap><c path="xinf.traits.EnumTrait"><e path="xinf.ony.type.CapsStyle"/></c></strokelinecap>
	<strokedashoffset><c path="xinf.traits.IntTrait"/></strokedashoffset>
	<strokedasharray><c path="xinf.ony.traits.IntListTrait"/></strokedasharray>
	<stroke><c path="xinf.ony.traits.PaintTrait"/></stroke>
	<opacity><c path="xinf.traits.BoundedFloatTrait"/></opacity>
	<fontweight><c path="xinf.ony.traits.StringChoiceTrait"/></fontweight>
	<fontsize><c path="xinf.ony.traits.LengthTrait"/></fontsize>
	<fontfamily><c path="xinf.ony.traits.StringListTrait"/></fontfamily>
	<fillopacity><c path="xinf.traits.BoundedFloatTrait"/></fillopacity>
	<fill><c path="xinf.ony.traits.PaintTrait"/></fill>
	<display><c path="xinf.traits.EnumTrait"><e path="xinf.ony.type.Display"/></c></display>
	<color><c path="xinf.ony.traits.PaintTrait"/></color>
</a></TRAITS>
		<transform public="1" get="dynamic" set="dynamic"><c path="xinf.geom.Transform"/></transform>
		<get_transform line="69"><f a=""><c path="xinf.geom.Transform"/></f></get_transform>
		<set_transform line="70"><f a="v">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></set_transform>
		<display public="1" get="dynamic" set="dynamic"><e path="xinf.ony.type.Display"/></display>
		<get_display line="73"><f a=""><e path="xinf.ony.type.Display"/></f></get_display>
		<set_display line="74"><f a="v">
	<e path="xinf.ony.type.Display"/>
	<e path="xinf.ony.type.Display"/>
</f></set_display>
		<visibility public="1" get="dynamic" set="dynamic"><e path="xinf.ony.type.Visibility"/></visibility>
		<get_visibility line="77"><f a=""><e path="xinf.ony.type.Visibility"/></f></get_visibility>
		<set_visibility line="78"><f a="v">
	<e path="xinf.ony.type.Visibility"/>
	<e path="xinf.ony.type.Visibility"/>
</f></set_visibility>
		<opacity public="1" get="dynamic" set="dynamic"><t path="Null"><c path="Float"/></t></opacity>
		<get_opacity line="81"><f a=""><t path="Null"><c path="Float"/></t></f></get_opacity>
		<set_opacity line="82"><f a="v">
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Float"/></t>
</f></set_opacity>
		<color public="1" get="dynamic" set="dynamic"><e path="xinf.ony.type.Paint"/></color>
		<get_color line="85"><f a=""><e path="xinf.ony.type.Paint"/></f></get_color>
		<set_color line="86"><f a="v">
	<e path="xinf.ony.type.Paint"/>
	<e path="xinf.ony.type.Paint"/>
</f></set_color>
		<fill public="1" get="dynamic" set="dynamic"><e path="xinf.ony.type.Paint"/></fill>
		<get_fill line="89"><f a=""><e path="xinf.ony.type.Paint"/></f></get_fill>
		<set_fill line="90"><f a="v">
	<e path="xinf.ony.type.Paint"/>
	<e path="xinf.ony.type.Paint"/>
</f></set_fill>
		<fillOpacity public="1" get="get_fill_opacity" set="set_fill_opacity"><t path="Null"><c path="Float"/></t></fillOpacity>
		<get_fill_opacity line="93"><f a=""><t path="Null"><c path="Float"/></t></f></get_fill_opacity>
		<set_fill_opacity line="94"><f a="v">
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Float"/></t>
</f></set_fill_opacity>
		<stroke public="1" get="dynamic" set="dynamic"><e path="xinf.ony.type.Paint"/></stroke>
		<get_stroke line="97"><f a=""><e path="xinf.ony.type.Paint"/></f></get_stroke>
		<set_stroke line="98"><f a="v">
	<e path="xinf.ony.type.Paint"/>
	<e path="xinf.ony.type.Paint"/>
</f></set_stroke>
		<strokeWidth public="1" get="get_stroke_width" set="set_stroke_width"><t path="Null"><c path="Float"/></t></strokeWidth>
		<get_stroke_width line="101"><f a=""><t path="Null"><c path="Float"/></t></f></get_stroke_width>
		<set_stroke_width line="102"><f a="v">
	<c path="Float"/>
	<t path="Null"><c path="Float"/></t>
</f></set_stroke_width>
		<strokeOpacity public="1" get="get_stroke_opacity" set="set_stroke_opacity"><t path="Null"><c path="Float"/></t></strokeOpacity>
		<get_stroke_opacity line="105"><f a=""><t path="Null"><c path="Float"/></t></f></get_stroke_opacity>
		<set_stroke_opacity line="106"><f a="v">
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Float"/></t>
</f></set_stroke_opacity>
		<strokeLinejoin public="1" get="get_line_join" set="set_line_join"><e path="xinf.ony.type.JoinStyle"/></strokeLinejoin>
		<get_line_join line="109"><f a=""><e path="xinf.ony.type.JoinStyle"/></f></get_line_join>
		<set_line_join line="110"><f a="v">
	<e path="xinf.ony.type.JoinStyle"/>
	<e path="xinf.ony.type.JoinStyle"/>
</f></set_line_join>
		<strokeLinecap public="1" get="get_line_cap" set="set_line_cap"><e path="xinf.ony.type.CapsStyle"/></strokeLinecap>
		<get_line_cap line="113"><f a=""><e path="xinf.ony.type.CapsStyle"/></f></get_line_cap>
		<set_line_cap line="114"><f a="v">
	<e path="xinf.ony.type.CapsStyle"/>
	<e path="xinf.ony.type.CapsStyle"/>
</f></set_line_cap>
		<strokeMiterlimit public="1" get="get_stroke_miterlimit" set="set_stroke_miterlimit"><t path="Null"><c path="Float"/></t></strokeMiterlimit>
		<get_stroke_miterlimit line="117"><f a=""><t path="Null"><c path="Float"/></t></f></get_stroke_miterlimit>
		<set_stroke_miterlimit line="118"><f a="v">
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Float"/></t>
</f></set_stroke_miterlimit>
		<strokeDasharray public="1" get="get_stroke_dasharray" set="set_stroke_dasharray"><c path="xinf.ony.type.IntList"/></strokeDasharray>
		<get_stroke_dasharray line="121"><f a=""><c path="xinf.ony.type.IntList"/></f></get_stroke_dasharray>
		<set_stroke_dasharray line="122"><f a="v">
	<c path="xinf.ony.type.IntList"/>
	<c path="xinf.ony.type.IntList"/>
</f></set_stroke_dasharray>
		<strokeDashoffset public="1" get="get_stroke_dashoffset" set="set_stroke_dashoffset"><t path="Null"><c path="Int"/></t></strokeDashoffset>
		<get_stroke_dashoffset line="125"><f a=""><t path="Null"><c path="Int"/></t></f></get_stroke_dashoffset>
		<set_stroke_dashoffset line="126"><f a="v">
	<t path="Null"><c path="Int"/></t>
	<t path="Null"><c path="Int"/></t>
</f></set_stroke_dashoffset>
		<fontFamily public="1" get="get_font_family" set="set_font_family"><c path="xinf.ony.type.StringList"/></fontFamily>
		<get_font_family line="129"><f a=""><c path="xinf.ony.type.StringList"/></f></get_font_family>
		<set_font_family line="130"><f a="v">
	<c path="xinf.ony.type.StringList"/>
	<c path="xinf.ony.type.StringList"/>
</f></set_font_family>
		<fontSize public="1" get="get_font_size" set="set_font_size"><c path="Float"/></fontSize>
		<get_font_size line="133"><f a=""><c path="Float"/></f></get_font_size>
		<set_font_size line="134"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_font_size>
		<textAnchor public="1" get="get_text_anchor" set="set_text_anchor"><e path="xinf.ony.type.TextAnchor"/></textAnchor>
		<get_text_anchor line="139"><f a=""><e path="xinf.ony.type.TextAnchor"/></f></get_text_anchor>
		<set_text_anchor line="140"><f a="v">
	<e path="xinf.ony.type.TextAnchor"/>
	<e path="xinf.ony.type.TextAnchor"/>
</f></set_text_anchor>
		<getBoundingBox public="1" line="161">
			<f a=""><t path="xinf.geom.TRectangle"/></f>
			<haxe_doc> the bounding box of the element </haxe_doc>
		</getBoundingBox>
		<retransform public="1" line="172">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[	
		schedule this Object for redefining it's transformation<br/>
		You should usually not need to call this yourself, 
		the Object will be automatically scheduled
		when you modify it's transformation.
	]]></haxe_doc>
		</retransform>
		<redraw public="1" line="180">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[ schedule this Object for redrawing<br/>
		The Object will (on JavaScript: <i>should</i>) be redrawn before the next frame is shown to the user.
		Call this function whenever your Object needs to redraw itself because it's (immediate) content changed
		- there's no need to call it if anything changes about it's children. 
	]]></haxe_doc>
		</redraw>
		<globalToLocal public="1" line="189">
			<f a="p">
				<t path="xinf.geom.TPoint"/>
				<t path="xinf.geom.TPoint"/>
			</f>
			<haxe_doc> convert the given point from global to local coordinates </haxe_doc>
		</globalToLocal>
		<localToGlobal public="1" line="197">
			<f a="p">
				<t path="xinf.geom.TPoint"/>
				<t path="xinf.geom.TPoint"/>
			</f>
			<haxe_doc> convert the given point from local to global coordinates </haxe_doc>
		</localToGlobal>
		<dispatchEvent public="1" params="T" line="208">
			<f a="e">
				<c path="xinf.event.Event"><c path="dispatchEvent.T"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ dispatch the given Event<br/>
		tries to dispatch the given Event to any registered listeners.
		If no handler is found, 'bubble' the Event - i.e., pass it up to our parent.
	]]></haxe_doc>
		</dispatchEvent>
		<new line="150"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Element" params="" file="../../../xinf/src/xinf/ony/erno/Element.hx">
		<extends path="xinf.ony.Element"/>
		<_manager static="1"><c path="xinf.ony.erno.Manager"/></_manager>
		<manager get="getManager" set="null" static="1"><c path="xinf.ony.erno.Manager"/></manager>
		<getManager line="26" static="1"><f a=""><c path="xinf.ony.erno.Manager"/></f></getManager>
		<findById public="1" line="33" static="1"><f a="id">
	<c path="Int"/>
	<c path="xinf.ony.erno.Element"/>
</f></findById>
		<xid public="1" set="null">
			<t path="Null"><c path="Int"/></t>
			<haxe_doc> Unique (to the runtime environment) ID of this object. Will be set automatically, in the constructor. 
		Note that this has nothing to do with the SVG 'id' property (which is a String, while this is numeric) </haxe_doc>
		</xid>
		<reTransform public="1" line="64">
			<f a="g">
				<c path="xinf.erno.Renderer"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ apply new transformation (position)<br/>
		This is an internal function, you should usually not care about it.
		]]></haxe_doc>
		</reTransform>
		<draw public="1" line="77">
			<f a="g">
				<c path="xinf.erno.Renderer"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ draw the Object to the given [Renderer]<br/>
		You should usually neither call nor override this function,
		instead, schedule a redraw with [redraw()] and 
		override [drawContents()] to draw stuff.
		]]></haxe_doc>
		</draw>
		<convertPaint line="86"><f a="paint:opacity">
	<e path="xinf.ony.type.Paint"/>
	<c path="Float"/>
	<e path="xinf.erno.Paint"/>
</f></convertPaint>
		<drawContents public="1" line="108">
			<f a="g">
				<c path="xinf.erno.Renderer"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ draw the Object's 'own' contents (not it's children) to the given [Renderer]<br/>
		You can override this method, and call the [Renderer]'s methods to draw things.
		Everything you do will be in the Object's local coordinate space.
		]]></haxe_doc>
		</drawContents>
		<new line="37"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.Line" params="" file="../../../xinf/src/xinf/ony/Line.hx">
		<extends path="xinf.ony.erno.Element"/>
		<tagName line="13" static="1"><c path="String"/></tagName>
		<TRAITS line="15" static="1"><a>
	<y2><c path="xinf.ony.traits.LengthTrait"/></y2>
	<y1><c path="xinf.ony.traits.LengthTrait"/></y1>
	<x2><c path="xinf.ony.traits.LengthTrait"/></x2>
	<x1><c path="xinf.ony.traits.LengthTrait"/></x1>
</a></TRAITS>
		<x1 public="1" get="dynamic" set="dynamic"><c path="Float"/></x1>
		<get_x1 line="23"><f a=""><c path="Float"/></f></get_x1>
		<set_x1 line="24"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x1>
		<y1 public="1" get="dynamic" set="dynamic"><c path="Float"/></y1>
		<get_y1 line="27"><f a=""><c path="Float"/></f></get_y1>
		<set_y1 line="28"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y1>
		<x2 public="1" get="dynamic" set="dynamic"><c path="Float"/></x2>
		<get_x2 line="31"><f a=""><c path="Float"/></f></get_x2>
		<set_x2 line="32"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x2>
		<y2 public="1" get="dynamic" set="dynamic"><c path="Float"/></y2>
		<get_y2 line="35"><f a=""><c path="Float"/></f></get_y2>
		<set_y2 line="36"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y2>
		<new line="11"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.traits.PointListTrait" params="" file="../../../xinf/src/xinf/ony/traits/PointListTrait.hx">
		<extends path="xinf.traits.TypedTrait"><c path="List"><t path="xinf.geom.TPoint"/></c></extends>
		<pointSplit line="15" static="1"><c path="EReg"/></pointSplit>
		<new public="1" line="11"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.erno.TextFormat" params="" file="../../../xinf/src/xinf/erno/TextFormat.hx">
		<create public="1" line="95" static="1"><f a="?family:?size:?bold:?italic">
	<c path="String"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="xinf.erno.TextFormat"/>
</f></create>
		<DEFAULT static="1"><c path="xinf.erno.TextFormat"/></DEFAULT>
		<getDefault public="1" line="107" static="1"><f a=""><c path="xinf.erno.TextFormat"/></f></getDefault>
		<family public="1" set="setFamily"><c path="String"/></family>
		<size public="1" set="setSize"><c path="Float"/></size>
		<bold public="1" set="setBold"><e path="Bool"/></bold>
		<italic public="1" set="setItalic"><e path="Bool"/></italic>
		<dirty><e path="Bool"/></dirty>
		<setFamily line="22"><f a="family">
	<c path="String"/>
	<c path="String"/>
</f></setFamily>
		<setSize line="28"><f a="size">
	<c path="Float"/>
	<c path="Float"/>
</f></setSize>
		<setBold line="34"><f a="v">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setBold>
		<setItalic line="40"><f a="v">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setItalic>
		<assureLoaded public="1" line="61"><f a=""><e path="Void"/></f></assureLoaded>
		<textSize public="1" line="67"><f a="text">
	<c path="String"/>
	<a>
		<y><c path="Float"/></y>
		<x><c path="Float"/></x>
	</a>
</f></textSize>
		<ascender public="1" line="72"><f a=""><c path="Float"/></f></ascender>
		<assureGlyphs public="1" line="76"><f a="text:size">
	<c path="String"/>
	<c path="Float"/>
	<e path="Void"/>
</f></assureGlyphs>
		<load public="1" line="79"><f a=""><e path="Void"/></f></load>
		<font public="1"><c path="xinf.inity.font.Font"/></font>
		<new line="48"><f a="?family:?size:?bold:?italic">
	<c path="String"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc> DOCME </haxe_doc>
	</class>
	<class path="String" params="" file="C:\Program Files\Motion-Twin\haxe/std/String.hx" extern="1">
		<fromCharCode public="1" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="neko.NekoString__" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/NekoString__.hx">
		<implements path="String"/>
		<__name__ line="29" static="1"><c path="Array"><c path="String"/></c></__name__>
		<__split line="30" static="1"><d/></__split>
		<fromCharCode line="177" static="1"><f a="c">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null"><c path="Int"/></length>
		<charAt public="1" line="43"><f a="p">
	<c path="Int"/>
	<c path="String"/>
</f></charAt>
		<charCodeAt public="1" line="55"><f a="p">
	<c path="Int"/>
	<t path="Null"><c path="Int"/></t>
</f></charCodeAt>
		<indexOf public="1" line="61"><f a="str:?pos">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" line="70"><f a="str:?pos">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<split public="1" line="85"><f a="delim">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></split>
		<substr public="1" line="101"><f a="pos:?len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></substr>
		<toLowerCase public="1" line="127"><f a=""><c path="String"/></f></toLowerCase>
		<toUpperCase public="1" line="143"><f a=""><c path="String"/></f></toUpperCase>
		<toString public="1" line="159"><f a=""><c path="String"/></f></toString>
		<__compare line="165"><f a="o">
	<a><__s><unknown/></__s></a>
	<unknown/>
</f></__compare>
		<__add line="169"><f a="s">
	<unknown/>
	<c path="String"/>
</f></__add>
		<__radd line="173"><f a="s">
	<unknown/>
	<c path="String"/>
</f></__radd>
		<new line="34"><f a="s">
	<unknown/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.inity.font.Glyph" params="" file="../../../xinf/src/xinf/inity/font/Glyph.hx">
		<advance public="1"><c path="Float"/></advance>
		<render public="1" line="15"><f a=""><c path="Float"/></f></render>
		<new public="1" line="11"><f a="adv">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Line" params="" file="../../../xinf/src/xinf/ony/erno/Line.hx">
		<extends path="xinf.ony.Line"/>
		<new public="1" line="10"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="xinf.ony.type.SVGPathSegment" params="" file="../../../xinf/src/xinf/ony/type/SVGPathSegment.hx">
		<VerticalToR a="y"><c path="Float"/></VerticalToR>
		<VerticalTo a="y"><c path="Float"/></VerticalTo>
		<SmoothQuadraticToR a="x:y">
			<c path="Float"/>
			<c path="Float"/>
		</SmoothQuadraticToR>
		<SmoothQuadraticTo a="x:y">
			<c path="Float"/>
			<c path="Float"/>
		</SmoothQuadraticTo>
		<SmoothCubicToR a="x2:y2:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
		</SmoothCubicToR>
		<SmoothCubicTo a="x2:y2:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
		</SmoothCubicTo>
		<QuadraticToR a="x1:y1:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
		</QuadraticToR>
		<QuadraticTo a="x1:y1:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
		</QuadraticTo>
		<MoveToR a="x:y">
			<c path="Float"/>
			<c path="Float"/>
		</MoveToR>
		<MoveTo a="x:y">
			<c path="Float"/>
			<c path="Float"/>
		</MoveTo>
		<LineToR a="x:y">
			<c path="Float"/>
			<c path="Float"/>
		</LineToR>
		<LineTo a="x:y">
			<c path="Float"/>
			<c path="Float"/>
		</LineTo>
		<HorizontalToR a="x"><c path="Float"/></HorizontalToR>
		<HorizontalTo a="x"><c path="Float"/></HorizontalTo>
		<CubicToR a="x1:y1:x2:y2:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
		</CubicToR>
		<CubicTo a="x1:y1:x2:y2:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
		</CubicTo>
		<Close/>
		<ArcToR a="rx:ry:rotation:largeArc:sweep:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<e path="Bool"/>
			<e path="Bool"/>
			<c path="Float"/>
			<c path="Float"/>
		</ArcToR>
		<ArcTo a="rx:ry:rotation:largeArc:sweep:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<e path="Bool"/>
			<e path="Bool"/>
			<c path="Float"/>
			<c path="Float"/>
		</ArcTo>
	</enum>
	<class path="openvg.DLLLoader" params="" file="../../../xinf/src/libs/openvg/api/openvg/DLLLoader.hx">
		<loaded public="1" static="1"><c path="Hash"><e path="Bool"/></c></loaded>
		<getHaxelibPath public="1" line="9" static="1"><f a=""><c path="String"/></f></getHaxelibPath>
		<getXinfLibPath public="1" line="32" static="1"><f a=""><c path="String"/></f></getXinfLibPath>
		<addToEnvironment public="1" line="42" static="1"><f a="name:separator:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></addToEnvironment>
		<checkEnvironment public="1" line="53" static="1"><f a="name:separator:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></checkEnvironment>
		<addLibToPath public="1" line="67" static="1"><f a="lib">
	<c path="String"/>
	<e path="Void"/>
</f></addLibToPath>
	</class>
	<class path="Hash" params="T" file="C:\Program Files\Motion-Twin\haxe/std/Hash.hx">
		<h><d/></h>
		<set public="1" line="61">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" line="76">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" line="96">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" line="125">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" line="155">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" line="181">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" line="218">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" line="38">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="neko.Sys" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/Sys.hx">
		<args public="1" line="29" static="1"><f a=""><c path="Array"><c path="String"/></c></f></args>
		<getEnv public="1" line="44" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></getEnv>
		<putEnv public="1" line="51" static="1"><f a="s:v">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></putEnv>
		<sleep public="1" line="55" static="1"><f a="seconds">
	<c path="Float"/>
	<e path="Void"/>
</f></sleep>
		<setTimeLocale public="1" line="59" static="1"><f a="loc">
	<c path="String"/>
	<e path="Bool"/>
</f></setTimeLocale>
		<getCwd public="1" line="63" static="1"><f a=""><c path="String"/></f></getCwd>
		<setCwd public="1" line="67" static="1"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></setCwd>
		<systemName public="1" line="71" static="1"><f a=""><c path="String"/></f></systemName>
		<escapeArgument public="1" line="75" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" line="89" static="1"><f a="cmd:?args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="Int"/>
</f></command>
		<exit public="1" line="98" static="1"><f a="code">
	<c path="Int"/>
	<e path="Void"/>
</f></exit>
		<time public="1" line="102" static="1"><f a=""><c path="Float"/></f></time>
		<cpuTime public="1" line="106" static="1"><f a=""><c path="Float"/></f></cpuTime>
		<executablePath public="1" line="110" static="1"><f a=""><c path="String"/></f></executablePath>
		<environment public="1" line="114" static="1"><f a=""><c path="Hash"><c path="String"/></c></f></environment>
		<get_env line="124" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></get_env>
		<put_env line="125" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></put_env>
		<_sleep line="126" static="1"><f a="">
	<c path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="127" static="1"><f a="">
	<unknown/>
	<e path="Bool"/>
</f></set_time_locale>
		<get_cwd line="128" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="129" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></set_cwd>
		<sys_string line="130" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="131" static="1"><f a="">
	<unknown/>
	<c path="Int"/>
</f></sys_command>
		<sys_exit line="132" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="133" static="1"><f a=""><c path="Float"/></f></sys_time>
		<sys_cpu_time line="134" static="1"><f a=""><c path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="135" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="136" static="1"><f a=""><c path="Array"><d/></c></f></sys_env>
	</class>
	<class path="neko.io.File" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/io/File.hx">
		<getContent public="1" line="41" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<getBytes public="1" line="45" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<read public="1" line="49" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="neko.io.FileInput"/>
</f></read>
		<write public="1" line="53" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="neko.io.FileOutput"/>
</f></write>
		<append public="1" line="57" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="neko.io.FileOutput"/>
</f></append>
		<copy public="1" line="61" static="1"><f a="src:dst">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></copy>
		<stdin public="1" line="69" static="1"><f a=""><c path="neko.io.FileInput"/></f></stdin>
		<stdout public="1" line="73" static="1"><f a=""><c path="neko.io.FileOutput"/></f></stdout>
		<stderr public="1" line="77" static="1"><f a=""><c path="neko.io.FileOutput"/></f></stderr>
		<getChar public="1" line="81" static="1"><f a="echo">
	<e path="Bool"/>
	<c path="Int"/>
</f></getChar>
		<file_stdin line="85" static="1"><f a=""><e path="neko.io.FileHandle"/></f></file_stdin>
		<file_stdout line="86" static="1"><f a=""><e path="neko.io.FileHandle"/></f></file_stdout>
		<file_stderr line="87" static="1"><f a=""><e path="neko.io.FileHandle"/></f></file_stderr>
		<file_contents line="89" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></file_contents>
		<file_open line="90" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></file_open>
		<getch line="92" static="1"><f a="">
	<e path="Bool"/>
	<c path="Int"/>
</f></getch>
		<haxe_doc>
	API for reading and writing to files.
</haxe_doc>
	</class>
	<class path="StringTools" params="" file="C:\Program Files\Motion-Twin\haxe/std/StringTools.hx">
		<urlEncode public="1" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" line="57" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" line="76" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" line="83" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" line="94" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" line="101" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" line="110" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" line="118" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" line="137" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" line="157" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" line="168" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" line="190" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" line="215" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" line="226" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<_urlEncode line="252" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></_urlEncode>
		<_urlDecode line="253" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></_urlDecode>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/Log.hx">
		<trace public="1" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" line="41" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="openvg.Handle" params="" file="../../../xinf/src/libs/openvg/api/openvg/Handle.hx" extern="1">
		<createPaint public="1" static="1">
			<f a=""><c path="openvg.Handle"/></f>
			<haxe_doc><![CDATA[ <nekobind ctor="true"/> ]]></haxe_doc>
		</createPaint>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
	<nekobind 
		translator="Capitalize"
		prefix="vg"
		nekoAbstract="__h"
		cStruct="VGHandle"
		module="openvg"
		/>
	<nekobind:cHeader>
		#include &lt;vg/openvg.h&gt;
	</nekobind:cHeader>
]]></haxe_doc>
	</class>
	<enum path="xinf.ony.type.GradientUnits" params="" file="../../../xinf/src/xinf/ony/type/GradientUnits.hx">
		<UserSpaceOnUse/>
		<ObjectBoundingBox/>
	</enum>
	<enum path="xinf.ony.type.SpreadMethod" params="" file="../../../xinf/src/xinf/ony/type/SpreadMethod.hx">
		<RepeatSpread/>
		<ReflectSpread/>
		<PadSpread/>
		<haxe_doc>
	Describes the spread method to use for gradients.
	
	SVG does not specify spread methods.
</haxe_doc>
	</enum>
	<class path="xinf.ony.Gradient" params="" file="../../../xinf/src/xinf/ony/Gradient.hx">
		<extends path="xinf.ony.erno.Element"/>
		<TRAITS line="28" static="1"><a>
	<spreadMethod><c path="xinf.traits.EnumTrait"><e path="xinf.ony.type.SpreadMethod"/></c></spreadMethod>
	<gradientUnits><c path="xinf.traits.EnumTrait"><e path="xinf.ony.type.GradientUnits"/></c></gradientUnits>
	<gradientTransform><c path="xinf.ony.traits.TransformTrait"/></gradientTransform>
</a></TRAITS>
		<href public="1" set="dynamic"><c path="String"/></href>
		<peer public="1" set="dynamic"><c path="xinf.ony.Gradient"/></peer>
		<gradientTransform public="1" get="dynamic" set="dynamic"><c path="xinf.geom.Transform"/></gradientTransform>
		<get_gradientTransform line="38"><f a=""><c path="xinf.geom.Transform"/></f></get_gradientTransform>
		<set_gradientTransform line="40"><f a="v">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></set_gradientTransform>
		<gradientUnits public="1" get="dynamic" set="dynamic"><e path="xinf.ony.type.GradientUnits"/></gradientUnits>
		<get_gradientUnits line="43"><f a=""><e path="xinf.ony.type.GradientUnits"/></f></get_gradientUnits>
		<set_gradientUnits line="45"><f a="v">
	<e path="xinf.ony.type.GradientUnits"/>
	<e path="xinf.ony.type.GradientUnits"/>
</f></set_gradientUnits>
		<spreadMethod public="1" get="dynamic" set="dynamic"><e path="xinf.ony.type.SpreadMethod"/></spreadMethod>
		<get_spreadMethod line="48"><f a=""><e path="xinf.ony.type.SpreadMethod"/></f></get_spreadMethod>
		<set_spreadMethod line="50"><f a="v">
	<e path="xinf.ony.type.SpreadMethod"/>
	<e path="xinf.ony.type.SpreadMethod"/>
</f></set_spreadMethod>
		<stops public="1" get="dynamic" set="null"><c path="Array"><t path="xinf.ony._Gradient.TGradientStop"/></c></stops>
		<get_stops line="54"><f a=""><c path="Array"><t path="xinf.ony._Gradient.TGradientStop"/></c></f></get_stops>
		<set_href line="66"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_href>
		<set_peer line="76"><f a="v">
	<c path="xinf.ony.Gradient"/>
	<c path="xinf.ony.Gradient"/>
</f></set_peer>
		<new public="1" line="61"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.RadialGradient" params="" file="../../../xinf/src/xinf/ony/RadialGradient.hx">
		<extends path="xinf.ony.Gradient"/>
		<TRAITS line="11" static="1"><a>
	<r><c path="xinf.traits.FloatTrait"/></r>
	<fy><c path="xinf.traits.FloatTrait"/></fy>
	<fx><c path="xinf.traits.FloatTrait"/></fx>
	<cy><c path="xinf.traits.FloatTrait"/></cy>
	<cx><c path="xinf.traits.FloatTrait"/></cx>
</a></TRAITS>
		<tagName line="19" static="1"><c path="String"/></tagName>
		<cx public="1" get="dynamic" set="dynamic"><c path="Float"/></cx>
		<get_cx line="22"><f a=""><c path="Float"/></f></get_cx>
		<set_cx line="23"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_cx>
		<cy public="1" get="dynamic" set="dynamic"><c path="Float"/></cy>
		<get_cy line="26"><f a=""><c path="Float"/></f></get_cy>
		<set_cy line="27"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_cy>
		<r public="1" get="dynamic" set="dynamic"><c path="Float"/></r>
		<get_r line="30"><f a=""><c path="Float"/></f></get_r>
		<set_r line="31"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_r>
		<new public="1" line="9"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.PaintServer" params="" file="../../../xinf/src/xinf/ony/erno/PaintServer.hx" interface="1"><getPaint public="1"><f a="target">
	<c path="xinf.ony.Element"/>
	<e path="xinf.erno.Paint"/>
</f></getPaint></class>
	<class path="xinf.ony.erno.RadialGradient" params="" file="../../../xinf/src/xinf/ony/erno/RadialGradient.hx">
		<extends path="xinf.ony.RadialGradient"/>
		<implements path="xinf.ony.erno.PaintServer"/>
		<getPaint public="1" line="18"><f a="target">
	<c path="xinf.ony.Element"/>
	<e path="xinf.erno.Paint"/>
</f></getPaint>
		<new public="1" line="16"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IModel" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/IModel.hx" interface="1">
		<registerProxy public="1">
			<f a="proxy">
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register an [IProxy] instance with the [Model].
	 </haxe_doc>
		</registerProxy>
		<retrieveProxy public="1">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>
	 * Retrieve an [IProxy] instance from the Model.
	 </haxe_doc>
		</retrieveProxy>
		<removeProxy public="1">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>
	 * Remove an [IProxy] instance from the Model.
	 </haxe_doc>
		</removeProxy>
		<hasProxy public="1">
			<f a="proxyName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a [Proxy] is registered
	 </haxe_doc>
		</hasProxy>
		<removeModel public="1">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove an IModel instance
	 </haxe_doc>
		</removeModel>
		<haxe_doc><![CDATA[
 * The interface definition for a PureMVC Model.
 * 
 * <p>In PureMVC, [IModel] implementors provide
 * access to [IProxy] objects by named lookup. </p>
 * 
 * <p>An [IModel] assumes these responsibilities:</p>
 * <ul>
 * <li>Maintain a cache of [IProxy] instances</li>
 * <li>Provide methods for registering, retrieving, and removing [IProxy] instances</li>
 * </ul>
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IFacade" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/IFacade.hx" interface="1">
		<implements path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<registerProxy public="1">
			<f a="proxy">
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register an [IProxy] with the [Model] by name.
	 </haxe_doc>
		</registerProxy>
		<retrieveProxy public="1">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>
	 * Retrieve a [IProxy] from the [Model] by name.
	 </haxe_doc>
		</retrieveProxy>
		<removeProxy public="1">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>
	 * Remove an [IProxy] instance from the [Model] by name.
	 </haxe_doc>
		</removeProxy>
		<hasProxy public="1">
			<f a="proxyName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a [Proxy] is registered
	 </haxe_doc>
		</hasProxy>
		<registerCommand public="1">
			<f a="noteName:commandClassRef">
				<c path="String"/>
				<c path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register an [ICommand] with the [Controller].
	 </haxe_doc>
		</registerCommand>
		<removeCommand public="1">
			<f a="notificationName">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove a previously registered [ICommand] to [INotification] mapping from the Controller.
	 </haxe_doc>
		</removeCommand>
		<hasCommand public="1">
			<f a="notificationName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a [Command] is registered for a given Notification 
	 </haxe_doc>
		</hasCommand>
		<registerMediator public="1">
			<f a="mediator">
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register an [IMediator] instance with the [View].
	 </haxe_doc>
		</registerMediator>
		<retrieveMediator public="1">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>
	 * Retrieve an [IMediator] instance from the [View].
	 </haxe_doc>
		</retrieveMediator>
		<removeMediator public="1">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>
	 * Remove a [IMediator] instance from the [View].
	 </haxe_doc>
		</removeMediator>
		<hasMediator public="1">
			<f a="mediatorName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a [Mediator] is registered or not
	 </haxe_doc>
		</hasMediator>
		<sendNotification public="1">
			<f a="notificationName:?body:?type">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Create and send an [INotification].
	 </haxe_doc>
		</sendNotification>
		<notifyObservers public="1">
			<f a="note">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Notify the [IObservers] for a particular [INotification].
	 * 
	 * <p>All previously attached [IObservers] for this [INotification]'s
	 * list are notified and are passed a reference to the [INotification] in 
	 * the order in which they were registered.</p>
	 * 
	 * <p>NOTE: Use this method only if you are sending custom Notifications. Otherwise
	 * use the sendNotification method which does not require you to create the
	 * Notification instance.</p> 
	 ]]></haxe_doc>
		</notifyObservers>
		<removeCore public="1">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove a Core 
	 </haxe_doc>
		</removeCore>
		<haxe_doc><![CDATA[
 * The interface definition for a PureMVC Facade.
 *
 * <p>The Facade Pattern suggests providing a single
 * class to act as a central point of communication 
 * for a subsystem.</p>
 * 
 * <p>In PureMVC, the Facade acts as an interface between
 * the core MVC actors (Model, View, Controller) and
 * the rest of your application.</p>
 ]]></haxe_doc>
	</class>
	<class path="Enum" params="" file="C:\Program Files\Motion-Twin\haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<enum path="neko.io.FileHandle" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/io/File.hx" module="neko.io.File"/>
	<enum path="neko.io.FileSeek" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/io/File.hx" module="neko.io.File">
		<SeekEnd/>
		<SeekCur/>
		<SeekBegin/>
	</enum>
	<class path="xinf.ony.Circle" params="" file="../../../xinf/src/xinf/ony/Circle.hx">
		<extends path="xinf.ony.erno.Element"/>
		<tagName line="13" static="1"><c path="String"/></tagName>
		<TRAITS line="15" static="1"><a>
	<r><c path="xinf.ony.traits.LengthTrait"/></r>
	<cy><c path="xinf.ony.traits.LengthTrait"/></cy>
	<cx><c path="xinf.ony.traits.LengthTrait"/></cx>
</a></TRAITS>
		<cx public="1" get="dynamic" set="dynamic"><c path="Float"/></cx>
		<get_cx line="22"><f a=""><c path="Float"/></f></get_cx>
		<set_cx line="23"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_cx>
		<cy public="1" get="dynamic" set="dynamic"><c path="Float"/></cy>
		<get_cy line="26"><f a=""><c path="Float"/></f></get_cy>
		<set_cy line="27"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_cy>
		<r public="1" get="dynamic" set="dynamic"><c path="Float"/></r>
		<get_r line="30"><f a=""><c path="Float"/></f></get_r>
		<set_r line="31"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_r>
		<new line="11"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="List" params="T" file="C:\Program Files\Motion-Twin\haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" line="56">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" line="76">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" line="100">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" line="108">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" line="118">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" line="132">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" line="149">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" line="190">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" line="229">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" line="249">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" line="268">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" line="284">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" line="49">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<class path="xinf.ony.LinearGradient" params="" file="../../../xinf/src/xinf/ony/LinearGradient.hx">
		<extends path="xinf.ony.Gradient"/>
		<TRAITS line="11" static="1"><a>
	<y2><c path="xinf.traits.FloatTrait"/></y2>
	<y1><c path="xinf.traits.FloatTrait"/></y1>
	<x2><c path="xinf.traits.FloatTrait"/></x2>
	<x1><c path="xinf.traits.FloatTrait"/></x1>
</a></TRAITS>
		<tagName line="18" static="1"><c path="String"/></tagName>
		<x1 public="1" get="dynamic" set="dynamic"><c path="Float"/></x1>
		<get_x1 line="21"><f a=""><c path="Float"/></f></get_x1>
		<set_x1 line="22"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x1>
		<y1 public="1" get="dynamic" set="dynamic"><c path="Float"/></y1>
		<get_y1 line="25"><f a=""><c path="Float"/></f></get_y1>
		<set_y1 line="26"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y1>
		<x2 public="1" get="dynamic" set="dynamic"><c path="Float"/></x2>
		<get_x2 line="29"><f a=""><c path="Float"/></f></get_x2>
		<set_x2 line="30"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x2>
		<y2 public="1" get="dynamic" set="dynamic"><c path="Float"/></y2>
		<get_y2 line="33"><f a=""><c path="Float"/></f></get_y2>
		<set_y2 line="34"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y2>
		<new public="1" line="9"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.traits.LineIncrementTrait" params="" file="../../../xinf/src/xinf/ony/traits/LineIncrementTrait.hx">
		<extends path="xinf.traits.FloatTrait"/>
		<new public="1" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="IntIter" params="" file="C:\Program Files\Motion-Twin\haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" line="43"><f a=""><e path="Bool"/></f></hasNext>
		<next public="1" line="47"><f a=""><c path="Int"/></f></next>
		<new public="1" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="xinf.inity.font.XTextFormat" params="" file="../../../xinf/src/xinf/inity/font/XTextFormat.hx">
		<extends path="xinf.erno.TextFormat"/>
		<new public="1" line="8"><f a="?family:?size:?bold:?italic">
	<c path="String"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.utilities.statemachine.State" params="" file="../../../pmvc_haxe_multicore_utilities_statemachine/src/org/puremvc/haxe/multicore/utilities/statemachine/State.hx">
		<name public="1"><c path="String"/></name>
		<entering public="1"><c path="String"/></entering>
		<exiting public="1"><c path="String"/></exiting>
		<defineTrans public="1" line="36">
			<f a="action:target">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc> 
	 * Define a transition. 
	 </haxe_doc>
		</defineTrans>
		<removeTrans public="1" line="45">
			<f a="action">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc> 
	 * Remove a previously defined transition.
	 </haxe_doc>
		</removeTrans>
		<getTarget public="1" line="53">
			<f a="action">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * Get the target state name for a given action.
	 </haxe_doc>
		</getTarget>
		<transitions>
			<c path="Hash"><c path="String"/></c>
			<haxe_doc>
	 *  Transition map of actions to target states
	 </haxe_doc>
		</transitions>
		<new public="1" line="25">
			<f a="name:?entering:?exiting">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Defines a State.
 </haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IProxy" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/IProxy.hx" interface="1">
		<implements path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<getProxyName public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Get the [Proxy] name
	 </haxe_doc>
		</getProxyName>
		<setData public="1">
			<f a="data">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the data object
	 </haxe_doc>
		</setData>
		<getData public="1">
			<f a=""><d/></f>
			<haxe_doc>
	 * Get the data object
	 </haxe_doc>
		</getData>
		<onRegister public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the Model when the [Proxy] is registered
	 </haxe_doc>
		</onRegister>
		<onRemove public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the Model when the [Proxy] is removed
	 </haxe_doc>
		</onRemove>
		<haxe_doc><![CDATA[
 * The interface definition for a PureMVC Proxy.
 *
 * <p>In PureMVC, [IProxy] implementors assume these responsibilities:</p>
 * <ul>
 * <li>Implement a common method which returns the name of the [Proxy].</li>
 * </ul>
 * <p>Additionally, [IProxy]s typically:</p>
 * <ul>
 * <li>Maintain references to one or more pieces of model data.</li>
 * <li>Provide methods for manipulating that data.</li>
 * <li>Generate [INotifications] when their model data changes.</li>
 * <li>Expose their name as a [public static var] called [NAME].</li>
 * <li>Encapsulate interaction with local or remote services used to fetch and persist model data.</li>
 * </ul>
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.proxy.Proxy" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/patterns/proxy/Proxy.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.observer.Notifier"/>
		<implements path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
		<NAME public="1" line="31" static="1"><c path="String"/></NAME>
		<getProxyName public="1" line="46">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Get the proxy name
	 </haxe_doc>
		</getProxyName>
		<setData public="1" line="54">
			<f a="data">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the data object
	 </haxe_doc>
		</setData>
		<getData public="1" line="62">
			<f a=""><d/></f>
			<haxe_doc>
	 * Get the data object
	 </haxe_doc>
		</getData>
		<onRegister public="1" line="70">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the [Model] when the [Proxy] is registered
	 </haxe_doc>
		</onRegister>
		<onRemove public="1" line="78">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the [Model] when the [Proxy] is removed
	 </haxe_doc>
		</onRemove>
		<proxyName><c path="String"/></proxyName>
		<data><d/></data>
		<new public="1" line="36">
			<f a="?proxyName:?data">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor
	 </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * A base [IProxy] implementation. 
 * 
 * <p>In PureMVC, [Proxy] classes are used to manage parts of the 
 * application's data model. </p>
 * 
 * <p>A [Proxy] might simply manage a reference to a local data object, 
 * in which case interacting with it might involve setting and 
 * getting of its data in synchronous fashion.</p>
 * 
 * <p>[Proxy] classes are also used to encapsulate the application's 
 * interaction with remote services to save or retrieve data, in which case, 
 * we adopt an asyncronous idiom; setting data (or calling a method) on the 
 * [Proxy] and listening for a [Notification] to be sent 
 * when the [Proxy] has retrieved the data from the service.</p>
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.proxy.StopWatchProxy" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/proxy/StopWatchProxy.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.proxy.Proxy"/>
		<NAME public="1" line="12" static="1"><c path="String"/></NAME>
		<SYNC public="1" line="13" static="1"><c path="String"/></SYNC>
		<TICK public="1" line="14" static="1"><c path="String"/></TICK>
		<LAP public="1" line="15" static="1"><c path="String"/></LAP>
		<RESET public="1" line="16" static="1"><c path="String"/></RESET>
		<startTimer public="1" line="34">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Start the timer.
	 *
	 * <p>Ensure the timer exists, and has a listener 
	 * placed if this is the first call.</p>
	 *
	 * <p>Then start the timer. Note, the timer is
	 * not reset first, so this is also called 
	 * when restarting a paused timer.</p>
	 ]]></haxe_doc>
		</startTimer>
		<resetTimer public="1" line="43">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Reset the timer.
	 </haxe_doc>
		</resetTimer>
		<stopTimer public="1" line="54">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Stop the timer.
	 </haxe_doc>
		</stopTimer>
		<freeze public="1" line="69">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Freeze the current lap time.
	 *
	 * <p>Send a LAP notification with the current elapsed time.</p>
	 *
	 * <p>Called when the Split button of the UI requests a split
	 * view of the current lap time (frozen) and the ongoing
	 * elapsed time as (updated with TICKS).</p>
	 ]]></haxe_doc>
		</freeze>
		<onTick line="80">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Update the time.
	 *
	 * <p>Each second, update the time and send a 
	 * TICK notification.</p> 
	 ]]></haxe_doc>
		</onTick>
		<getDisplayTime line="89">
			<f a=""><a>
	<s><c path="Int"/></s>
	<m><c path="Int"/></m>
	<h><c path="Int"/></h>
</a></f>
			<haxe_doc>
	 * Get the display time.
	 </haxe_doc>
		</getDisplayTime>
		<displayTime public="1" get="getDisplayTime" set="null"><a>
	<s><c path="Int"/></s>
	<m><c path="Int"/></m>
	<h><c path="Int"/></h>
</a></displayTime>
		<getElapsed line="104">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
	 * Get elapsed milliseconds as Date.
	 </haxe_doc>
		</getElapsed>
		<elapsed public="1" get="getElapsed" set="null"><c path="Date"/></elapsed>
		<start><c path="Date"/></start>
		<now><c path="Date"/></now>
		<timer><c path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.proxy.Timer"/></timer>
		<new public="1" line="18"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.proxy.Timer" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/proxy/StopWatchProxy.hx" module="org.puremvc.haxe.multicore.demos.xinf.stopwatch.proxy.StopWatchProxy">
		<callBack><f a=""><e path="Void"/></f></callBack>
		<milliInterval><c path="Int"/></milliInterval>
		<maxTicks><c path="Int"/></maxTicks>
		<ticks><c path="Int"/></ticks>
		<stopped><e path="Bool"/></stopped>
		<start public="1" line="133"><f a=""><e path="Void"/></f></start>
		<stop public="1" line="142"><f a=""><e path="Void"/></f></stop>
		<reset public="1" line="146"><f a=""><e path="Void"/></f></reset>
		<tick line="151"><f a=""><e path="Void"/></f></tick>
		<tock line="164"><f a=""><e path="Void"/></f></tock>
		<new public="1" line="125"><f a="callBack:?milliInterval:?maxTicks">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.xml.IBinding" params="" file="../../../xinf/src/xinf/xml/IBinding.hx" interface="1">
		<instantiate public="1">
			<f a="xml">
				<c path="Xml"/>
				<c path="xinf.xml.Node"/>
			</f>
			<haxe_doc> Instantiate (unmarshals/deserializes) the given [xml],
		and returns the instantiated Node.
		
		The returned Node will yet be empty ([fromXml] is not
		yet called).
	</haxe_doc>
		</instantiate>
		<add public="1">
			<f a="nodeName:cl">
				<c path="String"/>
				<c path="Class"><c path="xinf.xml.Node"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc> Bind the given [nodeName] (or tag name) to the class [cl].
		
		The class must have a constructor with only one, dynamic
		argument, like $xinf.xml.Element$, or instantiation will fail.
	</haxe_doc>
		</add>
		<addInstantiator public="1">
			<f a="i">
				<c path="xinf.xml.Instantiator"><c path="xinf.xml.Node"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc> Add the given Instantiator [i] to this Binding.
	</haxe_doc>
		</addInstantiator>
		<haxe_doc>
	Represents a Binding of XML content to instantiated $xinf.xml.Node$s.
	
	Usually, the one incarnation of this interface, $xinf.xml.Binding$,
	should be enough for most purposes.
</haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.ICommand" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/ICommand.hx" interface="1">
		<implements path="org.puremvc.haxe.multicore.interfaces.INotifier"/>
		<execute public="1">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
 	 * Execute the [ICommand]'s logic to handle a given [INotification].
 	 </haxe_doc>
		</execute>
		<haxe_doc>
 * The interface definition for a PureMVC Command.
 </haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.command.SimpleCommand" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/patterns/command/SimpleCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.observer.Notifier"/>
		<implements path="org.puremvc.haxe.multicore.interfaces.ICommand"/>
		<execute public="1" line="29">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Fulfill the use-case initiated by the given [INotification].
	 * 
	 * <p>In the Command Pattern, an application use-case typically
	 * begins with some user action, which results in an [INotification] being broadcast, which 
	 * is handled by business logic in the [execute] method of an [ICommand].</p>
	 ]]></haxe_doc>
		</execute>
		<new public="1" line="20"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
 * A base [ICommand] implementation.
 * 
 * <p>Your subclass should override the [execute] 
 * method where your business logic will handle the [INotification].</p>
 ]]></haxe_doc>
	</class>
	<class path="xinf.ony.Group" params="" file="../../../xinf/src/xinf/ony/Group.hx">
		<extends path="xinf.ony.erno.Element"/>
		<tagName line="11" static="1"><c path="String"/></tagName>
		<new line="9"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Group" params="" file="../../../xinf/src/xinf/ony/erno/Group.hx">
		<extends path="xinf.ony.Group"/>
		<new public="1" line="14"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.Definitions" params="" file="../../../xinf/src/xinf/ony/Definitions.hx">
		<extends path="xinf.ony.erno.Group"/>
		<tagName line="8" static="1"><c path="String"/></tagName>
		<new public="1" line="7"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Array" params="T" file="C:\Program Files\Motion-Twin\haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="IntHash" params="T" file="C:\Program Files\Motion-Twin\haxe/std/IntHash.hx">
		<h><d/></h>
		<set public="1" line="58">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" line="71">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" line="91">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" line="111">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" line="138">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" line="167">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" line="204">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<enum path="xinf.style.Selector" params="" file="../../../xinf/src/xinf/style/Selector.hx">
		<Unknown a="text">
			<c path="String"/>
			<haxe_doc> Unknown selector. Behaviour is undefined. </haxe_doc>
		</Unknown>
		<StyleClass a="name">
			<c path="String"/>
			<haxe_doc> Match elements with style class [name] ("[.name]")
		$CSS selector#class-html Class selectors$ </haxe_doc>
		</StyleClass>
		<Preceding a="s">
			<e path="xinf.style.Selector"/>
			<haxe_doc> Match if the element just before the element
		in question matches the given Selector [s]. 
		("[a + b]") 
		$CSS selector#adjacent-selectors Adjacent sibling selectors$ </haxe_doc>
		</Preceding>
		<Parent a="s">
			<e path="xinf.style.Selector"/>
			<haxe_doc><![CDATA[ Match if the element's parent matches 
		the given Selector [s]. ("[a > b]")
		$CSS selector#child-selectors Child selectors$ ]]></haxe_doc>
		</Parent>
		<GrandAncestor a="s">
			<e path="xinf.style.Selector"/>
			<haxe_doc> Match if the element has an ancestor
		that is not it's immediate parent and
		matches the given Selector [s]. 
		("[a * b]") 
		$CSS selector#descendant-selectors Descendant selectors$ </haxe_doc>
		</GrandAncestor>
		<ClassName a="name">
			<c path="String"/>
			<haxe_doc> Match elements with tag name [name].
		$CSS selector#type-selectors Type selectors$ </haxe_doc>
		</ClassName>
		<ById a="id">
			<c path="String"/>
			<haxe_doc> Match the element with id [id] ("[#id]")
		$CSS selector#id-selectors ID selectors$ </haxe_doc>
		</ById>
		<AnyOf a="a">
			<t path="Iterable"><e path="xinf.style.Selector"/></t>
			<haxe_doc> Match if any of the selectors in [a] match. 
		$CSS selector#grouping Grouping$ </haxe_doc>
		</AnyOf>
		<Any><haxe_doc> Match any element ("[*]").
		$CSS selector#universal-selector Universal selector$ </haxe_doc></Any>
		<Ancestor a="s">
			<e path="xinf.style.Selector"/>
			<haxe_doc> Match if the element has an ancestor
		that matches the given Selector [s]. ("[a b]")
		$CSS selector#descendant-selectors Descendant selectors$ </haxe_doc>
		</Ancestor>
		<AllOf a="a">
			<t path="Iterable"><e path="xinf.style.Selector"/></t>
			<haxe_doc> Match if all of the selectors in [a] match. </haxe_doc>
		</AllOf>
		<haxe_doc>
	CSS selectors enum.
	
	$CSS selector# CSS: Selectors$
</haxe_doc>
	</enum>
	<class path="xinf.support.DLLLoader" params="" file="../../../xinf/src/libs/xinfinity-support/api/xinf/support/DLLLoader.hx">
		<loaded public="1" static="1"><c path="Hash"><e path="Bool"/></c></loaded>
		<getHaxelibPath public="1" line="9" static="1"><f a=""><c path="String"/></f></getHaxelibPath>
		<getXinfLibPath public="1" line="32" static="1"><f a=""><c path="String"/></f></getXinfLibPath>
		<addToEnvironment public="1" line="42" static="1"><f a="name:separator:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></addToEnvironment>
		<checkEnvironment public="1" line="52" static="1"><f a="name:separator:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></checkEnvironment>
		<addLibToPath public="1" line="66" static="1"><f a="lib">
	<c path="String"/>
	<e path="Void"/>
</f></addLibToPath>
	</class>
	<class path="neko.FileSystem" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/FileSystem.hx">
		<exists public="1" line="49" static="1"><f a="path">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<rename public="1" line="53" static="1"><f a="path:newpath">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></rename>
		<stat public="1" line="57" static="1"><f a="path">
	<c path="String"/>
	<t path="neko.FileStat"/>
</f></stat>
		<fullPath public="1" line="65" static="1"><f a="relpath">
	<c path="String"/>
	<c path="String"/>
</f></fullPath>
		<kind public="1" line="69" static="1"><f a="path">
	<c path="String"/>
	<e path="neko.FileKind"/>
</f></kind>
		<isDirectory public="1" line="78" static="1"><f a="path">
	<c path="String"/>
	<e path="Bool"/>
</f></isDirectory>
		<createDirectory public="1" line="82" static="1"><f a="path">
	<c path="String"/>
	<e path="Void"/>
</f></createDirectory>
		<deleteFile public="1" line="86" static="1"><f a="path">
	<c path="String"/>
	<e path="Void"/>
</f></deleteFile>
		<deleteDirectory public="1" line="90" static="1"><f a="path">
	<c path="String"/>
	<e path="Void"/>
</f></deleteDirectory>
		<readDirectory public="1" line="94" static="1"><f a="path">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></readDirectory>
		<sys_exists line="104" static="1"><f a="">
	<unknown/>
	<e path="Bool"/>
</f></sys_exists>
		<file_delete line="105" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></file_delete>
		<sys_rename line="106" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></sys_rename>
		<sys_stat line="107" static="1"><f a="">
	<unknown/>
	<t path="neko.FileStat"/>
</f></sys_stat>
		<sys_file_type line="108" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></sys_file_type>
		<sys_create_dir line="109" static="1"><f a=":">
	<unknown/>
	<c path="Int"/>
	<unknown/>
</f></sys_create_dir>
		<sys_remove_dir line="110" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></sys_remove_dir>
		<sys_read_dir line="111" static="1"><f a="">
	<unknown/>
	<c path="Array"><d/></c>
</f></sys_read_dir>
		<file_full_path line="112" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></file_full_path>
	</class>
	<class path="haxe.io.Output" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Output.hx">
		<_float_bytes line="241" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_float_bytes>
		<_double_bytes line="242" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_double_bytes>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<writeByte public="1" line="37"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" line="41"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" line="62"><f a=""><e path="Void"/></f></flush>
		<close public="1" line="65"><f a=""><e path="Void"/></f></close>
		<setEndian line="68"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<write public="1" line="75"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<writeFullBytes public="1" line="86"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<writeFloat public="1" line="94"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" line="104"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" line="114"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" line="120"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" line="125"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt24 public="1" line="136"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt24 public="1" line="141"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt31 public="1" line="154"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt30 public="1" line="171"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt32 public="1" line="186"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<prepare public="1" line="206">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.
	</haxe_doc>
		</prepare>
		<writeInput public="1" line="209"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<writeString public="1" line="231"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<haxe_doc>
	An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.
</haxe_doc>
	</class>
	<class path="neko.io.FileOutput" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="68" static="1"><f a="">
	<e path="neko.io.FileHandle"/>
	<unknown/>
</f></file_close>
		<file_seek line="69" static="1"><f a="::">
	<e path="neko.io.FileHandle"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="70" static="1"><f a="">
	<e path="neko.io.FileHandle"/>
	<c path="Int"/>
</f></file_tell>
		<file_eof line="71" static="1"><f a="">
	<e path="neko.io.FileHandle"/>
	<e path="Bool"/>
</f></file_eof>
		<file_flush line="73" static="1"><f a="">
	<e path="neko.io.FileHandle"/>
	<unknown/>
</f></file_flush>
		<file_write line="74" static="1"><f a=":::">
	<e path="neko.io.FileHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_write>
		<file_write_char line="75" static="1"><f a=":">
	<e path="neko.io.FileHandle"/>
	<c path="Int"/>
	<unknown/>
</f></file_write_char>
		<__f><e path="neko.io.FileHandle"/></__f>
		<seek public="1" line="56"><f a="p:pos">
	<c path="Int"/>
	<e path="neko.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" line="60"><f a=""><c path="Int"/></f></tell>
		<eof public="1" line="64"><f a=""><e path="Bool"/></f></eof>
		<new public="1" line="35"><f a="f">
	<e path="neko.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [neko.io.File.write] to create a [FileOutput]
</haxe_doc>
	</class>
	<class path="xinf.support.Pixbuf" params="" file="../../../xinf/src/libs/xinfinity-support/api/xinf/support/Pixbuf.hx" extern="1">
		<newFromCompressedData public="1" static="1">
			<f a="data">
				<d/>
				<c path="xinf.support.Pixbuf"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind ctor="true"/>	]]></haxe_doc>
		</newFromCompressedData>
		<newFromRGB public="1" static="1">
			<f a="data:width:height:hasAlpha">
				<d/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="xinf.support.Pixbuf"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind ctor="true"/>	]]></haxe_doc>
		</newFromRGB>
		<width public="1" get="getWidth" set="null"><c path="Int"/></width>
		<height public="1" get="getHeight" set="null"><c path="Int"/></height>
		<getWidth public="1"><f a=""><c path="Int"/></f></getWidth>
		<getHeight public="1"><f a=""><c path="Int"/></f></getHeight>
		<getRowstride public="1"><f a=""><c path="Int"/></f></getRowstride>
		<getHasAlpha public="1"><f a=""><c path="Int"/></f></getHasAlpha>
		<copyPixels public="1"><f a=""><d/></f></copyPixels>
		<encode public="1"><f a="format">
	<c path="String"/>
	<d/>
</f></encode>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
	Wraps GdkPixbuf structure.
	
	<nekobind 
		translator="CamelCaseToMinuscleUnderscore"
		prefix="gdk_pixbuf_"
		nekoAbstract="__pixbuf"
		cStruct="GdkPixbuf*"
		dtor="unref"
		module="xinfinity-support"
		/>
	<nekobind:cHeader>
		#include &lt;gdk-pixbuf/gdk-pixbuf.h&gt;
		#include "neko-pixbuf.h"
	</nekobind:cHeader>
]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.controller.InjectFSMCommand" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/controller/InjectFSMCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.command.SimpleCommand"/>
		<new public="1" line="16"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * Create and inject the StateMachine.
 </haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.IObserver" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/IObserver.hx" interface="1">
		<setNotifyMethod public="1">
			<f a="notifyMethod">
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Set the notification method.
	 * 
	 * <p>The notification method should take one parameter of type [INotification]</p>
	 ]]></haxe_doc>
		</setNotifyMethod>
		<setNotifyContext public="1">
			<f a="notifyContext">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the notification context.
	 </haxe_doc>
		</setNotifyContext>
		<notifyObserver public="1">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Notify the interested object.
	 </haxe_doc>
		</notifyObserver>
		<compareNotifyContext public="1">
			<f a="object">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Compare the given object to the notificaiton context object.
	 </haxe_doc>
		</compareNotifyContext>
		<haxe_doc><![CDATA[
 * The interface definition for a PureMVC Observer.
 *
 * <p>In PureMVC, [IObserver] implementors assume these responsibilities:
 * <ul>
 * <li>Encapsulate the notification (callback) method of the interested object.</li>
 * <li>Encapsulate the notification context (this) of the interested object.</li>
 * <li>Provide methods for setting the interested object' notification method and context.</li>
 * <li>Provide a method for notifying the interested object.</li>
 * </ul>
 * 
 * <p>PureMVC does not rely upon underlying event
 * models such as the one provided with Flash.</p>
 * 
 * <p>The Observer Pattern as implemented within
 * PureMVC exists to support event driven communication
 * between the application and the actors of the MVC triad.</p>
 * 
 * <p> An Observer is an object that encapsulates information
 * about an interested object with a notification method that
 * should be called when an [INotification] is broadcast. The Observer then
 * acts as a proxy for notifying the interested object.
 * 
 * <p>Observers can receive [Notification]s by having their
 * [notifyObserver] method invoked, passing
 * in an object implementing the [INotification] interface, such
 * as a subclass of [Notification].</p>
 ]]></haxe_doc>
	</class>
	<enum path="xinf.ony.type.PreserveAspectRatio" params="" file="../../../xinf/src/xinf/ony/type/PreserveAspectRatio.hx">
		<Preserve a="x:y">
			<e path="xinf.ony.type.Align"/>
			<e path="xinf.ony.type.Align"/>
			<haxe_doc>
		Preserve aspect ratio with the given
		alignment on X- resp. Y-Axis.
	</haxe_doc>
		</Preserve>
		<None><haxe_doc>
		Do not preserve aspect ratio, scale the
		graphic non-uniformly to fit the viewport.
	</haxe_doc></None>
		<Meet a="o">
			<e path="xinf.ony.type.PreserveAspectRatio"/>
			<haxe_doc>
		Not quite sure what the "meet" argument implies.
		The SVG specification calls it "optional and only
		available due to historical reasons", so it 
		can probably be ignored.
		
		Current implementation just ignores it, and
		applies [o].
	</haxe_doc>
		</Meet>
		<Defer a="o">
			<e path="xinf.ony.type.PreserveAspectRatio"/>
			<haxe_doc>
		Defers preservance of aspect ratio to the referenced
		element, or uses [o] if the referenced element does
		not express a method.
		
		This is not factually implemented.
	</haxe_doc>
		</Defer>
		<haxe_doc>
	The PreserveAspectRatio enum describes the method
	used to uniformly stretch some graphic element.
	
	For example, SVG's "defer xMinYMax meet" is expressed
	as [Defer( Meet( Preserve( Min, Max ) )].
	
	$xinf.ony.traits.PreserveAspectRatioTrait::align$ can be used
	to apply the method to a given viewBox/viewport combination.

	$SVG coords#PreserveAspectRatioAttribute The 'preserveAspectRatio' attribute$
</haxe_doc>
	</enum>
	<enum path="xinf.ony.type.Align" params="" file="../../../xinf/src/xinf/ony/type/PreserveAspectRatio.hx" module="xinf.ony.type.PreserveAspectRatio">
		<Min><haxe_doc> align the graphic's left edge to the viewport's
		left edge (or respectively top to top) </haxe_doc></Min>
		<Mid><haxe_doc> align the graphic's center to the viewport's
		center </haxe_doc></Mid>
		<Max><haxe_doc> align the graphic's right edge to the viewport's
		right edge (or respectively bottom to bottom) </haxe_doc></Max>
		<haxe_doc>
	Possible values for 
	$xinf.ony.type.PreserveAspectRatio$.Preserve(x,y).
</haxe_doc>
	</enum>
	<class path="xinf.ony.traits.PreserveAspectRatioTrait" params="" file="../../../xinf/src/xinf/ony/traits/PreserveAspectRatioTrait.hx">
		<extends path="xinf.traits.TypedTrait"><e path="xinf.ony.type.PreserveAspectRatio"/></extends>
		<ws line="31" static="1"><c path="EReg"/></ws>
		<par line="32" static="1"><c path="EReg"/></par>
		<align public="1" line="78" static="1"><f a="p:viewBox:viewPort">
	<e path="xinf.ony.type.PreserveAspectRatio"/>
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.ony.traits.TRect"/>
</f></align>
		<alignPreserve line="93" static="1"><f a="viewBox:viewPort:x:y">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
	<e path="xinf.ony.type.Align"/>
	<e path="xinf.ony.type.Align"/>
	<t path="xinf.ony.traits.TRect"/>
</f></alignPreserve>
		<def><e path="xinf.ony.type.PreserveAspectRatio"/></def>
		<parsePart line="65"><f a="s">
	<c path="String"/>
	<e path="xinf.ony.type.Align"/>
</f></parsePart>
		<new public="1" line="21"><f a="?def">
	<e path="xinf.ony.type.PreserveAspectRatio"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.Image" params="" file="../../../xinf/src/xinf/ony/Image.hx">
		<extends path="xinf.ony.erno.Element"/>
		<tagName line="17" static="1"><c path="String"/></tagName>
		<TRAITS line="19" static="1"><a>
	<y><c path="xinf.ony.traits.LengthTrait"/></y>
	<x><c path="xinf.ony.traits.LengthTrait"/></x>
	<width><c path="xinf.ony.traits.LengthTrait"/></width>
	<preserveAspectRatio><c path="xinf.ony.traits.PreserveAspectRatioTrait"/></preserveAspectRatio>
	<href><c path="xinf.traits.StringTrait"/></href>
	<height><c path="xinf.ony.traits.LengthTrait"/></height>
</a></TRAITS>
		<x public="1" get="dynamic" set="dynamic"><c path="Float"/></x>
		<get_x line="30"><f a=""><c path="Float"/></f></get_x>
		<set_x line="31"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x>
		<y public="1" get="dynamic" set="dynamic"><c path="Float"/></y>
		<get_y line="34"><f a=""><c path="Float"/></f></get_y>
		<set_y line="35"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y>
		<width public="1" get="dynamic" set="dynamic"><t path="Null"><c path="Float"/></t></width>
		<get_width line="38"><f a=""><c path="Float"/></f></get_width>
		<set_width line="39"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_width>
		<height public="1" get="dynamic" set="dynamic"><t path="Null"><c path="Float"/></t></height>
		<get_height line="42"><f a=""><c path="Float"/></f></get_height>
		<set_height line="43"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_height>
		<href public="1" get="dynamic" set="dynamic"><c path="String"/></href>
		<get_href line="46"><f a=""><c path="String"/></f></get_href>
		<set_href line="47"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_href>
		<preserveAspectRatio public="1" get="dynamic" set="dynamic"><e path="xinf.ony.type.PreserveAspectRatio"/></preserveAspectRatio>
		<get_preserveAspectRatio line="50"><f a=""><e path="xinf.ony.type.PreserveAspectRatio"/></f></get_preserveAspectRatio>
		<set_preserveAspectRatio line="51"><f a="v">
	<e path="xinf.ony.type.PreserveAspectRatio"/>
	<e path="xinf.ony.type.PreserveAspectRatio"/>
</f></set_preserveAspectRatio>
		<new line="15"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.event.ScrollEvent" params="" file="../../../xinf/src/xinf/event/ScrollEvent.hx">
		<extends path="xinf.event.Event"><c path="xinf.event.ScrollEvent"/></extends>
		<SCROLL_STEP public="1" line="11" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.ScrollEvent"/></c></SCROLL_STEP>
		<SCROLL_LEAP public="1" line="12" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.ScrollEvent"/></c></SCROLL_LEAP>
		<SCROLL_TO public="1" line="13" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.ScrollEvent"/></c></SCROLL_TO>
		<value public="1"><c path="Float"/></value>
		<targetId public="1"><t path="Null"><c path="Int"/></t></targetId>
		<new public="1" line="18"><f a="_type:value:?targetId">
	<c path="xinf.event.EventKind"><c path="xinf.event.ScrollEvent"/></c>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	
</haxe_doc>
	</class>
	<enum path="neko.vm.ThreadHandle" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/vm/Thread.hx" module="neko.vm.Thread"/>
	<class path="neko.vm.Thread" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/vm/Thread.hx">
		<current public="1" line="49" static="1">
			<f a=""><c path="neko.vm.Thread"/></f>
			<haxe_doc>
		Returns the current thread.
	</haxe_doc>
		</current>
		<create public="1" line="56" static="1">
			<f a="callb">
				<f a=""><e path="Void"/></f>
				<c path="neko.vm.Thread"/>
			</f>
			<haxe_doc>
		Creates a new thread that will execute the [callb] function, then exit.
	</haxe_doc>
		</create>
		<readMessage public="1" line="65" static="1">
			<f a="block">
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc>
		Reads a message from the thread queue. If [block] is true, the function
		blocks until a message is available. If [block] is false, the function
		returns [null] if no message is available.
	</haxe_doc>
		</readMessage>
		<thread_create line="132" static="1">
			<f a=":">
				<f a="_">
					<unknown/>
					<e path="Void"/>
				</f>
				<unknown/>
				<e path="neko.vm.ThreadHandle"/>
			</f>
			<haxe_doc><![CDATA[
		Starts an OS message loop after [osInitialize] has been done.
		In that state, the UI handled by this thread will be updated and
		[sync] calls can be performed. The loop returns when [exitLoop] is
		called for this thread.
	**
	public static function osLoop() {
		if( os_loop == null ) throw "Please call osInitialize() first";
		os_loop();
	}

	/**
		The function [f] will be called by this thread if it's in [osLoop].
		[sync] returns immediatly. See [osInitialize] remarks.
	**
	public function sync( f : Void -> Void ) {
		os_sync(handle,f);
	}

	/**
		The function [f] will be called by this thread and the calling thread
		will wait until the result is available then return its value.
	**
	public function syncResult<T>( f : Void -> T ) : T {
		if( this == current() )
			return f();
		var v = new neko.vm.Lock();
		var r = null;
		sync(function() {
			r = f();
			v.release();
		});
		v.wait();
		return r;
	}

	/**
		Exit from [osLoop].
	**
	public function exitLoop() {
		os_loop_stop(handle);
	}

	/**
		If you want to use the [osLoop], [sync] and [syncResult] methods, you
		need to call [osInitialize] before creating any thread or calling [current].
		This will load [os.ndll] library and initialize UI methods for each thread.
	**
	public static function osInitialize() {
		os_loop = neko.Lib.load("os","os_loop",0);
		os_loop_stop = neko.Lib.load("os","os_loop_stop",1);
		os_sync = neko.Lib.load("os","os_sync",2);
	}

	static var os_loop = null;
	static var os_loop_stop = null;
	static var os_sync = null;
	]]></haxe_doc>
		</thread_create>
		<thread_current line="133" static="1"><f a=""><e path="neko.vm.ThreadHandle"/></f></thread_current>
		<thread_send line="134" static="1"><f a=":">
	<e path="neko.vm.ThreadHandle"/>
	<d/>
	<unknown/>
</f></thread_send>
		<thread_read_message line="135" static="1"><f a="">
	<e path="Bool"/>
	<unknown/>
</f></thread_read_message>
		<handle><e path="neko.vm.ThreadHandle"/></handle>
		<sendMessage public="1" line="41">
			<f a="msg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Send a message to the thread queue. This message can be readed by using [readMessage].
	</haxe_doc>
		</sendMessage>
		<__compare line="69"><f a="t">
	<a><handle><unknown/></handle></a>
	<unknown/>
</f></__compare>
		<new line="34"><f a="h">
	<e path="neko.vm.ThreadHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" line="199" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" line="223" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" line="258" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" line="49"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" line="61"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" line="89"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" line="108"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" line="140"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" line="180"><f a=""><c path="String"/></f></toString>
		<getData public="1" line="195"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="opengl.DLLLoader" params="" file="../../../xinf/src/libs/opengl/api/opengl/DLLLoader.hx">
		<loaded public="1" static="1"><c path="Hash"><e path="Bool"/></c></loaded>
		<getHaxelibPath public="1" line="9" static="1"><f a=""><c path="String"/></f></getHaxelibPath>
		<getXinfLibPath public="1" line="32" static="1"><f a=""><c path="String"/></f></getXinfLibPath>
		<addToEnvironment public="1" line="42" static="1"><f a="name:separator:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></addToEnvironment>
		<checkEnvironment public="1" line="53" static="1"><f a="name:separator:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></checkEnvironment>
		<addLibToPath public="1" line="67" static="1"><f a="lib">
	<c path="String"/>
	<e path="Void"/>
</f></addLibToPath>
	</class>
	<class path="opengl.GLFW" params="" file="../../../xinf/src/libs/opengl/api/opengl/GLFW.hx" extern="1">
		<VERSION_MAJOR public="1" static="1"><c path="Int"/></VERSION_MAJOR>
		<VERSION_MINOR public="1" static="1"><c path="Int"/></VERSION_MINOR>
		<VERSION_REVISION public="1" static="1"><c path="Int"/></VERSION_REVISION>
		<RELEASE public="1" static="1"><c path="Int"/></RELEASE>
		<PRESS public="1" static="1"><c path="Int"/></PRESS>
		<KEY_UNKNOWN public="1" static="1"><c path="Int"/></KEY_UNKNOWN>
		<KEY_SPACE public="1" static="1"><c path="Int"/></KEY_SPACE>
		<KEY_SPECIAL public="1" static="1"><c path="Int"/></KEY_SPECIAL>
		<KEY_ESC public="1" static="1"><c path="Int"/></KEY_ESC>
		<KEY_F1 public="1" static="1"><c path="Int"/></KEY_F1>
		<KEY_F2 public="1" static="1"><c path="Int"/></KEY_F2>
		<KEY_F3 public="1" static="1"><c path="Int"/></KEY_F3>
		<KEY_F4 public="1" static="1"><c path="Int"/></KEY_F4>
		<KEY_F5 public="1" static="1"><c path="Int"/></KEY_F5>
		<KEY_F6 public="1" static="1"><c path="Int"/></KEY_F6>
		<KEY_F7 public="1" static="1"><c path="Int"/></KEY_F7>
		<KEY_F8 public="1" static="1"><c path="Int"/></KEY_F8>
		<KEY_F9 public="1" static="1"><c path="Int"/></KEY_F9>
		<KEY_F10 public="1" static="1"><c path="Int"/></KEY_F10>
		<KEY_F11 public="1" static="1"><c path="Int"/></KEY_F11>
		<KEY_F12 public="1" static="1"><c path="Int"/></KEY_F12>
		<KEY_F13 public="1" static="1"><c path="Int"/></KEY_F13>
		<KEY_F14 public="1" static="1"><c path="Int"/></KEY_F14>
		<KEY_F15 public="1" static="1"><c path="Int"/></KEY_F15>
		<KEY_F16 public="1" static="1"><c path="Int"/></KEY_F16>
		<KEY_F17 public="1" static="1"><c path="Int"/></KEY_F17>
		<KEY_F18 public="1" static="1"><c path="Int"/></KEY_F18>
		<KEY_F19 public="1" static="1"><c path="Int"/></KEY_F19>
		<KEY_F20 public="1" static="1"><c path="Int"/></KEY_F20>
		<KEY_F21 public="1" static="1"><c path="Int"/></KEY_F21>
		<KEY_F22 public="1" static="1"><c path="Int"/></KEY_F22>
		<KEY_F23 public="1" static="1"><c path="Int"/></KEY_F23>
		<KEY_F24 public="1" static="1"><c path="Int"/></KEY_F24>
		<KEY_F25 public="1" static="1"><c path="Int"/></KEY_F25>
		<KEY_UP public="1" static="1"><c path="Int"/></KEY_UP>
		<KEY_DOWN public="1" static="1"><c path="Int"/></KEY_DOWN>
		<KEY_LEFT public="1" static="1"><c path="Int"/></KEY_LEFT>
		<KEY_RIGHT public="1" static="1"><c path="Int"/></KEY_RIGHT>
		<KEY_LSHIFT public="1" static="1"><c path="Int"/></KEY_LSHIFT>
		<KEY_RSHIFT public="1" static="1"><c path="Int"/></KEY_RSHIFT>
		<KEY_LCTRL public="1" static="1"><c path="Int"/></KEY_LCTRL>
		<KEY_RCTRL public="1" static="1"><c path="Int"/></KEY_RCTRL>
		<KEY_LALT public="1" static="1"><c path="Int"/></KEY_LALT>
		<KEY_RALT public="1" static="1"><c path="Int"/></KEY_RALT>
		<KEY_TAB public="1" static="1"><c path="Int"/></KEY_TAB>
		<KEY_ENTER public="1" static="1"><c path="Int"/></KEY_ENTER>
		<KEY_BACKSPACE public="1" static="1"><c path="Int"/></KEY_BACKSPACE>
		<KEY_INSERT public="1" static="1"><c path="Int"/></KEY_INSERT>
		<KEY_DEL public="1" static="1"><c path="Int"/></KEY_DEL>
		<KEY_PAGEUP public="1" static="1"><c path="Int"/></KEY_PAGEUP>
		<KEY_PAGEDOWN public="1" static="1"><c path="Int"/></KEY_PAGEDOWN>
		<KEY_HOME public="1" static="1"><c path="Int"/></KEY_HOME>
		<KEY_END public="1" static="1"><c path="Int"/></KEY_END>
		<KEY_KP_0 public="1" static="1"><c path="Int"/></KEY_KP_0>
		<KEY_KP_1 public="1" static="1"><c path="Int"/></KEY_KP_1>
		<KEY_KP_2 public="1" static="1"><c path="Int"/></KEY_KP_2>
		<KEY_KP_3 public="1" static="1"><c path="Int"/></KEY_KP_3>
		<KEY_KP_4 public="1" static="1"><c path="Int"/></KEY_KP_4>
		<KEY_KP_5 public="1" static="1"><c path="Int"/></KEY_KP_5>
		<KEY_KP_6 public="1" static="1"><c path="Int"/></KEY_KP_6>
		<KEY_KP_7 public="1" static="1"><c path="Int"/></KEY_KP_7>
		<KEY_KP_8 public="1" static="1"><c path="Int"/></KEY_KP_8>
		<KEY_KP_9 public="1" static="1"><c path="Int"/></KEY_KP_9>
		<KEY_KP_DIVIDE public="1" static="1"><c path="Int"/></KEY_KP_DIVIDE>
		<KEY_KP_MULTIPLY public="1" static="1"><c path="Int"/></KEY_KP_MULTIPLY>
		<KEY_KP_SUBTRACT public="1" static="1"><c path="Int"/></KEY_KP_SUBTRACT>
		<KEY_KP_ADD public="1" static="1"><c path="Int"/></KEY_KP_ADD>
		<KEY_KP_DECIMAL public="1" static="1"><c path="Int"/></KEY_KP_DECIMAL>
		<KEY_KP_EQUAL public="1" static="1"><c path="Int"/></KEY_KP_EQUAL>
		<KEY_KP_ENTER public="1" static="1"><c path="Int"/></KEY_KP_ENTER>
		<KEY_LAST public="1" static="1"><c path="Int"/></KEY_LAST>
		<MOUSE_BUTTON_1 public="1" static="1"><c path="Int"/></MOUSE_BUTTON_1>
		<MOUSE_BUTTON_2 public="1" static="1"><c path="Int"/></MOUSE_BUTTON_2>
		<MOUSE_BUTTON_3 public="1" static="1"><c path="Int"/></MOUSE_BUTTON_3>
		<MOUSE_BUTTON_4 public="1" static="1"><c path="Int"/></MOUSE_BUTTON_4>
		<MOUSE_BUTTON_5 public="1" static="1"><c path="Int"/></MOUSE_BUTTON_5>
		<MOUSE_BUTTON_6 public="1" static="1"><c path="Int"/></MOUSE_BUTTON_6>
		<MOUSE_BUTTON_7 public="1" static="1"><c path="Int"/></MOUSE_BUTTON_7>
		<MOUSE_BUTTON_8 public="1" static="1"><c path="Int"/></MOUSE_BUTTON_8>
		<MOUSE_BUTTON_LAST public="1" static="1"><c path="Int"/></MOUSE_BUTTON_LAST>
		<MOUSE_BUTTON_LEFT public="1" static="1"><c path="Int"/></MOUSE_BUTTON_LEFT>
		<MOUSE_BUTTON_RIGHT public="1" static="1"><c path="Int"/></MOUSE_BUTTON_RIGHT>
		<MOUSE_BUTTON_MIDDLE public="1" static="1"><c path="Int"/></MOUSE_BUTTON_MIDDLE>
		<JOYSTICK_1 public="1" static="1"><c path="Int"/></JOYSTICK_1>
		<JOYSTICK_2 public="1" static="1"><c path="Int"/></JOYSTICK_2>
		<JOYSTICK_3 public="1" static="1"><c path="Int"/></JOYSTICK_3>
		<JOYSTICK_4 public="1" static="1"><c path="Int"/></JOYSTICK_4>
		<JOYSTICK_5 public="1" static="1"><c path="Int"/></JOYSTICK_5>
		<JOYSTICK_6 public="1" static="1"><c path="Int"/></JOYSTICK_6>
		<JOYSTICK_7 public="1" static="1"><c path="Int"/></JOYSTICK_7>
		<JOYSTICK_8 public="1" static="1"><c path="Int"/></JOYSTICK_8>
		<JOYSTICK_9 public="1" static="1"><c path="Int"/></JOYSTICK_9>
		<JOYSTICK_10 public="1" static="1"><c path="Int"/></JOYSTICK_10>
		<JOYSTICK_11 public="1" static="1"><c path="Int"/></JOYSTICK_11>
		<JOYSTICK_12 public="1" static="1"><c path="Int"/></JOYSTICK_12>
		<JOYSTICK_13 public="1" static="1"><c path="Int"/></JOYSTICK_13>
		<JOYSTICK_14 public="1" static="1"><c path="Int"/></JOYSTICK_14>
		<JOYSTICK_15 public="1" static="1"><c path="Int"/></JOYSTICK_15>
		<JOYSTICK_16 public="1" static="1"><c path="Int"/></JOYSTICK_16>
		<JOYSTICK_LAST public="1" static="1"><c path="Int"/></JOYSTICK_LAST>
		<WINDOW public="1" static="1"><c path="Int"/></WINDOW>
		<FULLSCREEN public="1" static="1"><c path="Int"/></FULLSCREEN>
		<OPENED public="1" static="1"><c path="Int"/></OPENED>
		<ACTIVE public="1" static="1"><c path="Int"/></ACTIVE>
		<ICONIFIED public="1" static="1"><c path="Int"/></ICONIFIED>
		<ACCELERATED public="1" static="1"><c path="Int"/></ACCELERATED>
		<RED_BITS public="1" static="1"><c path="Int"/></RED_BITS>
		<GREEN_BITS public="1" static="1"><c path="Int"/></GREEN_BITS>
		<BLUE_BITS public="1" static="1"><c path="Int"/></BLUE_BITS>
		<ALPHA_BITS public="1" static="1"><c path="Int"/></ALPHA_BITS>
		<DEPTH_BITS public="1" static="1"><c path="Int"/></DEPTH_BITS>
		<STENCIL_BITS public="1" static="1"><c path="Int"/></STENCIL_BITS>
		<REFRESH_RATE public="1" static="1"><c path="Int"/></REFRESH_RATE>
		<ACCUM_RED_BITS public="1" static="1"><c path="Int"/></ACCUM_RED_BITS>
		<ACCUM_GREEN_BITS public="1" static="1"><c path="Int"/></ACCUM_GREEN_BITS>
		<ACCUM_BLUE_BITS public="1" static="1"><c path="Int"/></ACCUM_BLUE_BITS>
		<ACCUM_ALPHA_BITS public="1" static="1"><c path="Int"/></ACCUM_ALPHA_BITS>
		<AUX_BUFFERS public="1" static="1"><c path="Int"/></AUX_BUFFERS>
		<STEREO public="1" static="1"><c path="Int"/></STEREO>
		<MOUSE_CURSOR public="1" static="1"><c path="Int"/></MOUSE_CURSOR>
		<STICKY_KEYS public="1" static="1"><c path="Int"/></STICKY_KEYS>
		<STICKY_MOUSE_BUTTONS public="1" static="1"><c path="Int"/></STICKY_MOUSE_BUTTONS>
		<SYSTEM_KEYS public="1" static="1"><c path="Int"/></SYSTEM_KEYS>
		<KEY_REPEAT public="1" static="1"><c path="Int"/></KEY_REPEAT>
		<AUTO_POLL_EVENTS public="1" static="1"><c path="Int"/></AUTO_POLL_EVENTS>
		<WAIT public="1" static="1"><c path="Int"/></WAIT>
		<NOWAIT public="1" static="1"><c path="Int"/></NOWAIT>
		<PRESENT public="1" static="1"><c path="Int"/></PRESENT>
		<AXES public="1" static="1"><c path="Int"/></AXES>
		<BUTTONS public="1" static="1"><c path="Int"/></BUTTONS>
		<NO_RESCALE_BIT public="1" static="1"><c path="Int"/></NO_RESCALE_BIT>
		<ORIGIN_UL_BIT public="1" static="1"><c path="Int"/></ORIGIN_UL_BIT>
		<BUILD_MIPMAPS_BIT public="1" static="1"><c path="Int"/></BUILD_MIPMAPS_BIT>
		<ALPHA_MAP_BIT public="1" static="1"><c path="Int"/></ALPHA_MAP_BIT>
		<INFINITY public="1" static="1"><c path="Int"/></INFINITY>
		<terminate public="1" static="1"><f a=""><e path="Void"/></f></terminate>
		<openWindow public="1" static="1"><f a="width:height:redBits:greenBits:blueBits:alphaBits:depthBits:stencilBits:mode">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></openWindow>
		<openWindowHint public="1" static="1"><f a="target:hint">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></openWindowHint>
		<closeWindow public="1" static="1"><f a=""><e path="Void"/></f></closeWindow>
		<setWindowTitle public="1" static="1"><f a="title">
	<c path="String"/>
	<e path="Void"/>
</f></setWindowTitle>
		<setWindowSize public="1" static="1"><f a="width:height">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setWindowSize>
		<setWindowPos public="1" static="1"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setWindowPos>
		<iconifyWindow public="1" static="1"><f a=""><e path="Void"/></f></iconifyWindow>
		<restoreWindow public="1" static="1"><f a=""><e path="Void"/></f></restoreWindow>
		<swapBuffers public="1" static="1"><f a=""><e path="Void"/></f></swapBuffers>
		<swapInterval public="1" static="1"><f a="interval">
	<c path="Int"/>
	<e path="Void"/>
</f></swapInterval>
		<getWindowParam public="1" static="1"><f a="param">
	<c path="Int"/>
	<c path="Int"/>
</f></getWindowParam>
		<setWindowSizeFunction public="1" static="1"><f a="f">
	<d/>
	<e path="Void"/>
</f></setWindowSizeFunction>
		<setWindowCloseFunction public="1" static="1"><f a="f">
	<d/>
	<e path="Void"/>
</f></setWindowCloseFunction>
		<setWindowRefreshFunction public="1" static="1"><f a="f">
	<d/>
	<e path="Void"/>
</f></setWindowRefreshFunction>
		<pollEvents public="1" static="1"><f a=""><e path="Void"/></f></pollEvents>
		<waitEvents public="1" static="1"><f a=""><e path="Void"/></f></waitEvents>
		<getKey public="1" static="1"><f a="key">
	<c path="Int"/>
	<c path="Int"/>
</f></getKey>
		<getMouseButton public="1" static="1"><f a="button">
	<c path="Int"/>
	<c path="Int"/>
</f></getMouseButton>
		<getMousePosition public="1" static="1"><f a=""><a>
	<y><c path="Int"/></y>
	<x><c path="Int"/></x>
</a></f></getMousePosition>
		<setMousePos public="1" static="1"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMousePos>
		<getMouseWheel public="1" static="1"><f a=""><c path="Int"/></f></getMouseWheel>
		<setMouseWheel public="1" static="1"><f a="pos">
	<c path="Int"/>
	<e path="Void"/>
</f></setMouseWheel>
		<setKeyFunction public="1" static="1"><f a="f">
	<d/>
	<e path="Void"/>
</f></setKeyFunction>
		<setCharFunction public="1" static="1"><f a="f">
	<d/>
	<e path="Void"/>
</f></setCharFunction>
		<setMouseButtonFunction public="1" static="1"><f a="f">
	<d/>
	<e path="Void"/>
</f></setMouseButtonFunction>
		<setMousePosFunction public="1" static="1"><f a="f">
	<d/>
	<e path="Void"/>
</f></setMousePosFunction>
		<setMouseWheelFunction public="1" static="1"><f a="f">
	<d/>
	<e path="Void"/>
</f></setMouseWheelFunction>
		<haxe_doc><![CDATA[
	GLFW functions. 
	
	<nekobind 
		prefix="glfw"
		module="opengl"
		global="true"
		translator="Capitalize"
		globalFinderPrefix="GLFW_"
		globalFinderCCFlags="-lGL -lGLU -lglfw -Isrc"
		/>
	<nekobind:cHeader>
	#ifdef NEKO_OSX
		#include &lt;OpenGL/gl.h&gt;
		#include &lt;OpenGL/glu.h&gt;
		#include &lt;GLUT/glut.h&gt;
	#else
		#include &lt;GL/gl.h&gt;
		#include &lt;GL/glu.h&gt;
		#include &lt;GL/glfw.h&gt;
		#include "additions.h"
	#endif
	</nekobind:cHeader>
]]></haxe_doc>
	</class>
	<class path="xinf.erno.Keys" params="" file="../../../xinf/src/xinf/erno/Keys.hx">
		<SPECIAL public="1" static="1"><c path="Int"/></SPECIAL>
		<keys static="1"><c path="IntHash"><c path="String"/></c></keys>
		<get public="1" line="73" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></get>
		<haxe_doc><![CDATA[
	DOCME: out of date!
	
	The Keys class provides a single global function ([get]) to 
	convert a runtime-specific numeric key code to a
	xinferno-standard key string.
	<br/>
	"Well-known" Keys are:
	<ul>
		<li>backspace</li>
		<li>tab</li>
		<li>escape</li>
		<li>space</li>
		<li>page up</li>
		<li>page down</li>
		<li>left</li>
		<li>up</li>
		<li>right</li>
		<li>down</li>
	</ul>
]]></haxe_doc>
	</class>
	<class path="xinf.geom.TransformParser" params="" file="../../../xinf/src/xinf/geom/TransformParser.hx">
		<D2R public="1" line="9" static="1"><c path="Float"/></D2R>
		<R2D public="1" line="10" static="1"><c path="Float"/></R2D>
		<splitNumbers line="18" static="1"><c path="EReg"/></splitNumbers>
		<translate line="19" static="1"><c path="EReg"/></translate>
		<rotate line="20" static="1"><c path="EReg"/></rotate>
		<matrix line="21" static="1"><c path="EReg"/></matrix>
		<scale line="22" static="1"><c path="EReg"/></scale>
		<skewX line="23" static="1"><c path="EReg"/></skewX>
		<skewY line="24" static="1"><c path="EReg"/></skewY>
		<transform line="26" static="1"><c path="EReg"/></transform>
		<parse public="1" line="28" static="1"><f a="text">
	<c path="String"/>
	<c path="xinf.geom.Transform"/>
</f></parse>
		<parseSingle public="1" line="45" static="1"><f a="text">
	<c path="String"/>
	<c path="xinf.geom.Transform"/>
</f></parseSingle>
	</class>
	<class path="neko.NekoArray__" params="T" file="C:\Program Files\Motion-Twin\haxe/std/neko/NekoArray__.hx">
		<implements path="Array"><c path="neko.NekoArray__.T"/></implements>
		<__name__ line="29" static="1"><c path="Array"><c path="String"/></c></__name__>
		<new1 line="39" static="1"><f a="a:l">
	<unknown/>
	<c path="Int"/>
	<c path="neko.NekoArray__"><d/></c>
</f></new1>
		<length public="1" set="null"><c path="Int"/></length>
		<concat public="1" line="50"><f a="arr">
	<c path="Array"><c path="neko.NekoArray__.T"/></c>
	<c path="Array"><c path="neko.NekoArray__.T"/></c>
</f></concat>
		<copy public="1" line="63"><f a=""><c path="Array"><c path="neko.NekoArray__.T"/></c></f></copy>
		<iterator public="1" line="67"><f a=""><t path="Iterator"><t path="Null"><c path="neko.NekoArray__.T"/></t></t></f></iterator>
		<insert public="1" line="82"><f a="pos:x">
	<c path="Int"/>
	<c path="neko.NekoArray__.T"/>
	<e path="Void"/>
</f></insert>
		<join public="1" line="97"><f a="delim">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<toString public="1" line="109"><f a=""><c path="String"/></f></toString>
		<pop public="1" line="122"><f a=""><t path="Null"><c path="neko.NekoArray__.T"/></t></f></pop>
		<push public="1" line="133"><f a="v">
	<c path="neko.NekoArray__.T"/>
	<c path="Int"/>
</f></push>
		<unshift public="1" line="142"><f a="v">
	<c path="neko.NekoArray__.T"/>
	<e path="Void"/>
</f></unshift>
		<remove public="1" line="152"><f a="v">
	<c path="neko.NekoArray__.T"/>
	<e path="Bool"/>
</f></remove>
		<reverse public="1" line="171"><f a=""><e path="Void"/></f></reverse>
		<shift public="1" line="187"><f a=""><t path="Null"><c path="neko.NekoArray__.T"/></t></f></shift>
		<slice public="1" line="202"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="neko.NekoArray__.T"/></c>
</f></slice>
		<sort public="1" line="219"><f a="f">
	<f a=":">
		<c path="neko.NekoArray__.T"/>
		<c path="neko.NekoArray__.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<splice public="1" line="244"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="neko.NekoArray__.T"/></c>
</f></splice>
		<__get line="269"><f a="pos">
	<c path="Int"/>
	<unknown/>
</f></__get>
		<__set line="273"><f a="pos:v">
	<c path="Int"/>
	<unknown/>
	<e path="Void"/>
</f></__set>
		<__double line="289"><f a="l">
	<c path="Int"/>
	<e path="Void"/>
</f></__double>
		<__neko line="306"><f a=""><unknown/></f></__neko>
		<new line="32"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.controller.PrepModelCommand" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/controller/PrepModelCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.command.SimpleCommand"/>
		<new public="1" line="12"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/BytesBuffer.hx">
		<b><e path="Void"/></b>
		<addByte public="1" line="51"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" line="63"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" line="79"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" line="108">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" line="39"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.ony._Path.PathBBox" params="" file="../../../xinf/src/xinf/ony/Path.hx" private="1" module="xinf.ony.Path">
		<l public="1"><c path="Float"/></l>
		<t public="1"><c path="Float"/></t>
		<r public="1"><c path="Float"/></r>
		<b public="1"><c path="Float"/></b>
		<calculate public="1" line="21"><f a="segments">
	<t path="Iterable"><e path="xinf.ony.type.PathSegment"/></t>
	<c path="xinf.ony._Path.PathBBox"/>
</f></calculate>
		<proc line="47"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></proc>
		<new public="1" line="17"><f a="?segments">
	<t path="Iterable"><e path="xinf.ony.type.PathSegment"/></t>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.traits.PathTrait" params="" file="../../../xinf/src/xinf/ony/traits/PathTrait.hx">
		<extends path="xinf.traits.TypedTrait"><t path="Iterable"><e path="xinf.ony.type.PathSegment"/></t></extends>
		<new public="1" line="12"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.ony.Path" params="" file="../../../xinf/src/xinf/ony/Path.hx">
		<extends path="xinf.ony.erno.Element"/>
		<TRAITS line="57" static="1"><a><d><c path="xinf.ony.traits.PathTrait"/></d></a></TRAITS>
		<tagName line="61" static="1"><c path="String"/></tagName>
		<segments public="1" get="dynamic" set="dynamic"><t path="Iterable"><e path="xinf.ony.type.PathSegment"/></t></segments>
		<get_segments line="64"><f a=""><t path="Iterable"><e path="xinf.ony.type.PathSegment"/></t></f></get_segments>
		<set_segments line="67"><f a="v">
	<t path="Iterable"><e path="xinf.ony.type.PathSegment"/></t>
	<t path="Iterable"><e path="xinf.ony.type.PathSegment"/></t>
</f></set_segments>
		<d public="1" get="dynamic" set="dynamic"><c path="String"/></d>
		<get_d line="72"><f a=""><c path="String"/></f></get_d>
		<set_d line="75"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_d>
		<new line="55"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.Use" params="" file="../../../xinf/src/xinf/ony/Use.hx">
		<extends path="xinf.ony.erno.Element"/>
		<TRAITS line="11" static="1"><a>
	<y><c path="xinf.ony.traits.LengthTrait"/></y>
	<x><c path="xinf.ony.traits.LengthTrait"/></x>
	<href><c path="xinf.traits.StringTrait"/></href>
</a></TRAITS>
		<x public="1" get="dynamic" set="dynamic"><c path="Float"/></x>
		<get_x line="18"><f a=""><c path="Float"/></f></get_x>
		<set_x line="19"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x>
		<y public="1" get="dynamic" set="dynamic"><c path="Float"/></y>
		<get_y line="22"><f a=""><c path="Float"/></f></get_y>
		<set_y line="23"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y>
		<href public="1" get="dynamic" set="dynamic"><c path="String"/></href>
		<get_href line="26"><f a=""><c path="String"/></f></get_href>
		<set_href line="27"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_href>
		<peer set="dynamic"><t path="xinf.ony.ElementImpl"/></peer>
		<set_peer line="31"><f a="p">
	<t path="xinf.ony.ElementImpl"/>
	<t path="xinf.ony.ElementImpl"/>
</f></set_peer>
		<resolve line="39"><f a=""><e path="Void"/></f></resolve>
		<new line="10"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.type.StringList" params="" file="../../../xinf/src/xinf/ony/type/StringList.hx">
		<list public="1"><c path="Array"><c path="String"/></c></list>
		<toString public="1" line="21"><f a=""><c path="String"/></f></toString>
		<new public="1" line="17"><f a="l">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
	Defines a list of String values.
	
	Used mainly for the fontFamily property of
	SVG Text.
	
	FIXME: maybe drop this, and just use Array<String>?
]]></haxe_doc>
	</class>
	<class path="xinf.erno.BasicRenderer" params="" file="../../../xinf/src/xinf/erno/BasicRenderer.hx">
		<implements path="xinf.erno.Renderer"/>
		<unimplemented line="20"><f a="?func">
	<c path="String"/>
	<e path="Void"/>
</f></unimplemented>
		<startNative public="1" line="26"><f a="o">
	<t path="xinf.erno.NativeContainer"/>
	<e path="Void"/>
</f></startNative>
		<endNative public="1" line="30"><f a=""><e path="Void"/></f></endNative>
		<startObject public="1" line="34"><f a="id">
	<c path="Int"/>
	<e path="Void"/>
</f></startObject>
		<endObject public="1" line="38"><f a=""><e path="Void"/></f></endObject>
		<destroyObject public="1" line="42"><f a="id">
	<c path="Int"/>
	<e path="Void"/>
</f></destroyObject>
		<showObject public="1" line="46"><f a="id">
	<c path="Int"/>
	<e path="Void"/>
</f></showObject>
		<setTransform public="1" line="50"><f a="id:x:y:a:b:c:d">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTransform>
		<setTranslation public="1" line="54"><f a="id:x:y">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setTranslation>
		<clipRect public="1" line="58"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></clipRect>
		<setFill public="1" line="62"><f a="?paint">
	<e path="xinf.erno.Paint"/>
	<e path="Void"/>
</f></setFill>
		<setStroke public="1" line="66"><f a="?paint:width:?caps:?join:?miterLimit:?dashArray:?dashOffset">
	<e path="xinf.erno.Paint"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></setStroke>
		<startShape public="1" line="70"><f a=""><e path="Void"/></f></startShape>
		<endShape public="1" line="74"><f a=""><e path="Void"/></f></endShape>
		<startPath public="1" line="78"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></startPath>
		<endPath public="1" line="82"><f a=""><e path="Void"/></f></endPath>
		<close public="1" line="86"><f a=""><e path="Void"/></f></close>
		<lineTo public="1" line="90"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<quadraticTo public="1" line="94"><f a="x1:y1:x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></quadraticTo>
		<cubicTo public="1" line="98"><f a="x1:y1:x2:y2:x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></cubicTo>
		<arcTo public="1" line="102"><f a="x1:y1:rx:ry:rotation:largeArc:sweep:x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></arcTo>
		<rect public="1" line="106"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></rect>
		<roundedRect public="1" line="110"><f a="x:y:w:h:rx:ry">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></roundedRect>
		<ellipse public="1" line="114"><f a="x:y:rx:ry">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></ellipse>
		<text public="1" line="118"><f a="x:y:text:format">
	<c path="Float"/>
	<c path="Float"/>
	<c path="String"/>
	<c path="xinf.erno.TextFormat"/>
	<e path="Void"/>
</f></text>
		<image public="1" line="122"><f a="img:inRegion:outRegion">
	<c path="xinf.erno.ImageData"/>
	<a>
		<y><c path="Float"/></y>
		<x><c path="Float"/></x>
		<w><c path="Float"/></w>
		<h><c path="Float"/></h>
	</a>
	<a>
		<y><c path="Float"/></y>
		<x><c path="Float"/></x>
		<w><c path="Float"/></w>
		<h><c path="Float"/></h>
	</a>
	<e path="Void"/>
</f></image>
		<native public="1" line="126"><f a="o">
	<t path="xinf.erno.NativeObject"/>
	<e path="Void"/>
</f></native>
		<new public="1" line="17"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	BasicRenderer implements all functions
	of the $xinf.erno.Renderer$ interface to throw exceptions.
	It is used as a base class for other renderers (some, like JSRenderer,
	throw exceptions for functions that they cannot satisfy, like startShape()).
</haxe_doc>
	</class>
	<class path="Class" params="T" file="C:\Program Files\Motion-Twin\haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="org.puremvc.haxe.multicore.interfaces.IController" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/IController.hx" interface="1">
		<registerCommand public="1">
			<f a="notificationName:commandClassRef">
				<c path="String"/>
				<c path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register a particular [ICommand] class as the handler 
	 * for a particular [INotification].
	 </haxe_doc>
		</registerCommand>
		<executeCommand public="1">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Execute the [ICommand] previously registered as the
	 * handler for [INotification]s with the given notification name.
	 </haxe_doc>
		</executeCommand>
		<removeCommand public="1">
			<f a="notificationName">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove a previously registered [ICommand] to [INotification] mapping.
	 </haxe_doc>
		</removeCommand>
		<hasCommand public="1">
			<f a="notificationName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a Command is registered for a given Notification 
	 </haxe_doc>
		</hasCommand>
		<removeController public="1">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove an IController instance
	 </haxe_doc>
		</removeController>
		<haxe_doc><![CDATA[
 * The interface definition for a PureMVC Controller.
 * 
 * <p>In PureMVC, an [IController] implementor 
 * follows the 'Command and Controller' strategy, and 
 * assumes these responsibilities:</p>
 * <ul>
 * <li> Remembering which [ICommand]s 
 * are intended to handle which [INotifications].</li>
 * <li> Registering itself as an [IObserver] with
 * the [View] for each [INotification] 
 * that it has an [ICommand] mapping for.</li>
 * <li> Creating a new instance of the proper [ICommand]
 * to handle a given [INotification] when notified by the [View].</li>
 * <li> Calling the [ICommand]'s [execute]
 * method, passing in the [INotification].</li>
 * </ul>
 ]]></haxe_doc>
	</class>
	<class path="xinf.ony.erno.Image" params="" file="../../../xinf/src/xinf/ony/erno/Image.hx">
		<extends path="xinf.ony.Image"/>
		<load public="1" line="66" static="1"><f a="url">
	<c path="xinf.xml.URL"/>
	<c path="xinf.erno.ImageData"/>
</f></load>
		<bitmap public="1" set="dynamic"><c path="xinf.erno.ImageData"/></bitmap>
		<set_bitmap line="27"><f a="v">
	<c path="xinf.erno.ImageData"/>
	<c path="xinf.erno.ImageData"/>
</f></set_bitmap>
		<dataLoaded line="37"><f a="e">
	<c path="xinf.event.ImageLoadEvent"/>
	<e path="Void"/>
</f></dataLoaded>
		<dataChanged line="42"><f a="e">
	<c path="xinf.event.ImageLoadEvent"/>
	<e path="Void"/>
</f></dataChanged>
		<resolve line="51"><f a=""><e path="Void"/></f></resolve>
		<new public="1" line="17"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Resource" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/Resource.hx">
		<content static="1"><c path="Array"><a>
	<name><c path="String"/></name>
	<data><c path="String"/></data>
</a></c></content>
		<listNames public="1" line="58" static="1"><f a=""><c path="Array"><c path="String"/></c></f></listNames>
		<getString public="1" line="65" static="1"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></getString>
		<getBytes public="1" line="78" static="1"><f a="name">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
	</class>
	<enum path="xinf.ony.type.Editability" params="" file="../../../xinf/src/xinf/ony/type/Editability.hx">
		<Simple/>
		<None/>
		<haxe_doc>
	Defines wether something (usually something text-related)
	should be editable or not.
	
	Currently only supported on $xinf.ony.TextArea$, not
	on $xinf.ony.Text$ (and there also maybe with
	a grain of salt).
	
	$SVG text#editable-attribute The "editable" attribute$
</haxe_doc>
	</enum>
	<class path="xinf.ony.TextArea" params="" file="../../../xinf/src/xinf/ony/TextArea.hx">
		<extends path="xinf.ony.erno.Element"/>
		<tagName line="17" static="1"><c path="String"/></tagName>
		<TRAITS line="19" static="1"><a>
	<y><c path="xinf.ony.traits.LengthTrait"/></y>
	<x><c path="xinf.ony.traits.LengthTrait"/></x>
	<width><c path="xinf.ony.traits.LengthTrait"/></width>
	<text><c path="xinf.traits.StringTrait"/></text>
	<line_increment><c path="xinf.ony.traits.LineIncrementTrait"/></line_increment>
	<height><c path="xinf.ony.traits.LengthTrait"/></height>
	<editable><c path="xinf.traits.EnumTrait"><e path="xinf.ony.type.Editability"/></c></editable>
</a></TRAITS>
		<xmlUnescape public="1" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape XML special characters of the string.
	</haxe_doc>
		</xmlUnescape>
		<x public="1" get="dynamic" set="dynamic"><c path="Float"/></x>
		<get_x line="30"><f a=""><c path="Float"/></f></get_x>
		<set_x line="31"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x>
		<y public="1" get="dynamic" set="dynamic"><c path="Float"/></y>
		<get_y line="34"><f a=""><c path="Float"/></f></get_y>
		<set_y line="35"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y>
		<width public="1" get="dynamic" set="dynamic"><c path="Float"/></width>
		<get_width line="38"><f a=""><c path="Float"/></f></get_width>
		<set_width line="39"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_width>
		<height public="1" get="dynamic" set="dynamic"><c path="Float"/></height>
		<get_height line="42"><f a=""><c path="Float"/></f></get_height>
		<set_height line="43"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_height>
		<text public="1" get="dynamic" set="dynamic"><c path="String"/></text>
		<get_text line="46"><f a=""><c path="String"/></f></get_text>
		<set_text line="47"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<editable public="1" get="dynamic" set="dynamic"><e path="xinf.ony.type.Editability"/></editable>
		<get_editable line="50"><f a=""><e path="xinf.ony.type.Editability"/></f></get_editable>
		<set_editable line="51"><f a="v">
	<e path="xinf.ony.type.Editability"/>
	<e path="xinf.ony.type.Editability"/>
</f></set_editable>
		<lineIncrement public="1" get="get_line_increment" set="set_line_increment"><c path="Float"/></lineIncrement>
		<get_line_increment line="54"><f a=""><c path="Float"/></f></get_line_increment>
		<set_line_increment line="60"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_line_increment>
		<focus public="1" line="73"><f a="?focus">
	<e path="Bool"/>
	<e path="Void"/>
</f></focus>
		<textContent line="78"><f a="xml">
	<c path="Xml"/>
	<c path="String"/>
</f></textContent>
		<new line="15"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="xinf.erno.Paint" params="" file="../../../xinf/src/xinf/erno/Paint.hx">
		<SolidColor a="r:g:b:a">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<haxe_doc> use the solid RGBA color described.
	</haxe_doc>
		</SolidColor>
		<PRadialGradient a="stops:cx:cy:r:fx:fy:transform:spread">
			<t path="Iterable"><t path="xinf.erno.TGradientStop"/></t>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="xinf.geom.Transform"/>
			<c path="Int"/>
			<haxe_doc> fill or stroke using the radial gradient described.

		[cx,cy,r,fx] and [fy] are in user space units.
		
		([cx,cy,r]) describe the center and radius of the
		largest (outermost) circle for the radial gradient.
		
		([fx,fy]) describe the focal point for the radial gradient.

		$SVG painting#RadialGradientElement Radial gradients in SVG$
	</haxe_doc>
		</PRadialGradient>
		<PLinearGradient a="stops:x1:y1:x2:y2:transform:spread">
			<t path="Iterable"><t path="xinf.erno.TGradientStop"/></t>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="xinf.geom.Transform"/>
			<c path="Int"/>
			<haxe_doc> fill or stroke using the linear gradient described.
	
		[x1,y1,x2] and [y2] describe the gradient
		vector in user space units.
	
		$SVG painting#LinearGradientElement Linear gradients in SVG$
	</haxe_doc>
		</PLinearGradient>
		<None><haxe_doc> do not stroke/fill the shape in question at all
	</haxe_doc></None>
		<haxe_doc>
	A Paint specifies the Color or Gradient (in the
	future, also Pattern or PaintServer) to use for filling
	or stroking a shape.

	$SVG painting#SpecifyingPaint Specifying paint in SVG$
</haxe_doc>
	</enum>
	<class path="xinf.ony.Style" params="" file="../../../xinf/src/xinf/ony/Style.hx">
		<extends path="xinf.ony.erno.Element"/>
		<TRAITS line="11" static="1"><a>
	<type><c path="xinf.traits.StringTrait"/></type>
	<text><c path="xinf.traits.StringTrait"/></text>
</a></TRAITS>
		<type public="1" get="dynamic" set="dynamic"><c path="String"/></type>
		<get_type line="17"><f a=""><c path="String"/></f></get_type>
		<set_type line="18"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_type>
		<text public="1" get="dynamic" set="dynamic"><c path="String"/></text>
		<get_text line="21"><f a=""><c path="String"/></f></get_text>
		<set_text line="22"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<new line="9"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.inity.font.GlyphCache" params="" file="../../../xinf/src/xinf/inity/font/GlyphCache.hx">
		<glyphs><c path="IntHash"><c path="xinf.inity.font.Glyph"/></c></glyphs>
		<size><c path="Int"/></size>
		<font><c path="xinf.inity.font.Font"/></font>
		<hint><e path="Bool"/></hint>
		<get public="1" line="20"><f a="character">
	<c path="Int"/>
	<t path="Null"><c path="xinf.inity.font.Glyph"/></t>
</f></get>
		<toString public="1" line="34"><f a=""><c path="String"/></f></toString>
		<new public="1" line="12"><f a="font:size:?hint">
	<c path="xinf.inity.font.Font"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="xinf.geom.TPoint" params="" file="../../../xinf/src/xinf/geom/Types.hx" module="xinf.geom.Types"><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></typedef>
	<typedef path="xinf.geom.TRectangle" params="" file="../../../xinf/src/xinf/geom/Types.hx" module="xinf.geom.Types"><a>
	<t><c path="Float"/></t>
	<r><c path="Float"/></r>
	<l><c path="Float"/></l>
	<b><c path="Float"/></b>
</a></typedef>
	<typedef path="xinf.geom.TMatrix" params="" file="../../../xinf/src/xinf/geom/Types.hx" module="xinf.geom.Types"><a>
	<ty><c path="Float"/></ty>
	<tx><c path="Float"/></tx>
	<d><c path="Float"/></d>
	<c><c path="Float"/></c>
	<b><c path="Float"/></b>
	<a><c path="Float"/></a>
</a></typedef>
	<enum path="xinf.ony.type.PathSegment" params="" file="../../../xinf/src/xinf/ony/type/PathSegment.hx">
		<QuadraticTo a="x1:y1:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
		</QuadraticTo>
		<MoveTo a="x:y">
			<c path="Float"/>
			<c path="Float"/>
		</MoveTo>
		<LineTo a="x:y">
			<c path="Float"/>
			<c path="Float"/>
		</LineTo>
		<CubicTo a="x1:y1:x2:y2:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
		</CubicTo>
		<Close/>
		<ArcTo a="x1:y1:rx:ry:rotation:largeArc:sweep:x:y">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<e path="Bool"/>
			<e path="Bool"/>
			<c path="Float"/>
			<c path="Float"/>
		</ArcTo>
	</enum>
	<class path="xinf.geom.Transform" params="" file="../../../xinf/src/xinf/geom/Transform.hx" interface="1">
		<getTranslation public="1"><f a=""><t path="xinf.geom.TPoint"/></f></getTranslation>
		<getScale public="1"><f a=""><t path="xinf.geom.TPoint"/></f></getScale>
		<getMatrix public="1"><f a=""><t path="xinf.geom.TMatrix"/></f></getMatrix>
		<apply public="1"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<interpolateWith public="1"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
	</class>
	<class path="xinf.ony.SolidColor" params="" file="../../../xinf/src/xinf/ony/SolidColor.hx">
		<extends path="xinf.ony.erno.Element"/>
		<TRAITS line="13" static="1"><a>
	<solid_opacity><c path="xinf.traits.BoundedFloatTrait"/></solid_opacity>
	<solid_color><c path="xinf.ony.traits.PaintTrait"/></solid_color>
</a></TRAITS>
		<solidOpacity public="1" get="get_solid_opacity" set="set_solid_opacity"><t path="Null"><c path="Float"/></t></solidOpacity>
		<get_solid_opacity line="19"><f a=""><t path="Null"><c path="Float"/></t></f></get_solid_opacity>
		<set_solid_opacity line="20"><f a="v">
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Float"/></t>
</f></set_solid_opacity>
		<solidColor public="1" get="get_solid_color" set="set_solid_color"><e path="xinf.ony.type.Paint"/></solidColor>
		<get_solid_color line="23"><f a=""><e path="xinf.ony.type.Paint"/></f></get_solid_color>
		<set_solid_color line="24"><f a="v">
	<e path="xinf.ony.type.Paint"/>
	<e path="xinf.ony.type.Paint"/>
</f></set_solid_color>
		<new line="11"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.SolidColor" params="" file="../../../xinf/src/xinf/ony/erno/SolidColor.hx">
		<extends path="xinf.ony.SolidColor"/>
		<implements path="xinf.ony.erno.PaintServer"/>
		<getPaint public="1" line="11"><f a="target">
	<c path="xinf.ony.Element"/>
	<e path="xinf.erno.Paint"/>
</f></getPaint>
		<new line="9"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Input" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Input.hx">
		<_float_of_bytes line="242" static="1"><f a=":">
	<unknown/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_float_of_bytes>
		<_double_of_bytes line="243" static="1"><f a=":">
	<unknown/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_double_of_bytes>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<readByte public="1" line="35"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" line="39"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" line="58"><f a=""><e path="Void"/></f></close>
		<setEndian line="61"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readAll public="1" line="68"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" line="89"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<read public="1" line="97"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" line="109"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" line="117"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" line="134"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" line="146"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" line="158"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" line="165"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" line="174"><f a=""><c path="Int"/></f></readUInt16>
		<readInt24 public="1" line="180"><f a=""><c path="Int"/></f></readInt24>
		<readUInt24 public="1" line="190"><f a=""><c path="Int"/></f></readUInt24>
		<readInt31 public="1" line="197"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" line="214"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" line="223"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readString public="1" line="231"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>
	An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.
</haxe_doc>
	</class>
	<class path="neko.net.SocketInput" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/net/SocketInput.hx">
		<extends path="haxe.io.Input"/>
		<socket_recv line="70" static="1"><f a=":::">
	<e path="neko.net.SocketHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></socket_recv>
		<socket_recv_char line="71" static="1"><f a="">
	<e path="neko.net.SocketHandle"/>
	<c path="Int"/>
</f></socket_recv_char>
		<socket_close line="72" static="1"><f a="">
	<e path="neko.net.SocketHandle"/>
	<unknown/>
</f></socket_close>
		<__s><e path="neko.net.SocketHandle"/></__s>
		<new public="1" line="33"><f a="s">
	<e path="neko.net.SocketHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.interfaces.INotification" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/INotification.hx" interface="1">
		<getName public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Get the name of the [INotification] instance. 
	 * No setter, should be set by constructor only
	 </haxe_doc>
		</getName>
		<setBody public="1">
			<f a="body">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the body of the [INotification] instance
	 </haxe_doc>
		</setBody>
		<getBody public="1">
			<f a=""><d/></f>
			<haxe_doc>
	 * Get the body of the [INotification] instance
	 </haxe_doc>
		</getBody>
		<setType public="1">
			<f a="type">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the type of the [INotification] instance
	 </haxe_doc>
		</setType>
		<getType public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Get the type of the [INotification] instance
	 </haxe_doc>
		</getType>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Get the string representation of the [INotification] instance
	 </haxe_doc>
		</toString>
		<haxe_doc><![CDATA[
 * The interface definition for a PureMVC Notification.
 *
 * <p>PureMVC does not rely upon underlying event models such 
 * as the one provided with Flash.</p>
 * 
 * <p>The Observer Pattern as implemented within PureMVC exists 
 * to support event-driven communication between the 
 * application and the actors of the MVC triad.</p>
 * 
 * <p>Notifications are not meant to be a replacement for Events.
 * Generally, [IMediator] implementors
 * place event listeners on their view components, which they
 * then handle in the usual way. This may lead to the broadcast of [Notification]s to 
 * trigger [ICommand]s or to communicate with other [IMediators]. [IProxy] and [ICommand]
 * instances communicate with each other and [IMediator]s 
 * by broadcasting [INotification]s.</p>
 * 
 * <p>A key difference between Flash [Event]s and PureMVC 
 * [Notification]s is that [Event]s follow the 
 * 'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
 * until some parent component handles the [Event], while
 * PureMVC [Notification]s follow a 'Publish/Subscribe'
 * pattern. PureMVC classes need not be related to each other in a 
 * parent/child relationship in order to communicate with one another
 * using [Notification]s.
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.observer.Notification" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/patterns/observer/Notification.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.INotification"/>
		<getName public="1" line="50">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Get the name of the [Notification] instance.
	 </haxe_doc>
		</getName>
		<setBody public="1" line="58">
			<f a="body">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the body of the [Notification] instance.
	 </haxe_doc>
		</setBody>
		<getBody public="1" line="66">
			<f a=""><d/></f>
			<haxe_doc>
	 * Get the body of the [Notification] instance.
	 </haxe_doc>
		</getBody>
		<setType public="1" line="74">
			<f a="type">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the type of the [Notification] instance.
	 </haxe_doc>
		</setType>
		<getType public="1" line="82">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Get the type of the [Notification] instance.
	 </haxe_doc>
		</getType>
		<toString public="1" line="90">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * Get the string representation of the [Notification] instance.
	 </haxe_doc>
		</toString>
		<name><c path="String"/></name>
		<type><c path="String"/></type>
		<body><d/></body>
		<new public="1" line="40">
			<f a="name:?body:?type">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor. 
	 </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * A base [INotification] implementation.
 * 
 * <p>PureMVC does not rely upon underlying event models such 
 * as the one provided with Flash.</p>
 * 
 * <p>The Observer Pattern as implemented within PureMVC exists 
 * to support event-driven communication between the 
 * application and the actors of the MVC triad.</p>
 * 
 * <p>Notifications are not meant to be a replacement for Events.
 * Generally, [IMediator] implementors place event listeners on their view components, which they
 * then handle in the usual way. This may lead to the broadcast of [Notification]s to 
 * trigger [ICommand]s or to communicate with other [IMediators]. [IProxy] and [ICommand]
 * instances communicate with each other and [IMediator]s  by broadcasting [INotification]s.</p>
 * 
 * <p>A key difference between Flash [Event]s and PureMVC 
 * [Notification]s is that [Event]s follow the 
 * 'Chain of Responsibility' pattern, 'bubbling' up the display hierarchy 
 * until some parent component handles the [Event], while
 * PureMVC [Notification]s follow a 'Publish/Subscribe'
 * pattern. PureMVC classes need not be related to each other in a 
 * parent/child relationship in order to communicate with one another
 * using [Notification]s.
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.view.ApplicationMediator" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/view/ApplicationMediator.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.mediator.Mediator"/>
		<NAME public="1" line="17" static="1"><c path="String"/></NAME>
		<handleEvent line="66">
			<f a="event">
				<c path="StopWatchEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Handle events from the app.
	 *
	 * <p>For the StopWatch.ACTION_* events, we want to
	 * send a [StateMachine.ACTION] notification 
	 * with the event type being the action name.</p>
	 ]]></haxe_doc>
		</handleEvent>
		<app public="1" get="getApp" set="null"><c path="StopWatch"/></app>
		<getApp public="1" line="81"><f a=""><c path="StopWatch"/></f></getApp>
		<new public="1" line="19"><f a="viewComponent">
	<c path="StopWatch"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.traits.TraitTypeException" params="" file="../../../xinf/src/xinf/traits/TraitTypeException.hx">
		<message public="1"><c path="String"/></message>
		<toString public="1" line="14"><f a=""><c path="String"/></f></toString>
		<new public="1" line="9"><f a="name:obj:value:expected">
	<c path="String"/>
	<c path="xinf.traits.TraitAccess"/>
	<d/>
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.event.SimpleEventDispatcher" params="" file="../../../xinf/src/xinf/event/SimpleEventDispatcher.hx">
		<implements path="xinf.event.EventDispatcher"/>
		<listeners><c path="Hash"><c path="List"><f a="">
	<d/>
	<e path="Void"/>
</f></c></c></listeners>
		<filters><c path="List"><f a="">
	<d/>
	<e path="Bool"/>
</f></c></filters>
		<addEventListener public="1" params="T" line="15"><f a="type:h">
	<c path="xinf.event.EventKind"><c path="addEventListener.T"/></c>
	<f a="">
		<c path="addEventListener.T"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="addEventListener.T"/>
		<e path="Void"/>
	</f>
</f></addEventListener>
		<removeEventListener public="1" params="T" line="26"><f a="type:h">
	<c path="xinf.event.EventKind"><c path="removeEventListener.T"/></c>
	<f a="">
		<c path="removeEventListener.T"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
</f></removeEventListener>
		<removeAllListeners public="1" params="T" line="34"><f a="type">
	<c path="xinf.event.EventKind"><c path="removeAllListeners.T"/></c>
	<e path="Bool"/>
</f></removeAllListeners>
		<addEventFilter public="1" line="38"><f a="f">
	<f a="">
		<d/>
		<e path="Bool"/>
	</f>
	<e path="Void"/>
</f></addEventFilter>
		<dispatchEvent public="1" params="T" line="43"><f a="e">
	<c path="xinf.event.Event"><c path="dispatchEvent.T"/></c>
	<e path="Void"/>
</f></dispatchEvent>
		<copyProperties line="61"><f a="to">
	<d/>
	<e path="Void"/>
</f></copyProperties>
		<postEvent public="1" params="T" line="73"><f a="e:?pos">
	<c path="xinf.event.Event"><c path="postEvent.T"/></c>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></postEvent>
		<new public="1" line="11"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.Int32" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/Int32.hx">
		<make public="1" line="29" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" line="37" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<toInt public="1" line="45" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<add public="1" line="58" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" line="66" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" line="74" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" line="82" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" line="90" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" line="98" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" line="106" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" line="114" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" line="122" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" line="130" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" line="138" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" line="146" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<complement public="1" line="154" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" line="162" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
	</class>
	<class path="xinf.erno.Constants" params="" file="../../../xinf/src/xinf/erno/Constants.hx">
		<CAPS_BUTT public="1" line="7" static="1"><c path="Int"/></CAPS_BUTT>
		<CAPS_ROUND public="1" line="8" static="1"><c path="Int"/></CAPS_ROUND>
		<CAPS_SQUARE public="1" line="9" static="1"><c path="Int"/></CAPS_SQUARE>
		<JOIN_MITER public="1" line="11" static="1"><c path="Int"/></JOIN_MITER>
		<JOIN_ROUND public="1" line="12" static="1"><c path="Int"/></JOIN_ROUND>
		<JOIN_BEVEL public="1" line="13" static="1"><c path="Int"/></JOIN_BEVEL>
		<SPREAD_PAD public="1" line="15" static="1"><c path="Int"/></SPREAD_PAD>
		<SPREAD_REFLECT public="1" line="16" static="1"><c path="Int"/></SPREAD_REFLECT>
		<SPREAD_REPEAT public="1" line="17" static="1"><c path="Int"/></SPREAD_REPEAT>
	</class>
	<class path="openvg.Paint" params="" file="../../../xinf/src/libs/openvg/api/openvg/Paint.hx" extern="1">
		<create public="1" static="1">
			<f a=""><c path="openvg.Paint"/></f>
			<haxe_doc><![CDATA[ <nekobind ctor="true" suffix="Paint"/> ]]></haxe_doc>
		</create>
		<set public="1">
			<f a="paintModes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="Paint"/> ]]></haxe_doc>
		</set>
		<setParameterf public="1"><f a="type:value">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setParameterf>
		<setParameteri public="1"><f a="type:value">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setParameteri>
		<setParameterfv public="1">
			<f a="type:count:value">
				<c path="Float"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="value" type="float" min-size="count"/></nekobind> ]]></haxe_doc>
		</setParameterfv>
		<setParameteriv public="1">
			<f a="type:count:value">
				<c path="Float"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="value" type="int" min-size="count"/></nekobind> ]]></haxe_doc>
		</setParameteriv>
		<getParameterf public="1"><f a="type">
	<c path="Int"/>
	<c path="Float"/>
</f></getParameterf>
		<getParameteri public="1"><f a="type">
	<c path="Int"/>
	<c path="Int"/>
</f></getParameteri>
		<getParameterVectorSize public="1"><f a="type">
	<c path="Int"/>
	<c path="Int"/>
</f></getParameterVectorSize>
		<getParameterfv public="1">
			<f a="type:count:values">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="values" type="float" min-size="count"/></nekobind> ]]></haxe_doc>
		</getParameterfv>
		<getParameteriv public="1">
			<f a="type:count:values">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="values" type="int" min-size="count"/></nekobind> ]]></haxe_doc>
		</getParameteriv>
		<new><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
	<nekobind 
		translator="Capitalize"
		prefix="vg"
		nekoAbstract="__h"
		cStruct="VGPaint"
		dtor="destroyPaint"
		dtorLock="true"
		module="openvg"
		friends="openvg.Handle:VGHandle>__h"
		/>
	<nekobind:cHeader>
		#include &lt;vg/openvg.h&gt;
		#include "helper.h"
	</nekobind:cHeader>
]]></haxe_doc>
	</class>
	<class path="xinf.ony.erno.Embed" params="" file="../../../xinf/src/xinf/ony/erno/Embed.hx">
		<extends path="xinf.ony.erno.Group"/>
		<root><t path="xinf.erno.NativeContainer"/></root>
		<new public="1" line="21">
			<f a="o">
				<t path="xinf.erno.NativeContainer"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Constructor. Pass in a NativeContainer (a DisplayObjectContainer
		for Flash, a HtmlDom for JS, or a GLObject for Xinfinity); this Object
		will aquire it and use it as the root for this display hierarchy.
	</haxe_doc>
		</new>
		<haxe_doc>
	A Root-like Object, embeds a Xinfony display hierarchy
	into a Runtime-native Object.
</haxe_doc>
	</class>
	<enum path="haxe.StackItem" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/Stack.hx" module="haxe.Stack">
		<Module a="m"><c path="String"/></Module>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<Lambda a="v"><c path="Int"/></Lambda>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<c path="Int"/>
		</FilePos>
		<CFunction/>
		<haxe_doc>
	Elements return by [Stack] methods.
</haxe_doc>
	</enum>
	<class path="haxe.Stack" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/Stack.hx">
		<callStack public="1" line="46" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the call stack elements.
	</haxe_doc>
		</callStack>
		<exceptionStack public="1" line="67" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		catched.
	</haxe_doc>
		</exceptionStack>
		<toString public="1" line="96" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of the stack as a printable string.
	</haxe_doc>
		</toString>
		<itemToString line="105" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<e path="Void"/>
</f></itemToString>
		<makeStack line="131" static="1"><f a="s">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></makeStack>
		<haxe_doc>
	Get informations about the call stack.
</haxe_doc>
	</class>
	<class path="xinf.geom.Translate" params="" file="../../../xinf/src/xinf/geom/Translate.hx">
		<implements path="xinf.geom.Transform"/>
		<x><c path="Float"/></x>
		<y><c path="Float"/></y>
		<getTranslation public="1" line="17"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getTranslation>
		<getScale public="1" line="20"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getScale>
		<getMatrix public="1" line="23"><f a=""><a>
	<ty><c path="Float"/></ty>
	<tx><c path="Float"/></tx>
	<d><c path="Float"/></d>
	<c><c path="Float"/></c>
	<b><c path="Float"/></b>
	<a><c path="Float"/></a>
</a></f></getMatrix>
		<apply public="1" line="27"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1" line="30"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<interpolateWith public="1" line="34"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1" line="42"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1" line="49"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1" line="53"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
		<toString public="1" line="61"><f a=""><c path="String"/></f></toString>
		<new public="1" line="12"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="xinf.ony._Gradient.TGradientStop" params="" file="../../../xinf/src/xinf/ony/Gradient.hx" private="1" module="xinf.ony.Gradient"><a>
	<r><c path="Float"/></r>
	<offset><c path="Float"/></offset>
	<g><c path="Float"/></g>
	<b><c path="Float"/></b>
	<a><c path="Float"/></a>
</a></typedef>
	<enum path="ValueType" params="" file="C:\Program Files\Motion-Twin\haxe/std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"/></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
		<haxe_doc>
	The diffent possible runtime types of a value.
	See [Type] for the haXe Reflection API.
</haxe_doc>
	</enum>
	<class path="Type" params="" file="C:\Program Files\Motion-Twin\haxe/std/Type.hx">
		<getClass public="1" params="T" line="26" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" line="77" static="1">
			<f a="o">
				<d/>
				<c path="Enum"/>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" line="113" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" line="134" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" line="157" static="1">
			<f a="e">
				<c path="Enum"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" line="172" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" line="225" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"/>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" line="273" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" line="315" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" line="369" static="1">
			<f a="e:constr:?params">
				<c path="Enum"/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<getInstanceFields public="1" line="400" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" line="447" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" line="487" static="1">
			<f a="e">
				<c path="Enum"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" line="506" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" line="615" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" line="669" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" line="682" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" line="700" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.command.MacroCommand" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/patterns/command/MacroCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.observer.Notifier"/>
		<implements path="org.puremvc.haxe.multicore.interfaces.ICommand"/>
		<subCommands><c path="List"><c path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></c></c></subCommands>
		<initializeMacroCommand line="64">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Initialize the [MacroCommand].
	 * 
	 * <p>In your subclass, override this method to 
	 * initialize the [MacroCommand]'s <em>SubCommand</em>  
	 * list with [ICommand] class references.
	 *
	 * <p>Note that <i>SubCommand</i>s may be any [ICommand] implementor,
	 * [MacroCommand]s or [SimpleCommands] are both acceptable.</p>
	 ]]></haxe_doc>
		</initializeMacroCommand>
		<addSubCommand line="74">
			<f a="commandClassRef">
				<c path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Add a <em>SubCommand</em>.
	 * 
	 * <p>The <i>SubCommands</i> will be called in First In/First Out (FIFO)
	 * order.</p>
	 ]]></haxe_doc>
		</addSubCommand>
		<execute public="1" line="85">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ 
	 * Execute this [MacroCommand]'s <em>SubCommands</em>.
	 * 
	 * <p>The <i>SubCommands</i> will be called in First In/First Out (FIFO)
	 * order.</p>
	 ]]></haxe_doc>
		</execute>
		<new public="1" line="47">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Constructor. 
	 * 
	 * <p>You should not need to define a constructor, 
	 * instead, override the [initializeMacroCommand]
	 * method.</p>
	 * 
	 * <p>
	 * If your subclass does define a constructor, be 
	 * sure to call [super()].</p>
	 ]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * A base [ICommand] implementation that executes other [ICommand]s.
 *  
 * <p>A [MacroCommand] maintains an list of
 * [ICommand] Class references called <em>SubCommands</em>.</p>
 * 
 * <p>When [execute] is called, the [MacroCommand] 
 * instantiates and calls [execute] on each of its <em>SubCommands</em> turn.
 * Each <em>SubCommand</em> will be passed a reference to the original
 * [INotification] that was passed to the [MacroCommand]'s 
 * [execute] method.</p>
 * 
 * <p>Unlike [SimpleCommand], your subclass
 * should not override [execute], but instead, should 
 * override the [initializeMacroCommand] method, 
 * calling [addSubCommand] once for each <em>SubCommand</em>
 * to be executed.</p>
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.controller.StartupCommand" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/controller/StartupCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.command.MacroCommand"/>
		<new public="1" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.event.FrameEvent" params="" file="../../../xinf/src/xinf/event/FrameEvent.hx">
		<extends path="xinf.event.Event"><c path="xinf.event.FrameEvent"/></extends>
		<ENTER_FRAME public="1" line="12" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.FrameEvent"/></c></ENTER_FRAME>
		<frame public="1"><c path="Int"/></frame>
		<time public="1"><c path="Float"/></time>
		<new public="1" line="17"><f a="_type:frame:time">
	<c path="xinf.event.EventKind"><c path="xinf.event.FrameEvent"/></c>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="xinf.ony._PathParser.SimpleSegment" params="" file="../../../xinf/src/xinf/ony/PathParser.hx" private="1" module="xinf.ony.PathParser"><e path="xinf.ony.type.PathSegment"/></typedef>
	<enum path="xinf.ony._PathParser.PathParserState" params="" file="../../../xinf/src/xinf/ony/PathParser.hx" private="1" module="xinf.ony.PathParser">
		<ParseFloat a="s:old">
			<c path="String"/>
			<e path="xinf.ony._PathParser.PathParserState"/>
		</ParseFloat>
		<ParseCommand a="cmd:nargs">
			<c path="String"/>
			<c path="Int"/>
		</ParseCommand>
		<Empty/>
	</enum>
	<class path="xinf.ony.PathParser" params="" file="../../../xinf/src/xinf/ony/PathParser.hx">
		<commandReg line="17" static="1"><c path="EReg"/></commandReg>
		<simplify public="1" line="177" static="1"><f a="segments">
	<t path="Iterable"><e path="xinf.ony.type.SVGPathSegment"/></t>
	<c path="List"><t path="xinf.ony._PathParser.SimpleSegment"/></c>
</f></simplify>
		<g><c path="Array"><e path="xinf.ony.type.SVGPathSegment"/></c></g>
		<input><c path="String"/></input>
		<pin><c path="Int"/></pin>
		<state><e path="xinf.ony._PathParser.PathParserState"/></state>
		<args><c path="Array"><c path="Float"/></c></args>
		<parse public="1" line="31"><f a="pathToParse">
	<c path="String"/>
	<t path="Iterable"><e path="xinf.ony.type.SVGPathSegment"/></t>
</f></parse>
		<parseCommand line="76"><f a="cmd">
	<c path="String"/>
	<e path="Void"/>
</f></parseCommand>
		<fail line="94"><f a=""><e path="Void"/></f></fail>
		<endState line="98"><f a=""><e path="Void"/></f></endState>
		<command line="127"><f a="cmd:a">
	<c path="String"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Void"/>
</f></command>
		<new public="1" line="27"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="xinf.ony.ElementImpl" params="" file="../../../xinf/src/xinf/ony/Implementation.hx" module="xinf.ony.Implementation"><c path="xinf.ony.erno.Element"/></typedef>
	<typedef path="xinf.ony.GroupImpl" params="" file="../../../xinf/src/xinf/ony/Implementation.hx" module="xinf.ony.Implementation"><c path="xinf.ony.erno.Group"/></typedef>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.controller.EnsureTimerCommand" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/controller/EnsureTimerCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.command.SimpleCommand"/>
		<new public="1" line="12"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.support.Font" params="" file="../../../xinf/src/libs/xinfinity-support/api/xinf/support/Font.hx">
		<listFonts public="1" line="66" static="1"><f a="callbackFunction">
	<f a=":::">
		<c path="String"/>
		<c path="String"/>
		<c path="Int"/>
		<c path="Int"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></listFonts>
		<findFont public="1" line="70" static="1"><f a="family:weight:slant:size">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="String"/>
</f></findFont>
		<_load static="1"><f a="::">
	<unknown/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></_load>
		<_iterateGlyphs static="1"><f a=":">
	<e path="Void"/>
	<t path="xinf.support.FTIterateCallbacks"/>
	<unknown/>
</f></_iterateGlyphs>
		<_renderGlyph static="1"><f a=":::">
	<e path="Void"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<a>
		<y><c path="Int"/></y>
		<x><c path="Int"/></x>
		<width><c path="Int"/></width>
		<height><c path="Int"/></height>
		<bitmap><d/></bitmap>
		<advance><c path="Float"/></advance>
	</a>
</f></_renderGlyph>
		<_listFonts static="1"><f a="">
	<f a=":::">
		<c path="String"/>
		<c path="String"/>
		<c path="Int"/>
		<c path="Int"/>
		<e path="Void"/>
	</f>
	<unknown/>
</f></_listFonts>
		<_findFont static="1"><f a=":::">
	<unknown/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="String"/>
</f></_findFont>
		<__f><e path="Void"/></__f>
		<family_name public="1" set="null"><c path="String"/></family_name>
		<style_name public="1" set="null"><c path="String"/></style_name>
		<ascender public="1" set="null"><c path="Float"/></ascender>
		<descender public="1" set="null"><c path="Float"/></descender>
		<height public="1" set="null"><c path="Float"/></height>
		<underline_thickness public="1" set="null"><c path="Float"/></underline_thickness>
		<underline_position public="1" set="null"><c path="Float"/></underline_position>
		<units_per_EM public="1" set="null"><c path="Float"/></units_per_EM>
		<iterateAllGlyphs public="1" line="58"><f a="callbackObject">
	<t path="xinf.support.FTIterateCallbacks"/>
	<e path="Void"/>
</f></iterateAllGlyphs>
		<renderGlyph public="1" line="62"><f a="index:size:hint">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<a>
		<y><c path="Int"/></y>
		<x><c path="Int"/></x>
		<width><c path="Int"/></width>
		<height><c path="Int"/></height>
		<bitmap><d/></bitmap>
		<advance><c path="Float"/></advance>
	</a>
</f></renderGlyph>
		<new public="1" line="35"><f a="data:?width:?height">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.inity.font.Font" params="" file="../../../xinf/src/xinf/inity/font/Font.hx">
		<extends path="xinf.support.Font"/>
		<fonts line="11" static="1"><c path="Hash"><c path="xinf.inity.font.Font"/></c></fonts>
		<getFont public="1" line="13" static="1"><f a="?name:?weight:?slant">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="xinf.inity.font.Font"/>
</f></getFont>
		<font public="1"><c path="xinf.support.Font"/></font>
		<cache><c path="Hash"><c path="xinf.inity.font.GlyphCache"/></c></cache>
		<data><c path="String"/></data>
		<getGlyph public="1" line="55"><f a="character:fontSize">
	<c path="Int"/>
	<c path="Float"/>
	<c path="xinf.inity.font.Glyph"/>
</f></getGlyph>
		<textSize public="1" line="68"><f a="text:fontSize:?lineHeight">
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<a>
		<y><c path="Float"/></y>
		<x><c path="Float"/></x>
	</a>
</f></textSize>
		<renderText public="1" line="91"><f a="text:fontSize">
	<c path="String"/>
	<c path="Float"/>
	<e path="Void"/>
</f></renderText>
		<toString public="1" line="150"><f a=""><c path="String"/></f></toString>
		<new public="1" line="48"><f a="data:size">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<getBytes public="1" line="122"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<new public="1" line="35"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.event.GeometryEvent" params="" file="../../../xinf/src/xinf/event/GeometryEvent.hx">
		<extends path="xinf.event.Event"><c path="xinf.event.GeometryEvent"/></extends>
		<STAGE_SCALED public="1" line="12" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.GeometryEvent"/></c></STAGE_SCALED>
		<SIZE_CHANGED public="1" line="13" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.GeometryEvent"/></c></SIZE_CHANGED>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<new public="1" line="18"><f a="_type:_x:_y">
	<c path="xinf.event.EventKind"><c path="xinf.event.GeometryEvent"/></c>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	GeometryEvent is used to propagate information about changes
	in position or size of some Element.
</haxe_doc>
	</class>
	<class path="Reflect" params="" file="C:\Program Files\Motion-Twin\haxe/std/Reflect.hx">
		<hasField public="1" line="35" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" line="59" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" line="83" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" line="99" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" line="123" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" line="194" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" line="213" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" line="225" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
		Does not work on Neko platform.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" line="255" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" line="294" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" line="321" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" line="339" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<same_closure line="361" static="1"><f a=":">
	<d/>
	<d/>
	<e path="Bool"/>
</f></same_closure>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="xinf.ony.erno.Path" params="" file="../../../xinf/src/xinf/ony/erno/Path.hx">
		<extends path="xinf.ony.Path"/>
		<new public="1" line="11"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Manager" params="" file="../../../xinf/src/xinf/ony/erno/Manager.hx">
		<objects><c path="IntHash"><c path="xinf.ony.erno.Element"/></c></objects>
		<changed><c path="IntHash"><c path="xinf.ony.erno.Element"/></c></changed>
		<moved><c path="IntHash"><c path="xinf.ony.erno.Element"/></c></moved>
		<dispatchToTarget line="54"><f a="e">
	<d/>
	<e path="Void"/>
</f></dispatchToTarget>
		<register public="1" line="65"><f a="id:o">
	<c path="Int"/>
	<c path="xinf.ony.erno.Element"/>
	<e path="Void"/>
</f></register>
		<unregister public="1" line="70"><f a="id">
	<c path="Int"/>
	<e path="Void"/>
</f></unregister>
		<objectChanged public="1" line="78"><f a="id:o">
	<c path="Int"/>
	<c path="xinf.ony.erno.Element"/>
	<e path="Void"/>
</f></objectChanged>
		<objectMoved public="1" line="82"><f a="id:o">
	<c path="Int"/>
	<c path="xinf.ony.erno.Element"/>
	<e path="Void"/>
</f></objectMoved>
		<redrawChanged line="86"><f a="e">
	<c path="xinf.event.FrameEvent"/>
	<e path="Void"/>
</f></redrawChanged>
		<find public="1" line="120"><f a="id">
	<c path="Int"/>
	<c path="xinf.ony.erno.Element"/>
</f></find>
		<new public="1" line="37"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
	Xinfony creates one singleton Manager object as a static private member of Element.
	<p>
	It keeps a list (actually an IntHash) of all Elements,
	keeps track of changes to their contents or transformation
	and re-draws and re-transforms those that changed, once for each frame
	and using <a href="../erno/Runtime.html">Runtime</a>'s global renderer.
	<p></p>
	It also dispatches MouseEvent.MOUSE_DOWN and ScrollEvent.SCROLL_STEP to the
	Element whose ID is given in the Event (xinf.erno only knows about IDs, and
	has no reference to the actual object).
	</p>
	<p>
	All public functions on Manager are for use from <a href="Element.html">Element</a>,
	there should be no need to "manually" register any object.
	Use Element.redraw() to mark an object as changed.
	</p>
]]></haxe_doc>
	</class>
	<class path="xinf.erno.Runtime" params="" file="../../../xinf/src/xinf/erno/Runtime.hx">
		<extends path="xinf.event.SimpleEventDispatcher"/>
		<runtime public="1" get="getRuntime" set="null" static="1">
			<c path="xinf.erno.Runtime"/>
			<haxe_doc>
		A reference to the global Runtime singleton.
		If it is not initialized yet, requesting this will intialize
		the runtime.
	</haxe_doc>
		</runtime>
		<_runtime static="1"><c path="xinf.erno.Runtime"/></_runtime>
		<renderer public="1" get="getRenderer" set="null" static="1">
			<c path="xinf.erno.Renderer"/>
			<haxe_doc>
		A reference to the Renderer associated to the global Runtime singleton.
		If it is not initialized yet, requesting this will intialize
		the runtime.
	</haxe_doc>
		</renderer>
		<_renderer static="1"><c path="xinf.erno.Renderer"/></_renderer>
		<getRuntime line="59" static="1"><f a=""><c path="xinf.erno.Runtime"/></f></getRuntime>
		<getRenderer line="64" static="1"><f a=""><c path="xinf.erno.Renderer"/></f></getRenderer>
		<initRuntime line="69" static="1"><f a=""><c path="xinf.erno.Runtime"/></f></initRuntime>
		<addEventListener public="1" params="T" line="125" static="1">
			<f a="type:h">
				<c path="xinf.event.EventKind"><c path="addEventListener.T"/></c>
				<f a="">
					<c path="addEventListener.T"/>
					<e path="Void"/>
				</f>
				<f a="">
					<c path="addEventListener.T"/>
					<e path="Void"/>
				</f>
			</f>
			<haxe_doc>
		add an event listener to the Runtime singleton. This is a convenience
		function that has the same effect as Runtime.runtime.addEventListener.
	</haxe_doc>
		</addEventListener>
		<removeEventListener public="1" params="T" line="133" static="1">
			<f a="type:h">
				<c path="xinf.event.EventKind"><c path="removeEventListener.T"/></c>
				<f a="">
					<c path="removeEventListener.T"/>
					<e path="Void"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		remove an event listener from the Runtime singleton. This is a convenience
		function that has the same effect as Runtime.runtime.removeEventListener.
	</haxe_doc>
		</removeEventListener>
		<getNextId public="1" line="142">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[
		return a newly allocated numeric ID
		for use with <a href="Renderer.html">xinf.erno.Renderer</a>. 
		The default implementation will throw an exception.
	]]></haxe_doc>
		</getNextId>
		<getDefaultRoot public="1" line="151">
			<f a=""><t path="xinf.erno.NativeContainer"/></f>
			<haxe_doc><![CDATA[
		return the runtime's default Root <a href="NativeContainer.html">NativeContainer</a>.
		The default implementation will throw an exception.
	]]></haxe_doc>
		</getDefaultRoot>
		<run public="1" line="164">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
		start the runtime main loop if such exists. 
		From your application, you should call Runtime.runtime.run() once, at the end of your main() 
		(<a href="../ony/Application.html">xinf.ony.Application</a>.run() does this for you). 
		The function might return instantly, when the application quits,
		or never, depending on the runtime environment.
		The default implementation will throw an exception.
	]]></haxe_doc>
		</run>
		<changed public="1" line="174">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		signal to the Runtime that some content in the display hierarchy has changed.
		This will trigger re-rendering of the default Root object. There is no need
		to ever call this if you use Xinfony (the Manager will take care of this).
		The default implementation does nothing.
	</haxe_doc>
		</changed>
		<setBackgroundColor public="1" line="177"><f a="r:g:b:?a">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setBackgroundColor>
		<setFramerate public="1" line="180"><f a="rate">
	<c path="Float"/>
	<e path="Void"/>
</f></setFramerate>
		<getFramerate public="1" line="183"><f a=""><c path="Float"/></f></getFramerate>
		<getMeasuredFramerate public="1" line="187"><f a=""><c path="Float"/></f></getMeasuredFramerate>
		<new public="1" line="40"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
	DOCME: out of date!
	
	The Runtime class has static functions to request the global
	Runtime instance (a singleton) and it's associated <a href="Renderer.html">Renderer</a>.
	<p>
		The Runtime represents the runtime environment (Flash, JavaScript, Xinfinity), 
		there is only one global runtime object for a running Xinf application, 
		an instance of a class deriving from xinf.erno.Runtime. The specific runtimes
		implement some 'abstract' functions defined here in their individual ways.
	</p>
	<p>
		The Runtime singleton (Runtime.runtime) is an EventDispatcher that dispatches
		all global low-level user-interface events. In Xinfony, some of these are
		listened for and dispatched to the corresponding target object (see
		<a href="../ony/Manager.html">xinf.ony.Manager</a>). 
		For other events, you will have to register at the runtime (in particular, 
		this regards MOUSE_UP, MOUSE_MOVED, KEY_UP, KEY_DOWN and STAGE_SCALED). 
		You can register listeners either at the [Runtime.runtime] member or 
		using the static [addEventListener] function.
	</p>
	<p>
		The Runtime is initialized automatically when you instantate an
		<a href="../ony/Application.html">xinf.ony.Application</a> object, or do anything
		with Runtime.runtime. Only if you want to use Xinferno directly you
		should probably care about initialization once at the beginning of your
		application.
	</p>
]]></haxe_doc>
	</class>
	<class path="xinf.inity.XinfinityRuntime" params="" file="../../../xinf/src/xinf/inity/XinfinityRuntime.hx">
		<extends path="xinf.erno.Runtime"/>
		<frame><c path="Int"/></frame>
		<width><c path="Int"/></width>
		<height><c path="Int"/></height>
		<somethingChanged><e path="Bool"/></somethingChanged>
		<root><c path="xinf.inity.GLObject"/></root>
		<time><c path="Float"/></time>
		<interval><c path="Float"/></interval>
		<bgColor><a>
	<r><c path="Float"/></r>
	<g><c path="Float"/></g>
	<b><c path="Float"/></b>
	<a><c path="Float"/></a>
</a></bgColor>
		<lastMeasure><c path="Float"/></lastMeasure>
		<rateAcc><c path="Float"/></rateAcc>
		<rates><c path="Int"/></rates>
		<measuredFps><c path="Float"/></measuredFps>
		<preDisplayCallbacks public="1"><c path="List"><f a=""><e path="Void"/></f></c></preDisplayCallbacks>
		<postDisplayCallbacks public="1"><c path="List"><f a=""><e path="Void"/></f></c></postDisplayCallbacks>
		<_eventSource><c path="xinf.inity.GLEventSource"/></_eventSource>
		<renderRoot line="69"><f a=""><e path="Void"/></f></renderRoot>
		<resized line="75"><f a="e">
	<c path="xinf.event.GeometryEvent"/>
	<e path="Void"/>
</f></resized>
		<display public="1" line="122"><f a=""><e path="Void"/></f></display>
		<timing line="147"><f a=""><e path="Void"/></f></timing>
		<step public="1" line="168"><f a=""><e path="Void"/></f></step>
		<initGL line="214"><f a=""><e path="Void"/></f></initGL>
		<startFrame line="241"><f a=""><e path="Void"/></f></startFrame>
		<endFrame line="274"><f a=""><e path="Void"/></f></endFrame>
		<findIdAt public="1" line="290"><f a="x:y:?precise">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findIdAt>
		<new public="1" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.event.ImageLoadEvent" params="" file="../../../xinf/src/xinf/event/ImageLoadEvent.hx">
		<extends path="xinf.event.Event"><c path="xinf.event.ImageLoadEvent"/></extends>
		<PART_LOADED public="1" line="15" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.ImageLoadEvent"/></c></PART_LOADED>
		<LOADED public="1" line="16" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.ImageLoadEvent"/></c></LOADED>
		<FRAME_AVAILABLE public="1" line="17" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.ImageLoadEvent"/></c></FRAME_AVAILABLE>
		<image public="1"><c path="xinf.erno.ImageData"/></image>
		<data public="1"><d/></data>
		<new public="1" line="22"><f a="_type:image:?data">
	<c path="xinf.event.EventKind"><c path="xinf.event.ImageLoadEvent"/></c>
	<c path="xinf.erno.ImageData"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	
</haxe_doc>
	</class>
	<class path="xinf.ony.Rectangle" params="" file="../../../xinf/src/xinf/ony/Rectangle.hx">
		<extends path="xinf.ony.erno.Element"/>
		<tagName line="14" static="1"><c path="String"/></tagName>
		<TRAITS line="16" static="1"><a>
	<y><c path="xinf.ony.traits.LengthTrait"/></y>
	<x><c path="xinf.ony.traits.LengthTrait"/></x>
	<width><c path="xinf.ony.traits.LengthTrait"/></width>
	<ry><c path="xinf.ony.traits.LengthTrait"/></ry>
	<rx><c path="xinf.ony.traits.LengthTrait"/></rx>
	<height><c path="xinf.ony.traits.LengthTrait"/></height>
</a></TRAITS>
		<x public="1" get="dynamic" set="dynamic"><c path="Float"/></x>
		<get_x line="26"><f a=""><c path="Float"/></f></get_x>
		<set_x line="27"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x>
		<y public="1" get="dynamic" set="dynamic"><c path="Float"/></y>
		<get_y line="30"><f a=""><c path="Float"/></f></get_y>
		<set_y line="31"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y>
		<width public="1" get="dynamic" set="dynamic"><c path="Float"/></width>
		<get_width line="34"><f a=""><c path="Float"/></f></get_width>
		<set_width line="35"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_width>
		<height public="1" get="dynamic" set="dynamic"><c path="Float"/></height>
		<get_height line="38"><f a=""><c path="Float"/></f></get_height>
		<set_height line="39"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_height>
		<rx public="1" get="dynamic" set="dynamic"><c path="Float"/></rx>
		<get_rx line="42"><f a=""><c path="Float"/></f></get_rx>
		<set_rx line="43"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_rx>
		<ry public="1" get="dynamic" set="dynamic"><c path="Float"/></ry>
		<get_ry line="46"><f a=""><c path="Float"/></f></get_ry>
		<set_ry line="47"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_ry>
		<new line="12"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="xinf.erno.Primitive" params="" file="../../../xinf/src/xinf/erno/ObjectModelRenderer.hx" module="xinf.erno.ObjectModelRenderer">
		<c path="xinf.inity.GLObject"/>
		<haxe_doc><![CDATA[
	DOCME: out of date!
	
	The ObjectModelRenderer class implements some functionality for
	Renderers that use an object-model based engine (which is currently
	true for all available renderers).
	<p>
		It implements the <i>object parts</i> of the <a href="Renderer.html">Renderer</a>
		interface, keeps a global IntHash mapping Xinferno IDs to NativeObjects (here,
		these are called '[Primitive]'s. The type parameter is in fact required to be
		the same as [NativeObject]. FIXME: clean this up a little!
	</p>
	<p>
		Deriving classes should ignore the [startObject], [endObject], [startNative],
		[endNative], [showObject] and [setTransform] functions of the Renderer interface
		(i.e., not implement them), and instead implement the [createPrimitive],
		[attachPrimitive], [clearPrimitive] and [setPrimitiveTransform] functions
		declared here. The default implementations of those do nothing. Deriving classes
		can access the private member [current] to get access to the NativeObject currently
		being (re-)defined.
	</p>
]]></haxe_doc>
	</typedef>
	<class path="xinf.erno.PenRenderer" params="" file="../../../xinf/src/xinf/erno/PenRenderer.hx">
		<extends path="xinf.erno.BasicRenderer"/>
		<pen><c path="xinf.erno.Pen"/></pen>
		<new public="1" line="68"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
	A PenRenderer implements the <i>style part</i> of the 
	$xinf.erno.Renderer$ interface ([setFill] and [setStroke]),
	maintaining a <a href="Pen.html">Pen</a> structure.

	Renderers deriving from this can access the current Pen from the [pen] member variable.
	</p>
]]></haxe_doc>
	</class>
	<class path="xinf.erno.ObjectModelRenderer" params="" file="../../../xinf/src/xinf/erno/ObjectModelRenderer.hx">
		<extends path="xinf.erno.PenRenderer"/>
		<objects><c path="IntHash"><t path="xinf.erno.Primitive"/></c></objects>
		<lookup line="45"><f a="id">
	<c path="Int"/>
	<t path="xinf.erno.Primitive"/>
</f></lookup>
		<current><t path="xinf.erno.Primitive"/></current>
		<createPrimitive public="1" line="61">
			<f a="id">
				<c path="Int"/>
				<t path="xinf.erno.Primitive"/>
			</f>
			<haxe_doc>
		to be overridden by deriving classes, 
		this function returns a newly
		allocated native object associated to the given ID.
	</haxe_doc>
		</createPrimitive>
		<destroyPrimitive public="1" line="69">
			<f a="p">
				<t path="xinf.erno.Primitive"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		to be overridden by deriving classes, 
		free resources (notably memory) associated to the given Object.
	</haxe_doc>
		</destroyPrimitive>
		<attachPrimitive public="1" line="78">
			<f a="parent:child">
				<t path="xinf.erno.Primitive"/>
				<t path="xinf.erno.Primitive"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		to be overridden by deriving classes, 
		attach the [child] to the [parent] object,
		i.e., insert it, addChild, however you want to call it.
	</haxe_doc>
		</attachPrimitive>
		<clearPrimitive public="1" line="86">
			<f a="p">
				<t path="xinf.erno.Primitive"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		to be overridden by deriving classes, 
		clear the given object (remove all its children, clear an
		eventually existing graphics context).
	</haxe_doc>
		</clearPrimitive>
		<setPrimitiveTransform public="1" line="93">
			<f a="p:x:y:a:b:c:d">
				<t path="xinf.erno.Primitive"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		to be overridden by deriving classes, 
		set the transformation of the given object to the given Matrix.
	</haxe_doc>
		</setPrimitiveTransform>
		<setPrimitiveTranslation public="1" line="100">
			<f a="p:x:y">
				<t path="xinf.erno.Primitive"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		to be overridden by deriving classes, 
		set the translation of the given object to the given Position.
	</haxe_doc>
		</setPrimitiveTranslation>
		<new public="1" line="104"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="cptr.CPtr" params="" file="../../../xinf/src/libs/cptr/api/cptr/CPtr.hx">
		<float_alloc public="1" line="25" static="1"><f a="">
	<c path="Int"/>
	<c path="String"/>
</f></float_alloc>
		<float_set public="1" line="26" static="1"><f a="::">
	<c path="String"/>
	<c path="Int"/>
	<c path="Float"/>
	<unknown/>
</f></float_set>
		<float_get public="1" line="27" static="1"><unknown/></float_get>
		<float_to_array public="1" line="28" static="1"><unknown/></float_to_array>
		<float_from_array public="1" line="29" static="1"><f a=":">
	<c path="String"/>
	<unknown/>
	<unknown/>
</f></float_from_array>
		<double_alloc public="1" line="31" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></double_alloc>
		<double_set public="1" line="32" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Float"/>
	<unknown/>
</f></double_set>
		<double_get public="1" line="33" static="1"><unknown/></double_get>
		<double_to_array public="1" line="34" static="1"><unknown/></double_to_array>
		<double_from_array public="1" line="35" static="1"><unknown/></double_from_array>
		<int_alloc public="1" line="37" static="1"><unknown/></int_alloc>
		<int_set public="1" line="38" static="1"><unknown/></int_set>
		<int_get public="1" line="39" static="1"><unknown/></int_get>
		<int_to_array public="1" line="40" static="1"><unknown/></int_to_array>
		<int_from_array public="1" line="41" static="1"><unknown/></int_from_array>
		<uint_alloc public="1" line="43" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></uint_alloc>
		<uint_set public="1" line="44" static="1"><unknown/></uint_set>
		<uint_get public="1" line="45" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
</f></uint_get>
		<uint_to_array public="1" line="46" static="1"><unknown/></uint_to_array>
		<uint_from_array public="1" line="47" static="1"><unknown/></uint_from_array>
		<char_alloc public="1" line="49" static="1"><unknown/></char_alloc>
		<char_set public="1" line="50" static="1"><unknown/></char_set>
		<char_get public="1" line="51" static="1"><unknown/></char_get>
		<char_to_array public="1" line="52" static="1"><unknown/></char_to_array>
		<char_from_array public="1" line="53" static="1"><unknown/></char_from_array>
		<uchar_alloc public="1" line="55" static="1"><f a="">
	<c path="Int"/>
	<c path="String"/>
</f></uchar_alloc>
		<uchar_set public="1" line="56" static="1"><f a="::">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></uchar_set>
		<uchar_get public="1" line="57" static="1"><unknown/></uchar_get>
		<uchar_to_array public="1" line="58" static="1"><unknown/></uchar_to_array>
		<uchar_from_array public="1" line="59" static="1"><unknown/></uchar_from_array>
		<short_alloc public="1" line="61" static="1"><unknown/></short_alloc>
		<short_set public="1" line="62" static="1"><unknown/></short_set>
		<short_get public="1" line="63" static="1"><unknown/></short_get>
		<short_to_array public="1" line="64" static="1"><unknown/></short_to_array>
		<short_from_array public="1" line="65" static="1"><unknown/></short_from_array>
		<ushort_alloc public="1" line="67" static="1"><unknown/></ushort_alloc>
		<ushort_set public="1" line="68" static="1"><unknown/></ushort_set>
		<ushort_get public="1" line="69" static="1"><unknown/></ushort_get>
		<ushort_to_array public="1" line="70" static="1"><unknown/></ushort_to_array>
		<ushort_from_array public="1" line="71" static="1"><unknown/></ushort_from_array>
	</class>
	<class path="xinf.xml.Instantiator" params="T" file="../../../xinf/src/xinf/xml/Instantiator.hx">
		<myClass><c path="Class"><c path="xinf.xml.Instantiator.T"/></c></myClass>
		<fits public="1" line="30">
			<f a="xml">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc> Return [true] if the Instantiator fits the
		given [xml]. The default implementation always
		returns false.
	</haxe_doc>
		</fits>
		<instantiate public="1" line="36">
			<f a=""><d/></f>
			<haxe_doc> Instaniate an object of the Instantiator's type.
	</haxe_doc>
		</instantiate>
		<new public="1" line="22">
			<f a="cl">
				<c path="Class"><c path="xinf.xml.Instantiator.T"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc> Create a new Instantiator for class [cl].
	</haxe_doc>
		</new>
		<haxe_doc>
	Like the name suggests, an Instantiator is used
	to instantiate an object of a certain class.
	
	It is used by $xinf.xml.Binding$ to allow for 
	more complex binding of classes to XML content
	than simple nodeName to class relationships.
	
	For prominent example subclasses, see
	$xinf.xml.ByAttributeValue$ and $xinf.xml.HasAttribute$.
</haxe_doc>
	</class>
	<class path="xinf.xml.ByAttributeValue" params="T" file="../../../xinf/src/xinf/xml/Instantiator.hx" module="xinf.xml.Instantiator">
		<extends path="xinf.xml.Instantiator"><c path="xinf.xml.ByAttributeValue.T"/></extends>
		<attributeName><c path="String"/></attributeName>
		<attributeValue><c path="String"/></attributeValue>
		<new public="1" line="67">
			<f a="attributeName:attributeValue:cl">
				<c path="String"/>
				<c path="String"/>
				<c path="Class"><c path="xinf.xml.ByAttributeValue.T"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Create a new ByAttributeValue Instantiator
		that matches XML elements that have an
		attribute with name [attributeName] and value
		[attributeValue], bound to class [cl].
		
		For example,<br/>
			[   var i = new ByAttributeValue("name","foo");]<br/>
		matches <br/>
			[   <anyNode name="foo"/>]
	]]></haxe_doc>
		</new>
		<haxe_doc>
	ByAttributeValue is an Instantiator that matches
	XML Elements that have a certain attribute with
	a certain value.
</haxe_doc>
	</class>
	<class path="xinf.xml.HasAttribute" params="T" file="../../../xinf/src/xinf/xml/Instantiator.hx" module="xinf.xml.Instantiator">
		<extends path="xinf.xml.Instantiator"><c path="xinf.xml.HasAttribute.T"/></extends>
		<attributeName><c path="String"/></attributeName>
		<new public="1" line="99">
			<f a="attributeName:cl">
				<c path="String"/>
				<c path="Class"><c path="xinf.xml.HasAttribute.T"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Create a new HasAttribute Instantiator
		that matches xml elements that have an
		attribute with name [attributeName],
		bound to class [cl].
		
		For example, <br/>
			[  var i = new HasAttribute("name");] <br/>
		matches <br/>
			[  <anyNode name="anyValue"/>]
	]]></haxe_doc>
		</new>
		<haxe_doc>
	HasAttribute is an Instantiator that matches
	XML Elements that have a certain attribute.
	
	In contrast to $xinf.xml.ByAttributeValue$,
	the attribute's value is not regarded.
</haxe_doc>
	</class>
	<class path="Lambda" params="" file="C:\Program Files\Motion-Twin\haxe/std/Lambda.hx">
		<array public="1" params="A" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>
		Creates an [Array] from an [Iterable]
	</haxe_doc>
		</array>
		<list public="1" params="A" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>
		Creates a [List] from an [Iterable]
	</haxe_doc>
		</list>
		<map public="1" params="A:B" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>
		Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.
	</haxe_doc>
		</map>
		<mapi public="1" params="A:B" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>
		Similar to [map], but also pass an index for each item iterated.
	</haxe_doc>
		</mapi>
		<has public="1" params="A" line="77" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the element is part of an iterable
	</haxe_doc>
		</has>
		<exists public="1" params="A" line="93" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if at least one element of the iterable if found by using the specific function.
	</haxe_doc>
		</exists>
		<foreach public="1" params="A" line="103" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if all elements of the iterable have the specified property defined by [f].
	</haxe_doc>
		</foreach>
		<iter public="1" params="A" line="113" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Call the function 'f' on all elements of the [Iterable] 'it'.
	</haxe_doc>
		</iter>
		<filter public="1" params="A" line="121" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>
		Return the list of elements matching the function 'f'
	</haxe_doc>
		</filter>
		<fold public="1" params="A:B" line="132" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>
		Functional 'fold' using an [Iterable]
	</haxe_doc>
		</fold>
		<count public="1" params="A" line="141" static="1">
			<f a="it">
				<t path="Iterable"><c path="count.A"/></t>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Count the number of elements in an [Iterable]
	</haxe_doc>
		</count>
		<empty public="1" line="151" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an iterable does not contain any element.
	</haxe_doc>
		</empty>
		<haxe_doc>
	The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.
</haxe_doc>
	</class>
	<class path="neko.NekoDate__" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/NekoDate__.hx">
		<__name__ line="29" static="1"><c path="Array"><c path="String"/></c></__name__>
		<now line="73" static="1"><f a=""><c path="neko.NekoDate__"/></f></now>
		<fromTime line="77" static="1"><f a="t">
	<c path="Float"/>
	<c path="neko.NekoDate__"/>
</f></fromTime>
		<fromString line="85" static="1"><f a="s">
	<c path="String"/>
	<c path="neko.NekoDate__"/>
</f></fromString>
		<new1 line="89" static="1"><f a="t">
	<e path="Void"/>
	<c path="neko.NekoDate__"/>
</f></new1>
		<date_new line="95" static="1"><f a="">
	<unknown/>
	<e path="Void"/>
</f></date_new>
		<date_now line="96" static="1"><f a=""><e path="Void"/></f></date_now>
		<date_format line="97" static="1"><f a=":">
	<e path="Void"/>
	<unknown/>
	<c path="String"/>
</f></date_format>
		<date_set_hour line="98" static="1"><f a=":::">
	<e path="Void"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></date_set_hour>
		<date_set_day line="99" static="1"><f a=":::">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></date_set_day>
		<date_get_day line="100" static="1"><f a="">
	<d/>
	<a>
		<y><c path="Int"/></y>
		<m><c path="Int"/></m>
		<d><c path="Int"/></d>
	</a>
</f></date_get_day>
		<date_get_hour line="101" static="1"><f a="">
	<d/>
	<a>
		<s><c path="Int"/></s>
		<m><c path="Int"/></m>
		<h><c path="Int"/></h>
	</a>
</f></date_get_hour>
		<int32_to_float line="102" static="1"><f a="">
	<e path="Void"/>
	<c path="Int"/>
</f></int32_to_float>
		<int32_add line="103" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<e path="Void"/>
</f></int32_add>
		<int32_shl line="104" static="1"><f a=":">
	<unknown/>
	<c path="Int"/>
	<unknown/>
</f></int32_shl>
		<__t><e path="Void"/></__t>
		<getTime public="1" line="37"><f a=""><c path="Float"/></f></getTime>
		<getFullYear public="1" line="41"><f a=""><c path="Int"/></f></getFullYear>
		<getMonth public="1" line="45"><f a=""><c path="Int"/></f></getMonth>
		<getDate public="1" line="49"><f a=""><c path="Int"/></f></getDate>
		<getHours public="1" line="53"><f a=""><c path="Int"/></f></getHours>
		<getMinutes public="1" line="57"><f a=""><c path="Int"/></f></getMinutes>
		<getSeconds public="1" line="61"><f a=""><c path="Int"/></f></getSeconds>
		<getDay public="1" line="65"><f a=""><c path="Int"/></f></getDay>
		<toString public="1" line="69"><f a=""><c path="String"/></f></toString>
		<new public="1" line="32"><f a="year:month:day:hour:min:sec">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Date" params="" file="C:\Program Files\Motion-Twin\haxe/std/Date.hx" extern="1">
		<now public="1" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="haxe.io.Eof" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Eof.hx">
		<toString line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	This exception is raised when reading while data is no longer available in the [Input].
</haxe_doc>
	</class>
	<class path="neko.NekoXml__" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/NekoXml__.hx">
		<__name__ line="30" static="1"><c path="Array"><c path="String"/></c></__name__>
		<_parse line="46" static="1"><f a=":">
	<unknown/>
	<a>
		<xml><f a="name:att">
	<c path="String"/>
	<unknown/>
	<e path="Void"/>
</f></xml>
		<pcdata><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></pcdata>
		<done><f a=""><e path="Void"/></f></done>
		<doctype><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></doctype>
		<cur><c path="neko.NekoXml__"/></cur>
		<comment><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></comment>
		<cdata><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></cdata>
	</a>
	<unknown/>
</f></_parse>
		<parse line="48" static="1"><f a="xmlData">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></parse>
		<createElement line="116" static="1"><f a="name">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createElement>
		<createPCData line="125" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createPCData>
		<createCData line="132" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createCData>
		<createComment line="139" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createComment>
		<createDocType line="146" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createDocType>
		<createProlog line="153" static="1"><f a="data">
	<c path="String"/>
	<c path="neko.NekoXml__"/>
</f></createProlog>
		<createDocument line="160" static="1"><f a=""><c path="neko.NekoXml__"/></f></createDocument>
		<nodeName public="1" get="getNodeName" set="setNodeName"><c path="String"/></nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue"><c path="String"/></nodeValue>
		<parent public="1" get="getParent" set="null"><c path="neko.NekoXml__"/></parent>
		<nodeType public="1" set="null"><e path="XmlType"/></nodeType>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><d><c path="String"/></d></_attributes>
		<_children><c path="Array"><c path="neko.NekoXml__"/></c></_children>
		<_parent><c path="neko.NekoXml__"/></_parent>
		<getNodeName line="167"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName line="173"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue line="179"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue line="185"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent line="191"><f a=""><c path="neko.NekoXml__"/></f></getParent>
		<get public="1" line="195"><f a="att">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<set public="1" line="201"><f a="att:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<remove public="1" line="207"><f a="att">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
		<exists public="1" line="213"><f a="att">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<attributes public="1" line="219"><f a=""><t path="Iterator"><c path="String"/></t></f></attributes>
		<iterator public="1" line="225"><f a=""><t path="Iterator"><c path="neko.NekoXml__"/></t></f></iterator>
		<elements public="1" line="241"><f a=""><unknown/></f></elements>
		<elementsNamed public="1" line="274"><f a="name">
	<c path="String"/>
	<unknown/>
</f></elementsNamed>
		<firstChild public="1" line="308"><f a=""><c path="neko.NekoXml__"/></f></firstChild>
		<firstElement public="1" line="314"><f a=""><c path="neko.NekoXml__"/></f></firstElement>
		<addChild public="1" line="325"><f a="x">
	<c path="neko.NekoXml__"/>
	<e path="Void"/>
</f></addChild>
		<removeChild public="1" line="333"><f a="x">
	<c path="neko.NekoXml__"/>
	<e path="Bool"/>
</f></removeChild>
		<insertChild public="1" line="341"><f a="x:pos">
	<c path="neko.NekoXml__"/>
	<c path="Int"/>
	<e path="Void"/>
</f></insertChild>
		<toString public="1" line="349"><f a=""><c path="String"/></f></toString>
		<new line="43"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="opengl.GL" params="" file="../../../xinf/src/libs/opengl/api/opengl/GL.hx" extern="1">
		<VERSION_1_1 public="1" static="1"><c path="Int"/></VERSION_1_1>
		<VERSION_1_2 public="1" static="1"><c path="Int"/></VERSION_1_2>
		<VERSION_1_3 public="1" static="1"><c path="Int"/></VERSION_1_3>
		<FALSE public="1" static="1"><c path="Int"/></FALSE>
		<TRUE public="1" static="1"><c path="Int"/></TRUE>
		<BYTE public="1" static="1"><c path="Int"/></BYTE>
		<UNSIGNED_BYTE public="1" static="1"><c path="Int"/></UNSIGNED_BYTE>
		<SHORT public="1" static="1"><c path="Int"/></SHORT>
		<UNSIGNED_SHORT public="1" static="1"><c path="Int"/></UNSIGNED_SHORT>
		<INT public="1" static="1"><c path="Int"/></INT>
		<UNSIGNED_INT public="1" static="1"><c path="Int"/></UNSIGNED_INT>
		<FLOAT public="1" static="1"><c path="Int"/></FLOAT>
		<DOUBLE public="1" static="1"><c path="Int"/></DOUBLE>
		<POINTS public="1" static="1"><c path="Int"/></POINTS>
		<LINES public="1" static="1"><c path="Int"/></LINES>
		<LINE_LOOP public="1" static="1"><c path="Int"/></LINE_LOOP>
		<LINE_STRIP public="1" static="1"><c path="Int"/></LINE_STRIP>
		<TRIANGLES public="1" static="1"><c path="Int"/></TRIANGLES>
		<TRIANGLE_STRIP public="1" static="1"><c path="Int"/></TRIANGLE_STRIP>
		<TRIANGLE_FAN public="1" static="1"><c path="Int"/></TRIANGLE_FAN>
		<QUADS public="1" static="1"><c path="Int"/></QUADS>
		<QUAD_STRIP public="1" static="1"><c path="Int"/></QUAD_STRIP>
		<POLYGON public="1" static="1"><c path="Int"/></POLYGON>
		<VERTEX_ARRAY public="1" static="1"><c path="Int"/></VERTEX_ARRAY>
		<NORMAL_ARRAY public="1" static="1"><c path="Int"/></NORMAL_ARRAY>
		<COLOR_ARRAY public="1" static="1"><c path="Int"/></COLOR_ARRAY>
		<INDEX_ARRAY public="1" static="1"><c path="Int"/></INDEX_ARRAY>
		<TEXTURE_COORD_ARRAY public="1" static="1"><c path="Int"/></TEXTURE_COORD_ARRAY>
		<EDGE_FLAG_ARRAY public="1" static="1"><c path="Int"/></EDGE_FLAG_ARRAY>
		<VERTEX_ARRAY_SIZE public="1" static="1"><c path="Int"/></VERTEX_ARRAY_SIZE>
		<VERTEX_ARRAY_TYPE public="1" static="1"><c path="Int"/></VERTEX_ARRAY_TYPE>
		<VERTEX_ARRAY_STRIDE public="1" static="1"><c path="Int"/></VERTEX_ARRAY_STRIDE>
		<NORMAL_ARRAY_TYPE public="1" static="1"><c path="Int"/></NORMAL_ARRAY_TYPE>
		<NORMAL_ARRAY_STRIDE public="1" static="1"><c path="Int"/></NORMAL_ARRAY_STRIDE>
		<COLOR_ARRAY_SIZE public="1" static="1"><c path="Int"/></COLOR_ARRAY_SIZE>
		<COLOR_ARRAY_TYPE public="1" static="1"><c path="Int"/></COLOR_ARRAY_TYPE>
		<COLOR_ARRAY_STRIDE public="1" static="1"><c path="Int"/></COLOR_ARRAY_STRIDE>
		<INDEX_ARRAY_TYPE public="1" static="1"><c path="Int"/></INDEX_ARRAY_TYPE>
		<INDEX_ARRAY_STRIDE public="1" static="1"><c path="Int"/></INDEX_ARRAY_STRIDE>
		<TEXTURE_COORD_ARRAY_SIZE public="1" static="1"><c path="Int"/></TEXTURE_COORD_ARRAY_SIZE>
		<TEXTURE_COORD_ARRAY_TYPE public="1" static="1"><c path="Int"/></TEXTURE_COORD_ARRAY_TYPE>
		<TEXTURE_COORD_ARRAY_STRIDE public="1" static="1"><c path="Int"/></TEXTURE_COORD_ARRAY_STRIDE>
		<EDGE_FLAG_ARRAY_STRIDE public="1" static="1"><c path="Int"/></EDGE_FLAG_ARRAY_STRIDE>
		<VERTEX_ARRAY_POINTER public="1" static="1"><c path="Int"/></VERTEX_ARRAY_POINTER>
		<NORMAL_ARRAY_POINTER public="1" static="1"><c path="Int"/></NORMAL_ARRAY_POINTER>
		<COLOR_ARRAY_POINTER public="1" static="1"><c path="Int"/></COLOR_ARRAY_POINTER>
		<INDEX_ARRAY_POINTER public="1" static="1"><c path="Int"/></INDEX_ARRAY_POINTER>
		<TEXTURE_COORD_ARRAY_POINTER public="1" static="1"><c path="Int"/></TEXTURE_COORD_ARRAY_POINTER>
		<EDGE_FLAG_ARRAY_POINTER public="1" static="1"><c path="Int"/></EDGE_FLAG_ARRAY_POINTER>
		<V2F public="1" static="1"><c path="Int"/></V2F>
		<V3F public="1" static="1"><c path="Int"/></V3F>
		<C4UB_V2F public="1" static="1"><c path="Int"/></C4UB_V2F>
		<C4UB_V3F public="1" static="1"><c path="Int"/></C4UB_V3F>
		<C3F_V3F public="1" static="1"><c path="Int"/></C3F_V3F>
		<N3F_V3F public="1" static="1"><c path="Int"/></N3F_V3F>
		<C4F_N3F_V3F public="1" static="1"><c path="Int"/></C4F_N3F_V3F>
		<T2F_V3F public="1" static="1"><c path="Int"/></T2F_V3F>
		<T4F_V4F public="1" static="1"><c path="Int"/></T4F_V4F>
		<T2F_C4UB_V3F public="1" static="1"><c path="Int"/></T2F_C4UB_V3F>
		<T2F_C3F_V3F public="1" static="1"><c path="Int"/></T2F_C3F_V3F>
		<T2F_N3F_V3F public="1" static="1"><c path="Int"/></T2F_N3F_V3F>
		<T2F_C4F_N3F_V3F public="1" static="1"><c path="Int"/></T2F_C4F_N3F_V3F>
		<T4F_C4F_N3F_V4F public="1" static="1"><c path="Int"/></T4F_C4F_N3F_V4F>
		<MATRIX_MODE public="1" static="1"><c path="Int"/></MATRIX_MODE>
		<MODELVIEW public="1" static="1"><c path="Int"/></MODELVIEW>
		<PROJECTION public="1" static="1"><c path="Int"/></PROJECTION>
		<TEXTURE public="1" static="1"><c path="Int"/></TEXTURE>
		<POINT_SMOOTH public="1" static="1"><c path="Int"/></POINT_SMOOTH>
		<POINT_SIZE public="1" static="1"><c path="Int"/></POINT_SIZE>
		<POINT_SIZE_GRANULARITY public="1" static="1"><c path="Int"/></POINT_SIZE_GRANULARITY>
		<POINT_SIZE_RANGE public="1" static="1"><c path="Int"/></POINT_SIZE_RANGE>
		<LINE_SMOOTH public="1" static="1"><c path="Int"/></LINE_SMOOTH>
		<LINE_STIPPLE public="1" static="1"><c path="Int"/></LINE_STIPPLE>
		<LINE_STIPPLE_PATTERN public="1" static="1"><c path="Int"/></LINE_STIPPLE_PATTERN>
		<LINE_STIPPLE_REPEAT public="1" static="1"><c path="Int"/></LINE_STIPPLE_REPEAT>
		<LINE_WIDTH public="1" static="1"><c path="Int"/></LINE_WIDTH>
		<LINE_WIDTH_GRANULARITY public="1" static="1"><c path="Int"/></LINE_WIDTH_GRANULARITY>
		<LINE_WIDTH_RANGE public="1" static="1"><c path="Int"/></LINE_WIDTH_RANGE>
		<POINT public="1" static="1"><c path="Int"/></POINT>
		<LINE public="1" static="1"><c path="Int"/></LINE>
		<FILL public="1" static="1"><c path="Int"/></FILL>
		<CW public="1" static="1"><c path="Int"/></CW>
		<CCW public="1" static="1"><c path="Int"/></CCW>
		<FRONT public="1" static="1"><c path="Int"/></FRONT>
		<BACK public="1" static="1"><c path="Int"/></BACK>
		<POLYGON_MODE public="1" static="1"><c path="Int"/></POLYGON_MODE>
		<POLYGON_SMOOTH public="1" static="1"><c path="Int"/></POLYGON_SMOOTH>
		<POLYGON_STIPPLE public="1" static="1"><c path="Int"/></POLYGON_STIPPLE>
		<EDGE_FLAG public="1" static="1"><c path="Int"/></EDGE_FLAG>
		<CULL_FACE public="1" static="1"><c path="Int"/></CULL_FACE>
		<CULL_FACE_MODE public="1" static="1"><c path="Int"/></CULL_FACE_MODE>
		<FRONT_FACE public="1" static="1"><c path="Int"/></FRONT_FACE>
		<POLYGON_OFFSET_FACTOR public="1" static="1"><c path="Int"/></POLYGON_OFFSET_FACTOR>
		<POLYGON_OFFSET_UNITS public="1" static="1"><c path="Int"/></POLYGON_OFFSET_UNITS>
		<POLYGON_OFFSET_POINT public="1" static="1"><c path="Int"/></POLYGON_OFFSET_POINT>
		<POLYGON_OFFSET_LINE public="1" static="1"><c path="Int"/></POLYGON_OFFSET_LINE>
		<POLYGON_OFFSET_FILL public="1" static="1"><c path="Int"/></POLYGON_OFFSET_FILL>
		<COMPILE public="1" static="1"><c path="Int"/></COMPILE>
		<COMPILE_AND_EXECUTE public="1" static="1"><c path="Int"/></COMPILE_AND_EXECUTE>
		<LIST_BASE public="1" static="1"><c path="Int"/></LIST_BASE>
		<LIST_INDEX public="1" static="1"><c path="Int"/></LIST_INDEX>
		<LIST_MODE public="1" static="1"><c path="Int"/></LIST_MODE>
		<NEVER public="1" static="1"><c path="Int"/></NEVER>
		<LESS public="1" static="1"><c path="Int"/></LESS>
		<EQUAL public="1" static="1"><c path="Int"/></EQUAL>
		<LEQUAL public="1" static="1"><c path="Int"/></LEQUAL>
		<GREATER public="1" static="1"><c path="Int"/></GREATER>
		<NOTEQUAL public="1" static="1"><c path="Int"/></NOTEQUAL>
		<GEQUAL public="1" static="1"><c path="Int"/></GEQUAL>
		<ALWAYS public="1" static="1"><c path="Int"/></ALWAYS>
		<DEPTH_TEST public="1" static="1"><c path="Int"/></DEPTH_TEST>
		<DEPTH_BITS public="1" static="1"><c path="Int"/></DEPTH_BITS>
		<DEPTH_CLEAR_VALUE public="1" static="1"><c path="Int"/></DEPTH_CLEAR_VALUE>
		<DEPTH_FUNC public="1" static="1"><c path="Int"/></DEPTH_FUNC>
		<DEPTH_RANGE public="1" static="1"><c path="Int"/></DEPTH_RANGE>
		<DEPTH_WRITEMASK public="1" static="1"><c path="Int"/></DEPTH_WRITEMASK>
		<DEPTH_COMPONENT public="1" static="1"><c path="Int"/></DEPTH_COMPONENT>
		<LIGHTING public="1" static="1"><c path="Int"/></LIGHTING>
		<LIGHT0 public="1" static="1"><c path="Int"/></LIGHT0>
		<LIGHT1 public="1" static="1"><c path="Int"/></LIGHT1>
		<LIGHT2 public="1" static="1"><c path="Int"/></LIGHT2>
		<LIGHT3 public="1" static="1"><c path="Int"/></LIGHT3>
		<LIGHT4 public="1" static="1"><c path="Int"/></LIGHT4>
		<LIGHT5 public="1" static="1"><c path="Int"/></LIGHT5>
		<LIGHT6 public="1" static="1"><c path="Int"/></LIGHT6>
		<LIGHT7 public="1" static="1"><c path="Int"/></LIGHT7>
		<SPOT_EXPONENT public="1" static="1"><c path="Int"/></SPOT_EXPONENT>
		<SPOT_CUTOFF public="1" static="1"><c path="Int"/></SPOT_CUTOFF>
		<CONSTANT_ATTENUATION public="1" static="1"><c path="Int"/></CONSTANT_ATTENUATION>
		<LINEAR_ATTENUATION public="1" static="1"><c path="Int"/></LINEAR_ATTENUATION>
		<QUADRATIC_ATTENUATION public="1" static="1"><c path="Int"/></QUADRATIC_ATTENUATION>
		<AMBIENT public="1" static="1"><c path="Int"/></AMBIENT>
		<DIFFUSE public="1" static="1"><c path="Int"/></DIFFUSE>
		<SPECULAR public="1" static="1"><c path="Int"/></SPECULAR>
		<SHININESS public="1" static="1"><c path="Int"/></SHININESS>
		<EMISSION public="1" static="1"><c path="Int"/></EMISSION>
		<POSITION public="1" static="1"><c path="Int"/></POSITION>
		<SPOT_DIRECTION public="1" static="1"><c path="Int"/></SPOT_DIRECTION>
		<AMBIENT_AND_DIFFUSE public="1" static="1"><c path="Int"/></AMBIENT_AND_DIFFUSE>
		<COLOR_INDEXES public="1" static="1"><c path="Int"/></COLOR_INDEXES>
		<LIGHT_MODEL_TWO_SIDE public="1" static="1"><c path="Int"/></LIGHT_MODEL_TWO_SIDE>
		<LIGHT_MODEL_LOCAL_VIEWER public="1" static="1"><c path="Int"/></LIGHT_MODEL_LOCAL_VIEWER>
		<LIGHT_MODEL_AMBIENT public="1" static="1"><c path="Int"/></LIGHT_MODEL_AMBIENT>
		<FRONT_AND_BACK public="1" static="1"><c path="Int"/></FRONT_AND_BACK>
		<SHADE_MODEL public="1" static="1"><c path="Int"/></SHADE_MODEL>
		<FLAT public="1" static="1"><c path="Int"/></FLAT>
		<SMOOTH public="1" static="1"><c path="Int"/></SMOOTH>
		<COLOR_MATERIAL public="1" static="1"><c path="Int"/></COLOR_MATERIAL>
		<COLOR_MATERIAL_FACE public="1" static="1"><c path="Int"/></COLOR_MATERIAL_FACE>
		<COLOR_MATERIAL_PARAMETER public="1" static="1"><c path="Int"/></COLOR_MATERIAL_PARAMETER>
		<NORMALIZE public="1" static="1"><c path="Int"/></NORMALIZE>
		<CLIP_PLANE0 public="1" static="1"><c path="Int"/></CLIP_PLANE0>
		<CLIP_PLANE1 public="1" static="1"><c path="Int"/></CLIP_PLANE1>
		<CLIP_PLANE2 public="1" static="1"><c path="Int"/></CLIP_PLANE2>
		<CLIP_PLANE3 public="1" static="1"><c path="Int"/></CLIP_PLANE3>
		<CLIP_PLANE4 public="1" static="1"><c path="Int"/></CLIP_PLANE4>
		<CLIP_PLANE5 public="1" static="1"><c path="Int"/></CLIP_PLANE5>
		<ACCUM_RED_BITS public="1" static="1"><c path="Int"/></ACCUM_RED_BITS>
		<ACCUM_GREEN_BITS public="1" static="1"><c path="Int"/></ACCUM_GREEN_BITS>
		<ACCUM_BLUE_BITS public="1" static="1"><c path="Int"/></ACCUM_BLUE_BITS>
		<ACCUM_ALPHA_BITS public="1" static="1"><c path="Int"/></ACCUM_ALPHA_BITS>
		<ACCUM_CLEAR_VALUE public="1" static="1"><c path="Int"/></ACCUM_CLEAR_VALUE>
		<ACCUM public="1" static="1"><c path="Int"/></ACCUM>
		<ADD public="1" static="1"><c path="Int"/></ADD>
		<LOAD public="1" static="1"><c path="Int"/></LOAD>
		<MULT public="1" static="1"><c path="Int"/></MULT>
		<RETURN public="1" static="1"><c path="Int"/></RETURN>
		<ALPHA_TEST public="1" static="1"><c path="Int"/></ALPHA_TEST>
		<ALPHA_TEST_REF public="1" static="1"><c path="Int"/></ALPHA_TEST_REF>
		<ALPHA_TEST_FUNC public="1" static="1"><c path="Int"/></ALPHA_TEST_FUNC>
		<BLEND public="1" static="1"><c path="Int"/></BLEND>
		<BLEND_SRC public="1" static="1"><c path="Int"/></BLEND_SRC>
		<BLEND_DST public="1" static="1"><c path="Int"/></BLEND_DST>
		<ZERO public="1" static="1"><c path="Int"/></ZERO>
		<ONE public="1" static="1"><c path="Int"/></ONE>
		<SRC_COLOR public="1" static="1"><c path="Int"/></SRC_COLOR>
		<ONE_MINUS_SRC_COLOR public="1" static="1"><c path="Int"/></ONE_MINUS_SRC_COLOR>
		<SRC_ALPHA public="1" static="1"><c path="Int"/></SRC_ALPHA>
		<ONE_MINUS_SRC_ALPHA public="1" static="1"><c path="Int"/></ONE_MINUS_SRC_ALPHA>
		<DST_ALPHA public="1" static="1"><c path="Int"/></DST_ALPHA>
		<ONE_MINUS_DST_ALPHA public="1" static="1"><c path="Int"/></ONE_MINUS_DST_ALPHA>
		<DST_COLOR public="1" static="1"><c path="Int"/></DST_COLOR>
		<ONE_MINUS_DST_COLOR public="1" static="1"><c path="Int"/></ONE_MINUS_DST_COLOR>
		<SRC_ALPHA_SATURATE public="1" static="1"><c path="Int"/></SRC_ALPHA_SATURATE>
		<FEEDBACK public="1" static="1"><c path="Int"/></FEEDBACK>
		<RENDER public="1" static="1"><c path="Int"/></RENDER>
		<SELECT public="1" static="1"><c path="Int"/></SELECT>
		<POINT_TOKEN public="1" static="1"><c path="Int"/></POINT_TOKEN>
		<LINE_TOKEN public="1" static="1"><c path="Int"/></LINE_TOKEN>
		<LINE_RESET_TOKEN public="1" static="1"><c path="Int"/></LINE_RESET_TOKEN>
		<POLYGON_TOKEN public="1" static="1"><c path="Int"/></POLYGON_TOKEN>
		<BITMAP_TOKEN public="1" static="1"><c path="Int"/></BITMAP_TOKEN>
		<DRAW_PIXEL_TOKEN public="1" static="1"><c path="Int"/></DRAW_PIXEL_TOKEN>
		<COPY_PIXEL_TOKEN public="1" static="1"><c path="Int"/></COPY_PIXEL_TOKEN>
		<PASS_THROUGH_TOKEN public="1" static="1"><c path="Int"/></PASS_THROUGH_TOKEN>
		<FEEDBACK_BUFFER_POINTER public="1" static="1"><c path="Int"/></FEEDBACK_BUFFER_POINTER>
		<FEEDBACK_BUFFER_SIZE public="1" static="1"><c path="Int"/></FEEDBACK_BUFFER_SIZE>
		<FEEDBACK_BUFFER_TYPE public="1" static="1"><c path="Int"/></FEEDBACK_BUFFER_TYPE>
		<SELECTION_BUFFER_POINTER public="1" static="1"><c path="Int"/></SELECTION_BUFFER_POINTER>
		<SELECTION_BUFFER_SIZE public="1" static="1"><c path="Int"/></SELECTION_BUFFER_SIZE>
		<FOG public="1" static="1"><c path="Int"/></FOG>
		<FOG_MODE public="1" static="1"><c path="Int"/></FOG_MODE>
		<FOG_DENSITY public="1" static="1"><c path="Int"/></FOG_DENSITY>
		<FOG_COLOR public="1" static="1"><c path="Int"/></FOG_COLOR>
		<FOG_INDEX public="1" static="1"><c path="Int"/></FOG_INDEX>
		<FOG_START public="1" static="1"><c path="Int"/></FOG_START>
		<FOG_END public="1" static="1"><c path="Int"/></FOG_END>
		<LINEAR public="1" static="1"><c path="Int"/></LINEAR>
		<EXP public="1" static="1"><c path="Int"/></EXP>
		<EXP2 public="1" static="1"><c path="Int"/></EXP2>
		<LOGIC_OP public="1" static="1"><c path="Int"/></LOGIC_OP>
		<INDEX_LOGIC_OP public="1" static="1"><c path="Int"/></INDEX_LOGIC_OP>
		<COLOR_LOGIC_OP public="1" static="1"><c path="Int"/></COLOR_LOGIC_OP>
		<LOGIC_OP_MODE public="1" static="1"><c path="Int"/></LOGIC_OP_MODE>
		<CLEAR public="1" static="1"><c path="Int"/></CLEAR>
		<SET public="1" static="1"><c path="Int"/></SET>
		<COPY public="1" static="1"><c path="Int"/></COPY>
		<COPY_INVERTED public="1" static="1"><c path="Int"/></COPY_INVERTED>
		<NOOP public="1" static="1"><c path="Int"/></NOOP>
		<INVERT public="1" static="1"><c path="Int"/></INVERT>
		<AND public="1" static="1"><c path="Int"/></AND>
		<NAND public="1" static="1"><c path="Int"/></NAND>
		<OR public="1" static="1"><c path="Int"/></OR>
		<NOR public="1" static="1"><c path="Int"/></NOR>
		<XOR public="1" static="1"><c path="Int"/></XOR>
		<EQUIV public="1" static="1"><c path="Int"/></EQUIV>
		<AND_REVERSE public="1" static="1"><c path="Int"/></AND_REVERSE>
		<AND_INVERTED public="1" static="1"><c path="Int"/></AND_INVERTED>
		<OR_REVERSE public="1" static="1"><c path="Int"/></OR_REVERSE>
		<OR_INVERTED public="1" static="1"><c path="Int"/></OR_INVERTED>
		<STENCIL_TEST public="1" static="1"><c path="Int"/></STENCIL_TEST>
		<STENCIL_WRITEMASK public="1" static="1"><c path="Int"/></STENCIL_WRITEMASK>
		<STENCIL_BITS public="1" static="1"><c path="Int"/></STENCIL_BITS>
		<STENCIL_FUNC public="1" static="1"><c path="Int"/></STENCIL_FUNC>
		<STENCIL_VALUE_MASK public="1" static="1"><c path="Int"/></STENCIL_VALUE_MASK>
		<STENCIL_REF public="1" static="1"><c path="Int"/></STENCIL_REF>
		<STENCIL_FAIL public="1" static="1"><c path="Int"/></STENCIL_FAIL>
		<STENCIL_PASS_DEPTH_PASS public="1" static="1"><c path="Int"/></STENCIL_PASS_DEPTH_PASS>
		<STENCIL_PASS_DEPTH_FAIL public="1" static="1"><c path="Int"/></STENCIL_PASS_DEPTH_FAIL>
		<STENCIL_CLEAR_VALUE public="1" static="1"><c path="Int"/></STENCIL_CLEAR_VALUE>
		<STENCIL_INDEX public="1" static="1"><c path="Int"/></STENCIL_INDEX>
		<KEEP public="1" static="1"><c path="Int"/></KEEP>
		<REPLACE public="1" static="1"><c path="Int"/></REPLACE>
		<INCR public="1" static="1"><c path="Int"/></INCR>
		<DECR public="1" static="1"><c path="Int"/></DECR>
		<NONE public="1" static="1"><c path="Int"/></NONE>
		<LEFT public="1" static="1"><c path="Int"/></LEFT>
		<RIGHT public="1" static="1"><c path="Int"/></RIGHT>
		<FRONT_LEFT public="1" static="1"><c path="Int"/></FRONT_LEFT>
		<FRONT_RIGHT public="1" static="1"><c path="Int"/></FRONT_RIGHT>
		<BACK_LEFT public="1" static="1"><c path="Int"/></BACK_LEFT>
		<BACK_RIGHT public="1" static="1"><c path="Int"/></BACK_RIGHT>
		<AUX0 public="1" static="1"><c path="Int"/></AUX0>
		<AUX1 public="1" static="1"><c path="Int"/></AUX1>
		<AUX2 public="1" static="1"><c path="Int"/></AUX2>
		<AUX3 public="1" static="1"><c path="Int"/></AUX3>
		<COLOR_INDEX public="1" static="1"><c path="Int"/></COLOR_INDEX>
		<RED public="1" static="1"><c path="Int"/></RED>
		<GREEN public="1" static="1"><c path="Int"/></GREEN>
		<BLUE public="1" static="1"><c path="Int"/></BLUE>
		<ALPHA public="1" static="1"><c path="Int"/></ALPHA>
		<LUMINANCE public="1" static="1"><c path="Int"/></LUMINANCE>
		<LUMINANCE_ALPHA public="1" static="1"><c path="Int"/></LUMINANCE_ALPHA>
		<ALPHA_BITS public="1" static="1"><c path="Int"/></ALPHA_BITS>
		<RED_BITS public="1" static="1"><c path="Int"/></RED_BITS>
		<GREEN_BITS public="1" static="1"><c path="Int"/></GREEN_BITS>
		<BLUE_BITS public="1" static="1"><c path="Int"/></BLUE_BITS>
		<INDEX_BITS public="1" static="1"><c path="Int"/></INDEX_BITS>
		<SUBPIXEL_BITS public="1" static="1"><c path="Int"/></SUBPIXEL_BITS>
		<AUX_BUFFERS public="1" static="1"><c path="Int"/></AUX_BUFFERS>
		<READ_BUFFER public="1" static="1"><c path="Int"/></READ_BUFFER>
		<DRAW_BUFFER public="1" static="1"><c path="Int"/></DRAW_BUFFER>
		<DOUBLEBUFFER public="1" static="1"><c path="Int"/></DOUBLEBUFFER>
		<STEREO public="1" static="1"><c path="Int"/></STEREO>
		<BITMAP public="1" static="1"><c path="Int"/></BITMAP>
		<COLOR public="1" static="1"><c path="Int"/></COLOR>
		<DEPTH public="1" static="1"><c path="Int"/></DEPTH>
		<STENCIL public="1" static="1"><c path="Int"/></STENCIL>
		<DITHER public="1" static="1"><c path="Int"/></DITHER>
		<RGB public="1" static="1"><c path="Int"/></RGB>
		<RGBA public="1" static="1"><c path="Int"/></RGBA>
		<MAX_LIST_NESTING public="1" static="1"><c path="Int"/></MAX_LIST_NESTING>
		<MAX_ATTRIB_STACK_DEPTH public="1" static="1"><c path="Int"/></MAX_ATTRIB_STACK_DEPTH>
		<MAX_MODELVIEW_STACK_DEPTH public="1" static="1"><c path="Int"/></MAX_MODELVIEW_STACK_DEPTH>
		<MAX_NAME_STACK_DEPTH public="1" static="1"><c path="Int"/></MAX_NAME_STACK_DEPTH>
		<MAX_PROJECTION_STACK_DEPTH public="1" static="1"><c path="Int"/></MAX_PROJECTION_STACK_DEPTH>
		<MAX_TEXTURE_STACK_DEPTH public="1" static="1"><c path="Int"/></MAX_TEXTURE_STACK_DEPTH>
		<MAX_EVAL_ORDER public="1" static="1"><c path="Int"/></MAX_EVAL_ORDER>
		<MAX_LIGHTS public="1" static="1"><c path="Int"/></MAX_LIGHTS>
		<MAX_CLIP_PLANES public="1" static="1"><c path="Int"/></MAX_CLIP_PLANES>
		<MAX_TEXTURE_SIZE public="1" static="1"><c path="Int"/></MAX_TEXTURE_SIZE>
		<MAX_PIXEL_MAP_TABLE public="1" static="1"><c path="Int"/></MAX_PIXEL_MAP_TABLE>
		<MAX_VIEWPORT_DIMS public="1" static="1"><c path="Int"/></MAX_VIEWPORT_DIMS>
		<MAX_CLIENT_ATTRIB_STACK_DEPTH public="1" static="1"><c path="Int"/></MAX_CLIENT_ATTRIB_STACK_DEPTH>
		<ATTRIB_STACK_DEPTH public="1" static="1"><c path="Int"/></ATTRIB_STACK_DEPTH>
		<CLIENT_ATTRIB_STACK_DEPTH public="1" static="1"><c path="Int"/></CLIENT_ATTRIB_STACK_DEPTH>
		<COLOR_CLEAR_VALUE public="1" static="1"><c path="Int"/></COLOR_CLEAR_VALUE>
		<COLOR_WRITEMASK public="1" static="1"><c path="Int"/></COLOR_WRITEMASK>
		<CURRENT_INDEX public="1" static="1"><c path="Int"/></CURRENT_INDEX>
		<CURRENT_COLOR public="1" static="1"><c path="Int"/></CURRENT_COLOR>
		<CURRENT_NORMAL public="1" static="1"><c path="Int"/></CURRENT_NORMAL>
		<CURRENT_RASTER_COLOR public="1" static="1"><c path="Int"/></CURRENT_RASTER_COLOR>
		<CURRENT_RASTER_DISTANCE public="1" static="1"><c path="Int"/></CURRENT_RASTER_DISTANCE>
		<CURRENT_RASTER_INDEX public="1" static="1"><c path="Int"/></CURRENT_RASTER_INDEX>
		<CURRENT_RASTER_POSITION public="1" static="1"><c path="Int"/></CURRENT_RASTER_POSITION>
		<CURRENT_RASTER_TEXTURE_COORDS public="1" static="1"><c path="Int"/></CURRENT_RASTER_TEXTURE_COORDS>
		<CURRENT_RASTER_POSITION_VALID public="1" static="1"><c path="Int"/></CURRENT_RASTER_POSITION_VALID>
		<CURRENT_TEXTURE_COORDS public="1" static="1"><c path="Int"/></CURRENT_TEXTURE_COORDS>
		<INDEX_CLEAR_VALUE public="1" static="1"><c path="Int"/></INDEX_CLEAR_VALUE>
		<INDEX_MODE public="1" static="1"><c path="Int"/></INDEX_MODE>
		<INDEX_WRITEMASK public="1" static="1"><c path="Int"/></INDEX_WRITEMASK>
		<MODELVIEW_MATRIX public="1" static="1"><c path="Int"/></MODELVIEW_MATRIX>
		<MODELVIEW_STACK_DEPTH public="1" static="1"><c path="Int"/></MODELVIEW_STACK_DEPTH>
		<NAME_STACK_DEPTH public="1" static="1"><c path="Int"/></NAME_STACK_DEPTH>
		<PROJECTION_MATRIX public="1" static="1"><c path="Int"/></PROJECTION_MATRIX>
		<PROJECTION_STACK_DEPTH public="1" static="1"><c path="Int"/></PROJECTION_STACK_DEPTH>
		<RENDER_MODE public="1" static="1"><c path="Int"/></RENDER_MODE>
		<RGBA_MODE public="1" static="1"><c path="Int"/></RGBA_MODE>
		<TEXTURE_MATRIX public="1" static="1"><c path="Int"/></TEXTURE_MATRIX>
		<TEXTURE_STACK_DEPTH public="1" static="1"><c path="Int"/></TEXTURE_STACK_DEPTH>
		<VIEWPORT public="1" static="1"><c path="Int"/></VIEWPORT>
		<AUTO_NORMAL public="1" static="1"><c path="Int"/></AUTO_NORMAL>
		<MAP1_COLOR_4 public="1" static="1"><c path="Int"/></MAP1_COLOR_4>
		<MAP1_INDEX public="1" static="1"><c path="Int"/></MAP1_INDEX>
		<MAP1_NORMAL public="1" static="1"><c path="Int"/></MAP1_NORMAL>
		<MAP1_TEXTURE_COORD_1 public="1" static="1"><c path="Int"/></MAP1_TEXTURE_COORD_1>
		<MAP1_TEXTURE_COORD_2 public="1" static="1"><c path="Int"/></MAP1_TEXTURE_COORD_2>
		<MAP1_TEXTURE_COORD_3 public="1" static="1"><c path="Int"/></MAP1_TEXTURE_COORD_3>
		<MAP1_TEXTURE_COORD_4 public="1" static="1"><c path="Int"/></MAP1_TEXTURE_COORD_4>
		<MAP1_VERTEX_3 public="1" static="1"><c path="Int"/></MAP1_VERTEX_3>
		<MAP1_VERTEX_4 public="1" static="1"><c path="Int"/></MAP1_VERTEX_4>
		<MAP2_COLOR_4 public="1" static="1"><c path="Int"/></MAP2_COLOR_4>
		<MAP2_INDEX public="1" static="1"><c path="Int"/></MAP2_INDEX>
		<MAP2_NORMAL public="1" static="1"><c path="Int"/></MAP2_NORMAL>
		<MAP2_TEXTURE_COORD_1 public="1" static="1"><c path="Int"/></MAP2_TEXTURE_COORD_1>
		<MAP2_TEXTURE_COORD_2 public="1" static="1"><c path="Int"/></MAP2_TEXTURE_COORD_2>
		<MAP2_TEXTURE_COORD_3 public="1" static="1"><c path="Int"/></MAP2_TEXTURE_COORD_3>
		<MAP2_TEXTURE_COORD_4 public="1" static="1"><c path="Int"/></MAP2_TEXTURE_COORD_4>
		<MAP2_VERTEX_3 public="1" static="1"><c path="Int"/></MAP2_VERTEX_3>
		<MAP2_VERTEX_4 public="1" static="1"><c path="Int"/></MAP2_VERTEX_4>
		<MAP1_GRID_DOMAIN public="1" static="1"><c path="Int"/></MAP1_GRID_DOMAIN>
		<MAP1_GRID_SEGMENTS public="1" static="1"><c path="Int"/></MAP1_GRID_SEGMENTS>
		<MAP2_GRID_DOMAIN public="1" static="1"><c path="Int"/></MAP2_GRID_DOMAIN>
		<MAP2_GRID_SEGMENTS public="1" static="1"><c path="Int"/></MAP2_GRID_SEGMENTS>
		<COEFF public="1" static="1"><c path="Int"/></COEFF>
		<DOMAIN public="1" static="1"><c path="Int"/></DOMAIN>
		<ORDER public="1" static="1"><c path="Int"/></ORDER>
		<FOG_HINT public="1" static="1"><c path="Int"/></FOG_HINT>
		<LINE_SMOOTH_HINT public="1" static="1"><c path="Int"/></LINE_SMOOTH_HINT>
		<PERSPECTIVE_CORRECTION_HINT public="1" static="1"><c path="Int"/></PERSPECTIVE_CORRECTION_HINT>
		<POINT_SMOOTH_HINT public="1" static="1"><c path="Int"/></POINT_SMOOTH_HINT>
		<POLYGON_SMOOTH_HINT public="1" static="1"><c path="Int"/></POLYGON_SMOOTH_HINT>
		<DONT_CARE public="1" static="1"><c path="Int"/></DONT_CARE>
		<FASTEST public="1" static="1"><c path="Int"/></FASTEST>
		<NICEST public="1" static="1"><c path="Int"/></NICEST>
		<SCISSOR_TEST public="1" static="1"><c path="Int"/></SCISSOR_TEST>
		<SCISSOR_BOX public="1" static="1"><c path="Int"/></SCISSOR_BOX>
		<MAP_COLOR public="1" static="1"><c path="Int"/></MAP_COLOR>
		<MAP_STENCIL public="1" static="1"><c path="Int"/></MAP_STENCIL>
		<INDEX_SHIFT public="1" static="1"><c path="Int"/></INDEX_SHIFT>
		<INDEX_OFFSET public="1" static="1"><c path="Int"/></INDEX_OFFSET>
		<RED_SCALE public="1" static="1"><c path="Int"/></RED_SCALE>
		<RED_BIAS public="1" static="1"><c path="Int"/></RED_BIAS>
		<GREEN_SCALE public="1" static="1"><c path="Int"/></GREEN_SCALE>
		<GREEN_BIAS public="1" static="1"><c path="Int"/></GREEN_BIAS>
		<BLUE_SCALE public="1" static="1"><c path="Int"/></BLUE_SCALE>
		<BLUE_BIAS public="1" static="1"><c path="Int"/></BLUE_BIAS>
		<ALPHA_SCALE public="1" static="1"><c path="Int"/></ALPHA_SCALE>
		<ALPHA_BIAS public="1" static="1"><c path="Int"/></ALPHA_BIAS>
		<DEPTH_SCALE public="1" static="1"><c path="Int"/></DEPTH_SCALE>
		<DEPTH_BIAS public="1" static="1"><c path="Int"/></DEPTH_BIAS>
		<PIXEL_MAP_S_TO_S_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_S_TO_S_SIZE>
		<PIXEL_MAP_I_TO_I_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_I_SIZE>
		<PIXEL_MAP_I_TO_R_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_R_SIZE>
		<PIXEL_MAP_I_TO_G_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_G_SIZE>
		<PIXEL_MAP_I_TO_B_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_B_SIZE>
		<PIXEL_MAP_I_TO_A_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_A_SIZE>
		<PIXEL_MAP_R_TO_R_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_R_TO_R_SIZE>
		<PIXEL_MAP_G_TO_G_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_G_TO_G_SIZE>
		<PIXEL_MAP_B_TO_B_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_B_TO_B_SIZE>
		<PIXEL_MAP_A_TO_A_SIZE public="1" static="1"><c path="Int"/></PIXEL_MAP_A_TO_A_SIZE>
		<PIXEL_MAP_S_TO_S public="1" static="1"><c path="Int"/></PIXEL_MAP_S_TO_S>
		<PIXEL_MAP_I_TO_I public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_I>
		<PIXEL_MAP_I_TO_R public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_R>
		<PIXEL_MAP_I_TO_G public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_G>
		<PIXEL_MAP_I_TO_B public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_B>
		<PIXEL_MAP_I_TO_A public="1" static="1"><c path="Int"/></PIXEL_MAP_I_TO_A>
		<PIXEL_MAP_R_TO_R public="1" static="1"><c path="Int"/></PIXEL_MAP_R_TO_R>
		<PIXEL_MAP_G_TO_G public="1" static="1"><c path="Int"/></PIXEL_MAP_G_TO_G>
		<PIXEL_MAP_B_TO_B public="1" static="1"><c path="Int"/></PIXEL_MAP_B_TO_B>
		<PIXEL_MAP_A_TO_A public="1" static="1"><c path="Int"/></PIXEL_MAP_A_TO_A>
		<PACK_ALIGNMENT public="1" static="1"><c path="Int"/></PACK_ALIGNMENT>
		<PACK_LSB_FIRST public="1" static="1"><c path="Int"/></PACK_LSB_FIRST>
		<PACK_ROW_LENGTH public="1" static="1"><c path="Int"/></PACK_ROW_LENGTH>
		<PACK_SKIP_PIXELS public="1" static="1"><c path="Int"/></PACK_SKIP_PIXELS>
		<PACK_SKIP_ROWS public="1" static="1"><c path="Int"/></PACK_SKIP_ROWS>
		<PACK_SWAP_BYTES public="1" static="1"><c path="Int"/></PACK_SWAP_BYTES>
		<UNPACK_ALIGNMENT public="1" static="1"><c path="Int"/></UNPACK_ALIGNMENT>
		<UNPACK_LSB_FIRST public="1" static="1"><c path="Int"/></UNPACK_LSB_FIRST>
		<UNPACK_ROW_LENGTH public="1" static="1"><c path="Int"/></UNPACK_ROW_LENGTH>
		<UNPACK_SKIP_PIXELS public="1" static="1"><c path="Int"/></UNPACK_SKIP_PIXELS>
		<UNPACK_SKIP_ROWS public="1" static="1"><c path="Int"/></UNPACK_SKIP_ROWS>
		<UNPACK_SWAP_BYTES public="1" static="1"><c path="Int"/></UNPACK_SWAP_BYTES>
		<ZOOM_X public="1" static="1"><c path="Int"/></ZOOM_X>
		<ZOOM_Y public="1" static="1"><c path="Int"/></ZOOM_Y>
		<TEXTURE_ENV public="1" static="1"><c path="Int"/></TEXTURE_ENV>
		<TEXTURE_ENV_MODE public="1" static="1"><c path="Int"/></TEXTURE_ENV_MODE>
		<TEXTURE_1D public="1" static="1"><c path="Int"/></TEXTURE_1D>
		<TEXTURE_2D public="1" static="1"><c path="Int"/></TEXTURE_2D>
		<TEXTURE_WRAP_S public="1" static="1"><c path="Int"/></TEXTURE_WRAP_S>
		<TEXTURE_WRAP_T public="1" static="1"><c path="Int"/></TEXTURE_WRAP_T>
		<TEXTURE_MAG_FILTER public="1" static="1"><c path="Int"/></TEXTURE_MAG_FILTER>
		<TEXTURE_MIN_FILTER public="1" static="1"><c path="Int"/></TEXTURE_MIN_FILTER>
		<TEXTURE_ENV_COLOR public="1" static="1"><c path="Int"/></TEXTURE_ENV_COLOR>
		<TEXTURE_GEN_S public="1" static="1"><c path="Int"/></TEXTURE_GEN_S>
		<TEXTURE_GEN_T public="1" static="1"><c path="Int"/></TEXTURE_GEN_T>
		<TEXTURE_GEN_MODE public="1" static="1"><c path="Int"/></TEXTURE_GEN_MODE>
		<TEXTURE_BORDER_COLOR public="1" static="1"><c path="Int"/></TEXTURE_BORDER_COLOR>
		<TEXTURE_WIDTH public="1" static="1"><c path="Int"/></TEXTURE_WIDTH>
		<TEXTURE_HEIGHT public="1" static="1"><c path="Int"/></TEXTURE_HEIGHT>
		<TEXTURE_BORDER public="1" static="1"><c path="Int"/></TEXTURE_BORDER>
		<TEXTURE_COMPONENTS public="1" static="1"><c path="Int"/></TEXTURE_COMPONENTS>
		<TEXTURE_RED_SIZE public="1" static="1"><c path="Int"/></TEXTURE_RED_SIZE>
		<TEXTURE_GREEN_SIZE public="1" static="1"><c path="Int"/></TEXTURE_GREEN_SIZE>
		<TEXTURE_BLUE_SIZE public="1" static="1"><c path="Int"/></TEXTURE_BLUE_SIZE>
		<TEXTURE_ALPHA_SIZE public="1" static="1"><c path="Int"/></TEXTURE_ALPHA_SIZE>
		<TEXTURE_LUMINANCE_SIZE public="1" static="1"><c path="Int"/></TEXTURE_LUMINANCE_SIZE>
		<TEXTURE_INTENSITY_SIZE public="1" static="1"><c path="Int"/></TEXTURE_INTENSITY_SIZE>
		<NEAREST_MIPMAP_NEAREST public="1" static="1"><c path="Int"/></NEAREST_MIPMAP_NEAREST>
		<NEAREST_MIPMAP_LINEAR public="1" static="1"><c path="Int"/></NEAREST_MIPMAP_LINEAR>
		<LINEAR_MIPMAP_NEAREST public="1" static="1"><c path="Int"/></LINEAR_MIPMAP_NEAREST>
		<LINEAR_MIPMAP_LINEAR public="1" static="1"><c path="Int"/></LINEAR_MIPMAP_LINEAR>
		<OBJECT_LINEAR public="1" static="1"><c path="Int"/></OBJECT_LINEAR>
		<OBJECT_PLANE public="1" static="1"><c path="Int"/></OBJECT_PLANE>
		<EYE_LINEAR public="1" static="1"><c path="Int"/></EYE_LINEAR>
		<EYE_PLANE public="1" static="1"><c path="Int"/></EYE_PLANE>
		<SPHERE_MAP public="1" static="1"><c path="Int"/></SPHERE_MAP>
		<DECAL public="1" static="1"><c path="Int"/></DECAL>
		<MODULATE public="1" static="1"><c path="Int"/></MODULATE>
		<NEAREST public="1" static="1"><c path="Int"/></NEAREST>
		<REPEAT public="1" static="1"><c path="Int"/></REPEAT>
		<CLAMP public="1" static="1"><c path="Int"/></CLAMP>
		<S public="1" static="1"><c path="Int"/></S>
		<T public="1" static="1"><c path="Int"/></T>
		<R public="1" static="1"><c path="Int"/></R>
		<Q public="1" static="1"><c path="Int"/></Q>
		<TEXTURE_GEN_R public="1" static="1"><c path="Int"/></TEXTURE_GEN_R>
		<TEXTURE_GEN_Q public="1" static="1"><c path="Int"/></TEXTURE_GEN_Q>
		<VENDOR public="1" static="1"><c path="Int"/></VENDOR>
		<RENDERER public="1" static="1"><c path="Int"/></RENDERER>
		<VERSION public="1" static="1"><c path="Int"/></VERSION>
		<EXTENSIONS public="1" static="1"><c path="Int"/></EXTENSIONS>
		<NO_ERROR public="1" static="1"><c path="Int"/></NO_ERROR>
		<INVALID_VALUE public="1" static="1"><c path="Int"/></INVALID_VALUE>
		<INVALID_ENUM public="1" static="1"><c path="Int"/></INVALID_ENUM>
		<INVALID_OPERATION public="1" static="1"><c path="Int"/></INVALID_OPERATION>
		<STACK_OVERFLOW public="1" static="1"><c path="Int"/></STACK_OVERFLOW>
		<STACK_UNDERFLOW public="1" static="1"><c path="Int"/></STACK_UNDERFLOW>
		<OUT_OF_MEMORY public="1" static="1"><c path="Int"/></OUT_OF_MEMORY>
		<CURRENT_BIT public="1" static="1"><c path="Int"/></CURRENT_BIT>
		<POINT_BIT public="1" static="1"><c path="Int"/></POINT_BIT>
		<LINE_BIT public="1" static="1"><c path="Int"/></LINE_BIT>
		<POLYGON_BIT public="1" static="1"><c path="Int"/></POLYGON_BIT>
		<POLYGON_STIPPLE_BIT public="1" static="1"><c path="Int"/></POLYGON_STIPPLE_BIT>
		<PIXEL_MODE_BIT public="1" static="1"><c path="Int"/></PIXEL_MODE_BIT>
		<LIGHTING_BIT public="1" static="1"><c path="Int"/></LIGHTING_BIT>
		<FOG_BIT public="1" static="1"><c path="Int"/></FOG_BIT>
		<DEPTH_BUFFER_BIT public="1" static="1"><c path="Int"/></DEPTH_BUFFER_BIT>
		<ACCUM_BUFFER_BIT public="1" static="1"><c path="Int"/></ACCUM_BUFFER_BIT>
		<STENCIL_BUFFER_BIT public="1" static="1"><c path="Int"/></STENCIL_BUFFER_BIT>
		<VIEWPORT_BIT public="1" static="1"><c path="Int"/></VIEWPORT_BIT>
		<TRANSFORM_BIT public="1" static="1"><c path="Int"/></TRANSFORM_BIT>
		<ENABLE_BIT public="1" static="1"><c path="Int"/></ENABLE_BIT>
		<COLOR_BUFFER_BIT public="1" static="1"><c path="Int"/></COLOR_BUFFER_BIT>
		<HINT_BIT public="1" static="1"><c path="Int"/></HINT_BIT>
		<EVAL_BIT public="1" static="1"><c path="Int"/></EVAL_BIT>
		<LIST_BIT public="1" static="1"><c path="Int"/></LIST_BIT>
		<TEXTURE_BIT public="1" static="1"><c path="Int"/></TEXTURE_BIT>
		<SCISSOR_BIT public="1" static="1"><c path="Int"/></SCISSOR_BIT>
		<ALL_ATTRIB_BITS public="1" static="1"><c path="Int"/></ALL_ATTRIB_BITS>
		<PROXY_TEXTURE_1D public="1" static="1"><c path="Int"/></PROXY_TEXTURE_1D>
		<PROXY_TEXTURE_2D public="1" static="1"><c path="Int"/></PROXY_TEXTURE_2D>
		<TEXTURE_PRIORITY public="1" static="1"><c path="Int"/></TEXTURE_PRIORITY>
		<TEXTURE_RESIDENT public="1" static="1"><c path="Int"/></TEXTURE_RESIDENT>
		<TEXTURE_BINDING_1D public="1" static="1"><c path="Int"/></TEXTURE_BINDING_1D>
		<TEXTURE_BINDING_2D public="1" static="1"><c path="Int"/></TEXTURE_BINDING_2D>
		<TEXTURE_INTERNAL_FORMAT public="1" static="1"><c path="Int"/></TEXTURE_INTERNAL_FORMAT>
		<ALPHA4 public="1" static="1"><c path="Int"/></ALPHA4>
		<ALPHA8 public="1" static="1"><c path="Int"/></ALPHA8>
		<ALPHA12 public="1" static="1"><c path="Int"/></ALPHA12>
		<ALPHA16 public="1" static="1"><c path="Int"/></ALPHA16>
		<LUMINANCE4 public="1" static="1"><c path="Int"/></LUMINANCE4>
		<LUMINANCE8 public="1" static="1"><c path="Int"/></LUMINANCE8>
		<LUMINANCE12 public="1" static="1"><c path="Int"/></LUMINANCE12>
		<LUMINANCE16 public="1" static="1"><c path="Int"/></LUMINANCE16>
		<LUMINANCE4_ALPHA4 public="1" static="1"><c path="Int"/></LUMINANCE4_ALPHA4>
		<LUMINANCE6_ALPHA2 public="1" static="1"><c path="Int"/></LUMINANCE6_ALPHA2>
		<LUMINANCE8_ALPHA8 public="1" static="1"><c path="Int"/></LUMINANCE8_ALPHA8>
		<LUMINANCE12_ALPHA4 public="1" static="1"><c path="Int"/></LUMINANCE12_ALPHA4>
		<LUMINANCE12_ALPHA12 public="1" static="1"><c path="Int"/></LUMINANCE12_ALPHA12>
		<LUMINANCE16_ALPHA16 public="1" static="1"><c path="Int"/></LUMINANCE16_ALPHA16>
		<INTENSITY public="1" static="1"><c path="Int"/></INTENSITY>
		<INTENSITY4 public="1" static="1"><c path="Int"/></INTENSITY4>
		<INTENSITY8 public="1" static="1"><c path="Int"/></INTENSITY8>
		<INTENSITY12 public="1" static="1"><c path="Int"/></INTENSITY12>
		<INTENSITY16 public="1" static="1"><c path="Int"/></INTENSITY16>
		<R3_G3_B2 public="1" static="1"><c path="Int"/></R3_G3_B2>
		<RGB4 public="1" static="1"><c path="Int"/></RGB4>
		<RGB5 public="1" static="1"><c path="Int"/></RGB5>
		<RGB8 public="1" static="1"><c path="Int"/></RGB8>
		<RGB10 public="1" static="1"><c path="Int"/></RGB10>
		<RGB12 public="1" static="1"><c path="Int"/></RGB12>
		<RGB16 public="1" static="1"><c path="Int"/></RGB16>
		<RGBA2 public="1" static="1"><c path="Int"/></RGBA2>
		<RGBA4 public="1" static="1"><c path="Int"/></RGBA4>
		<RGB5_A1 public="1" static="1"><c path="Int"/></RGB5_A1>
		<RGBA8 public="1" static="1"><c path="Int"/></RGBA8>
		<RGB10_A2 public="1" static="1"><c path="Int"/></RGB10_A2>
		<RGBA12 public="1" static="1"><c path="Int"/></RGBA12>
		<RGBA16 public="1" static="1"><c path="Int"/></RGBA16>
		<CLIENT_PIXEL_STORE_BIT public="1" static="1"><c path="Int"/></CLIENT_PIXEL_STORE_BIT>
		<CLIENT_VERTEX_ARRAY_BIT public="1" static="1"><c path="Int"/></CLIENT_VERTEX_ARRAY_BIT>
		<clearIndex public="1" static="1"><f a="c">
	<c path="Float"/>
	<e path="Void"/>
</f></clearIndex>
		<clearColor public="1" static="1"><f a="red:green:blue:alpha">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></clearColor>
		<clear public="1" static="1"><f a="mask">
	<c path="Int"/>
	<e path="Void"/>
</f></clear>
		<indexMask public="1" static="1"><f a="mask">
	<c path="Int"/>
	<e path="Void"/>
</f></indexMask>
		<colorMask public="1" static="1"><f a="red:green:blue:alpha">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></colorMask>
		<alphaFunc public="1" static="1"><f a="func:ref">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></alphaFunc>
		<blendFunc public="1" static="1"><f a="sfactor:dfactor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blendFunc>
		<logicOp public="1" static="1"><f a="opcode">
	<c path="Int"/>
	<e path="Void"/>
</f></logicOp>
		<cullFace public="1" static="1"><f a="mode">
	<c path="Int"/>
	<e path="Void"/>
</f></cullFace>
		<frontFace public="1" static="1"><f a="mode">
	<c path="Int"/>
	<e path="Void"/>
</f></frontFace>
		<pointSize public="1" static="1"><f a="size">
	<c path="Float"/>
	<e path="Void"/>
</f></pointSize>
		<lineWidth public="1" static="1"><f a="width">
	<c path="Float"/>
	<e path="Void"/>
</f></lineWidth>
		<lineStipple public="1" static="1"><f a="factor:pattern">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></lineStipple>
		<polygonMode public="1" static="1"><f a="face:mode">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></polygonMode>
		<polygonOffset public="1" static="1"><f a="factor:units">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></polygonOffset>
		<polygonStipple public="1" static="1">
			<f a="mask">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="mask" type="unsigned char" min-size="(32*32)"/></nekobind> ]]></haxe_doc>
		</polygonStipple>
		<getPolygonStipple public="1" static="1">
			<f a="mask">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="mask" type="unsigned char" min-size="(32*32)"/></nekobind> ]]></haxe_doc>
		</getPolygonStipple>
		<edgeFlag public="1" static="1"><f a="flag">
	<c path="Int"/>
	<e path="Void"/>
</f></edgeFlag>
		<scissor public="1" static="1"><f a="x:y:width:height">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scissor>
		<clipPlane public="1" static="1">
			<f a="plane:equation">
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="equation" type="double" min-size="4"/></nekobind> ]]></haxe_doc>
		</clipPlane>
		<getClipPlane public="1" static="1">
			<f a="plane:equation">
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="equation" type="double" min-size="4"/></nekobind> ]]></haxe_doc>
		</getClipPlane>
		<drawBuffer public="1" static="1"><f a="mode">
	<c path="Int"/>
	<e path="Void"/>
</f></drawBuffer>
		<readBuffer public="1" static="1"><f a="mode">
	<c path="Int"/>
	<e path="Void"/>
</f></readBuffer>
		<enable public="1" static="1"><f a="cap">
	<c path="Int"/>
	<e path="Void"/>
</f></enable>
		<disable public="1" static="1"><f a="cap">
	<c path="Int"/>
	<e path="Void"/>
</f></disable>
		<isEnabled public="1" static="1"><f a="cap">
	<c path="Int"/>
	<c path="Int"/>
</f></isEnabled>
		<enableClientState public="1" static="1"><f a="cap">
	<c path="Int"/>
	<e path="Void"/>
</f></enableClientState>
		<disableClientState public="1" static="1"><f a="cap">
	<c path="Int"/>
	<e path="Void"/>
</f></disableClientState>
		<pushAttrib public="1" static="1"><f a="mask">
	<c path="Int"/>
	<e path="Void"/>
</f></pushAttrib>
		<popAttrib public="1" static="1"><f a=""><e path="Void"/></f></popAttrib>
		<pushClientAttrib public="1" static="1"><f a="mask">
	<c path="Int"/>
	<e path="Void"/>
</f></pushClientAttrib>
		<popClientAttrib public="1" static="1"><f a=""><e path="Void"/></f></popClientAttrib>
		<renderMode public="1" static="1"><f a="mode">
	<c path="Int"/>
	<c path="Int"/>
</f></renderMode>
		<getError public="1" static="1"><f a=""><c path="Int"/></f></getError>
		<getString public="1" static="1"><f a="name">
	<c path="Int"/>
	<c path="String"/>
</f></getString>
		<finish public="1" static="1"><f a=""><e path="Void"/></f></finish>
		<flush public="1" static="1"><f a=""><e path="Void"/></f></flush>
		<hint public="1" static="1"><f a="target:mode">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></hint>
		<clearDepth public="1" static="1"><f a="depth">
	<c path="Float"/>
	<e path="Void"/>
</f></clearDepth>
		<depthFunc public="1" static="1"><f a="func">
	<c path="Int"/>
	<e path="Void"/>
</f></depthFunc>
		<depthMask public="1" static="1"><f a="flag">
	<c path="Int"/>
	<e path="Void"/>
</f></depthMask>
		<depthRange public="1" static="1"><f a="near_val:far_val">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></depthRange>
		<clearAccum public="1" static="1"><f a="red:green:blue:alpha">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></clearAccum>
		<accum public="1" static="1"><f a="op:value">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></accum>
		<matrixMode public="1" static="1"><f a="mode">
	<c path="Int"/>
	<e path="Void"/>
</f></matrixMode>
		<ortho public="1" static="1"><f a="left:right:bottom:top:near_val:far_val">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></ortho>
		<frustum public="1" static="1"><f a="left:right:bottom:top:near_val:far_val">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></frustum>
		<viewport public="1" static="1"><f a="x:y:width:height">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></viewport>
		<pushMatrix public="1" static="1"><f a=""><e path="Void"/></f></pushMatrix>
		<popMatrix public="1" static="1"><f a=""><e path="Void"/></f></popMatrix>
		<loadIdentity public="1" static="1"><f a=""><e path="Void"/></f></loadIdentity>
		<rotate public="1" static="1">
			<f a="angle:x:y:z">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</rotate>
		<scale public="1" static="1">
			<f a="x:y:z">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</scale>
		<translate public="1" static="1">
			<f a="x:y:z">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</translate>
		<isList public="1" static="1"><f a="list">
	<c path="Int"/>
	<c path="Int"/>
</f></isList>
		<deleteLists public="1" static="1"><f a="list:range">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></deleteLists>
		<genLists public="1" static="1"><f a="range">
	<c path="Int"/>
	<c path="Int"/>
</f></genLists>
		<newList public="1" static="1"><f a="list:mode">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></newList>
		<endList public="1" static="1"><f a=""><e path="Void"/></f></endList>
		<callList public="1" static="1"><f a="list">
	<c path="Int"/>
	<e path="Void"/>
</f></callList>
		<listBase public="1" static="1"><f a="base">
	<c path="Int"/>
	<e path="Void"/>
</f></listBase>
		<begin public="1" static="1"><f a="mode">
	<c path="Int"/>
	<e path="Void"/>
</f></begin>
		<end public="1" static="1"><f a=""><e path="Void"/></f></end>
		<vertex2 public="1" static="1">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</vertex2>
		<vertex3 public="1" static="1">
			<f a="x:y:z">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</vertex3>
		<vertex4 public="1" static="1">
			<f a="x:y:z:w">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</vertex4>
		<normal3 public="1" static="1">
			<f a="nx:ny:nz">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</normal3>
		<index public="1" static="1">
			<f a="c">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</index>
		<color3 public="1" static="1">
			<f a="red:green:blue">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</color3>
		<color4 public="1" static="1">
			<f a="red:green:blue:alpha">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</color4>
		<texCoord1 public="1" static="1">
			<f a="s">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</texCoord1>
		<texCoord2 public="1" static="1">
			<f a="s:t">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</texCoord2>
		<texCoord3 public="1" static="1">
			<f a="s:t:r">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</texCoord3>
		<texCoord4 public="1" static="1">
			<f a="s:t:r:q">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</texCoord4>
		<rasterPos2 public="1" static="1">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</rasterPos2>
		<rasterPos3 public="1" static="1">
			<f a="x:y:z">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</rasterPos3>
		<rasterPos4 public="1" static="1">
			<f a="x:y:z:w">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</rasterPos4>
		<rect public="1" static="1">
			<f a="x1:y1:x2:y2">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</rect>
		<loadMatrixf public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="16"/></nekobind> ]]></haxe_doc>
		</loadMatrixf>
		<loadMatrixd public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="16"/></nekobind> ]]></haxe_doc>
		</loadMatrixd>
		<multMatrixf public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="16"/></nekobind> ]]></haxe_doc>
		</multMatrixf>
		<multMatrixd public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="16"/></nekobind> ]]></haxe_doc>
		</multMatrixd>
		<vertex2fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="2"/></nekobind> ]]></haxe_doc>
		</vertex2fv>
		<vertex3fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="3"/></nekobind> ]]></haxe_doc>
		</vertex3fv>
		<vertex4fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="4"/></nekobind> ]]></haxe_doc>
		</vertex4fv>
		<normal3fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="3"/></nekobind> ]]></haxe_doc>
		</normal3fv>
		<indexfv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="1"/></nekobind> ]]></haxe_doc>
		</indexfv>
		<color3fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="3"/></nekobind> ]]></haxe_doc>
		</color3fv>
		<color4fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="4"/></nekobind> ]]></haxe_doc>
		</color4fv>
		<texCoord1fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="1"/></nekobind> ]]></haxe_doc>
		</texCoord1fv>
		<texCoord2fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="2"/></nekobind> ]]></haxe_doc>
		</texCoord2fv>
		<texCoord3fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="3"/></nekobind> ]]></haxe_doc>
		</texCoord3fv>
		<texCoord4fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="4"/></nekobind> ]]></haxe_doc>
		</texCoord4fv>
		<rasterPos2fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="2"/></nekobind> ]]></haxe_doc>
		</rasterPos2fv>
		<rasterPos3fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="3"/></nekobind> ]]></haxe_doc>
		</rasterPos3fv>
		<rasterPos4fv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="float" min-size="4"/></nekobind> ]]></haxe_doc>
		</rasterPos4fv>
		<rectfv public="1" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v1" type="float" min-size="2"/>
			<cptr name="v2" type="float" min-size="2"/></nekobind> ]]></haxe_doc>
		</rectfv>
		<vertex2dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="2"/></nekobind> ]]></haxe_doc>
		</vertex2dv>
		<vertex3dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="3"/></nekobind> ]]></haxe_doc>
		</vertex3dv>
		<vertex4dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="4"/></nekobind> ]]></haxe_doc>
		</vertex4dv>
		<normal3dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="3"/></nekobind> ]]></haxe_doc>
		</normal3dv>
		<indexdv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="1"/></nekobind> ]]></haxe_doc>
		</indexdv>
		<color3dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="3"/></nekobind> ]]></haxe_doc>
		</color3dv>
		<color4dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="4"/></nekobind> ]]></haxe_doc>
		</color4dv>
		<texCoord1dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="1"/></nekobind> ]]></haxe_doc>
		</texCoord1dv>
		<texCoord2dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="2"/></nekobind> ]]></haxe_doc>
		</texCoord2dv>
		<texCoord3dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="3"/></nekobind> ]]></haxe_doc>
		</texCoord3dv>
		<texCoord4dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="4"/></nekobind> ]]></haxe_doc>
		</texCoord4dv>
		<rasterPos2dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="2"/></nekobind> ]]></haxe_doc>
		</rasterPos2dv>
		<rasterPos3dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="3"/></nekobind> ]]></haxe_doc>
		</rasterPos3dv>
		<rasterPos4dv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="double" min-size="4"/></nekobind> ]]></haxe_doc>
		</rasterPos4dv>
		<rectdv public="1" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v1" type="double" min-size="2"/>
			<cptr name="v2" type="double" min-size="2"/></nekobind> ]]></haxe_doc>
		</rectdv>
		<vertex2sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="2"/></nekobind> ]]></haxe_doc>
		</vertex2sv>
		<vertex3sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="3"/></nekobind> ]]></haxe_doc>
		</vertex3sv>
		<vertex4sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="4"/></nekobind> ]]></haxe_doc>
		</vertex4sv>
		<normal3sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="3"/></nekobind> ]]></haxe_doc>
		</normal3sv>
		<indexsv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="1"/></nekobind> ]]></haxe_doc>
		</indexsv>
		<color3sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="3"/></nekobind> ]]></haxe_doc>
		</color3sv>
		<color4sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="4"/></nekobind> ]]></haxe_doc>
		</color4sv>
		<texCoord1sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="1"/></nekobind> ]]></haxe_doc>
		</texCoord1sv>
		<texCoord2sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="2"/></nekobind> ]]></haxe_doc>
		</texCoord2sv>
		<texCoord3sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="3"/></nekobind> ]]></haxe_doc>
		</texCoord3sv>
		<texCoord4sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="4"/></nekobind> ]]></haxe_doc>
		</texCoord4sv>
		<rasterPos2sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="2"/></nekobind> ]]></haxe_doc>
		</rasterPos2sv>
		<rasterPos3sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="3"/></nekobind> ]]></haxe_doc>
		</rasterPos3sv>
		<rasterPos4sv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="short" min-size="4"/></nekobind> ]]></haxe_doc>
		</rasterPos4sv>
		<rectsv public="1" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v1" type="short" min-size="2"/>
			<cptr name="v2" type="short" min-size="2"/></nekobind> ]]></haxe_doc>
		</rectsv>
		<vertex2iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="2"/></nekobind> ]]></haxe_doc>
		</vertex2iv>
		<vertex3iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="3"/></nekobind> ]]></haxe_doc>
		</vertex3iv>
		<vertex4iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="4"/></nekobind> ]]></haxe_doc>
		</vertex4iv>
		<normal3iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="3"/></nekobind> ]]></haxe_doc>
		</normal3iv>
		<indexiv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="1"/></nekobind> ]]></haxe_doc>
		</indexiv>
		<color3iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="3"/></nekobind> ]]></haxe_doc>
		</color3iv>
		<color4iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="4"/></nekobind> ]]></haxe_doc>
		</color4iv>
		<texCoord1iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="1"/></nekobind> ]]></haxe_doc>
		</texCoord1iv>
		<texCoord2iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="2"/></nekobind> ]]></haxe_doc>
		</texCoord2iv>
		<texCoord3iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="3"/></nekobind> ]]></haxe_doc>
		</texCoord3iv>
		<texCoord4iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="4"/></nekobind> ]]></haxe_doc>
		</texCoord4iv>
		<rasterPos2iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="2"/></nekobind> ]]></haxe_doc>
		</rasterPos2iv>
		<rasterPos3iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="3"/></nekobind> ]]></haxe_doc>
		</rasterPos3iv>
		<rasterPos4iv public="1" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v" type="GLint" min-size="4"/></nekobind> ]]></haxe_doc>
		</rasterPos4iv>
		<rectiv public="1" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="v1" type="GLint" min-size="2"/>
			<cptr name="v2" type="GLint" min-size="2"/></nekobind> ]]></haxe_doc>
		</rectiv>
		<vertexPointer public="1" static="1">
			<f a="size:type:stride:ptr">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="ptr" type="GLfloat" min-size="(stride*type)"/></nekobind> ]]></haxe_doc>
		</vertexPointer>
		<drawElements public="1" static="1"><f a="mode:count:type:indices">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<d/>
	<e path="Void"/>
</f></drawElements>
		<arrayElement public="1" static="1"><f a="i">
	<c path="Int"/>
	<e path="Void"/>
</f></arrayElement>
		<drawArrays public="1" static="1"><f a="mode:first:count">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawArrays>
		<shadeModel public="1" static="1"><f a="mode">
	<c path="Int"/>
	<e path="Void"/>
</f></shadeModel>
		<light public="1" static="1">
			<f a="light:pname:param">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="f"/> ]]></haxe_doc>
		</light>
		<lightModel public="1" static="1">
			<f a="pname:param">
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="f"/> ]]></haxe_doc>
		</lightModel>
		<material public="1" static="1">
			<f a="face:pname:param">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="f"/> ]]></haxe_doc>
		</material>
		<colorMaterial public="1" static="1"><f a="face:mode">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></colorMaterial>
		<pixelZoom public="1" static="1"><f a="xfactor:yfactor">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></pixelZoom>
		<pixelStore public="1" static="1">
			<f a="pname:param">
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="f"/> ]]></haxe_doc>
		</pixelStore>
		<pixelTransfer public="1" static="1">
			<f a="pname:param">
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="f"/> ]]></haxe_doc>
		</pixelTransfer>
		<stencilFunc public="1" static="1"><f a="func:ref:mask">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></stencilFunc>
		<stencilMask public="1" static="1"><f a="mask">
	<c path="Int"/>
	<e path="Void"/>
</f></stencilMask>
		<stencilOp public="1" static="1"><f a="fail:zfail:zpass">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></stencilOp>
		<clearStencil public="1" static="1"><f a="s">
	<c path="Int"/>
	<e path="Void"/>
</f></clearStencil>
		<texGen public="1" static="1">
			<f a="coord:pname:param">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="f"/> ]]></haxe_doc>
		</texGen>
		<texEnv public="1" static="1">
			<f a="target:pname:param">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="f"/> ]]></haxe_doc>
		</texEnv>
		<texParameter public="1" static="1">
			<f a="target:pname:param">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="f"/> ]]></haxe_doc>
		</texParameter>
		<texImage2D public="1" static="1">
			<f a="target:level:internalFormat:width:height:border:format:type:pixels">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="pixels" type="GLvoid" null-allowed="true"/></nekobind> ]]></haxe_doc>
		</texImage2D>
		<genTextures public="1" static="1">
			<f a="n:textures">
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="textures" type="GLuint" min-size="n"/></nekobind> ]]></haxe_doc>
		</genTextures>
		<bindTexture public="1" static="1"><f a="target:texture">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></bindTexture>
		<isTexture public="1" static="1"><f a="texture">
	<c path="Int"/>
	<c path="Int"/>
</f></isTexture>
		<texSubImageRGBA public="1" static="1">
			<f a="target:x:y:width:height:pixels">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="pixels" type="unsigned char" min-size="(width*height*4)"/></nekobind> ]]></haxe_doc>
		</texSubImageRGBA>
		<texSubImageBGRA public="1" static="1">
			<f a="target:x:y:width:height:pixels">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="pixels" type="unsigned char" min-size="(width*height*4)"/></nekobind> ]]></haxe_doc>
		</texSubImageBGRA>
		<texSubImageRGB public="1" static="1">
			<f a="target:x:y:width:height:pixels">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="pixels" type="unsigned char" min-size="(width*height*3)"/></nekobind> ]]></haxe_doc>
		</texSubImageRGB>
		<texSubImageBGR public="1" static="1">
			<f a="target:x:y:width:height:pixels">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="pixels" type="unsigned char" min-size="(width*height*3)"/></nekobind> ]]></haxe_doc>
		</texSubImageBGR>
		<texSubImageGRAY public="1" static="1">
			<f a="target:x:y:width:height:pixels">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="pixels" type="unsigned char" min-size="(width*height)"/></nekobind> ]]></haxe_doc>
		</texSubImageGRAY>
		<texSubImageALPHA public="1" static="1">
			<f a="target:x:y:width:height:pixels">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="pixels" type="unsigned char" min-size="(width*height)"/></nekobind> ]]></haxe_doc>
		</texSubImageALPHA>
		<texImageClearFT public="1" static="1">
			<f a="target:width:height">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="pixels" type="unsigned char" min-size="(width*height)"/></nekobind> ]]></haxe_doc>
		</texImageClearFT>
		<texSubImageFT public="1" static="1">
			<f a="target:x:y:width:height:pixels">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="pixels" type="unsigned char" min-size="(width*height)"/></nekobind> ]]></haxe_doc>
		</texSubImageFT>
		<evalCoord1 public="1" static="1">
			<f a="u">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</evalCoord1>
		<evalCoord2 public="1" static="1">
			<f a="u:v">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</evalCoord2>
		<evalCoord1dv public="1" static="1">
			<f a="u">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="u" type="double" min-size="1"/></nekobind> ]]></haxe_doc>
		</evalCoord1dv>
		<evalCoord2dv public="1" static="1">
			<f a="u">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="u" type="double" min-size="2"/></nekobind> ]]></haxe_doc>
		</evalCoord2dv>
		<mapGrid1 public="1" static="1">
			<f a="un:u1:u2">
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</mapGrid1>
		<mapGrid2 public="1" static="1">
			<f a="un:u1:u2:vn:v1:v2">
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="d"/> ]]></haxe_doc>
		</mapGrid2>
		<evalPoint1 public="1" static="1"><f a="i">
	<c path="Int"/>
	<e path="Void"/>
</f></evalPoint1>
		<evalPoint2 public="1" static="1"><f a="i:j">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></evalPoint2>
		<evalMesh1 public="1" static="1"><f a="mode:i1:i2">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></evalMesh1>
		<evalMesh2 public="1" static="1"><f a="mode:i1:i2:j1:j2">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></evalMesh2>
		<fog public="1" static="1">
			<f a="pname:param">
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="f"/> ]]></haxe_doc>
		</fog>
		<feedbackBuffer public="1" static="1">
			<f a="size:type:buffer">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="buffer" type="float" min-size="size"/></nekobind> ]]></haxe_doc>
		</feedbackBuffer>
		<passThrough public="1" static="1"><f a="token">
	<c path="Float"/>
	<e path="Void"/>
</f></passThrough>
		<selectBuffer public="1" static="1">
			<f a="size:buffer">
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="buffer" type="GLuint" min-size="size"/></nekobind> ]]></haxe_doc>
		</selectBuffer>
		<initNames public="1" static="1"><f a=""><e path="Void"/></f></initNames>
		<loadName public="1" static="1"><f a="name">
	<c path="Int"/>
	<e path="Void"/>
</f></loadName>
		<pushName public="1" static="1"><f a="name">
	<c path="Int"/>
	<e path="Void"/>
</f></pushName>
		<popName public="1" static="1"><f a=""><e path="Void"/></f></popName>
		<MULTISAMPLE public="1" static="1"><c path="Int"/></MULTISAMPLE>
		<BGR public="1" static="1"><c path="Int"/></BGR>
		<BGRA public="1" static="1"><c path="Int"/></BGRA>
		<haxe_doc><![CDATA[
	Global OpenGL functions. 
	Make sure you create (and makeCurrent) a Display before using any of these.
	
	<nekobind 
		prefix="gl"
		module="opengl"
		global="true"
		translator="Capitalize"
		globalFinderPrefix="GL_"
		globalFinderCCFlags="-lGL"
		/>
	<nekobind:cHeader>
	#ifdef NEKO_OSX
		#include &lt;OpenGL/gl.h&gt;
	#else
		#include &lt;GL/glew.h&gt;
		#include &lt;GL/gl.h&gt;
	#endif
	</nekobind:cHeader>
]]></haxe_doc>
	</class>
	<class path="xinf.event.SimpleEvent" params="" file="../../../xinf/src/xinf/event/SimpleEvent.hx">
		<extends path="xinf.event.Event"><c path="xinf.event.SimpleEvent"/></extends>
		<QUIT public="1" line="12" static="1">
			<c path="xinf.event.EventKind"><c path="xinf.event.SimpleEvent"/></c>
			<haxe_doc> quit application </haxe_doc>
		</QUIT>
		<CHANGED public="1" line="15" static="1">
			<c path="xinf.event.EventKind"><c path="xinf.event.SimpleEvent"/></c>
			<haxe_doc> something has changed </haxe_doc>
		</CHANGED>
		<new public="1" line="17"><f a="_type">
	<c path="xinf.event.EventKind"><c path="xinf.event.SimpleEvent"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	SimpleEvent is an Event that carries no further data.
</haxe_doc>
	</class>
	<typedef path="ButtonData" params="" file="../src-multicore/StopWatch.hx" module="StopWatch"><a>
	<groupId><c path="String"/></groupId>
	<coverId><c path="String"/></coverId>
	<action><f a=""><e path="Void"/></f></action>
</a></typedef>
	<typedef path="WatchData" params="" file="../src-multicore/StopWatch.hx" module="StopWatch"><a>
	<watch><c path="Watch"/></watch>
	<doc><d/></doc>
	<buttons><c path="Hash"><c path="Button"/></c></buttons>
</a></typedef>
	<class path="StopWatch" params="" file="../src-multicore/StopWatch.hx">
		<extends path="xinf.event.SimpleEventDispatcher"/>
		<NAME public="1" line="23" static="1"><c path="String"/></NAME>
		<ACTION_STOP public="1" line="26" static="1"><c path="String"/></ACTION_STOP>
		<ACTION_START public="1" line="27" static="1"><c path="String"/></ACTION_START>
		<ACTION_RESET public="1" line="28" static="1"><c path="String"/></ACTION_RESET>
		<ACTION_SPLIT public="1" line="29" static="1"><c path="String"/></ACTION_SPLIT>
		<ACTION_UNSPLIT public="1" line="30" static="1"><c path="String"/></ACTION_UNSPLIT>
		<STATE_READY public="1" line="33" static="1"><c path="String"/></STATE_READY>
		<STATE_RUNNING public="1" line="34" static="1"><c path="String"/></STATE_RUNNING>
		<STATE_PAUSED public="1" line="35" static="1"><c path="String"/></STATE_PAUSED>
		<STATE_STOPPED public="1" line="36" static="1"><c path="String"/></STATE_STOPPED>
		<main line="163" static="1"><f a=""><e path="Void"/></f></main>
		<laptime public="1" set="setLaptime"><t path="TWatchTime"/></laptime>
		<elapsed public="1" set="setElapsed"><t path="TWatchTime"/></elapsed>
		<state public="1" set="setState"><c path="String"/></state>
		<buttonData><c path="Array"><t path="ButtonData"/></c></buttonData>
		<timeWatch><t path="WatchData"/></timeWatch>
		<laptimeWatch><t path="WatchData"/></laptimeWatch>
		<setLaptime line="46"><f a="hms">
	<t path="TWatchTime"/>
	<t path="TWatchTime"/>
</f></setLaptime>
		<setElapsed line="57"><f a="hms">
	<t path="TWatchTime"/>
	<t path="TWatchTime"/>
</f></setElapsed>
		<setState line="63"><f a="state">
	<c path="String"/>
	<c path="String"/>
</f></setState>
		<getButtons line="121"><f a="doc">
	<d/>
	<c path="Hash"><c path="Button"/></c>
</f></getButtons>
		<showButtons line="128"><f a="doc:b">
	<d/>
	<e path="Bool"/>
	<e path="Void"/>
</f></showButtons>
		<onLoad1 line="136"><f a="data">
	<t path="Svg"/>
	<e path="Void"/>
</f></onLoad1>
		<onLoad2 line="142"><f a="data">
	<t path="Svg"/>
	<e path="Void"/>
</f></onLoad2>
		<onError line="153"><f a="e">
	<c path="String"/>
	<e path="Void"/>
</f></onError>
		<onStop line="157"><f a=""><e path="Void"/></f></onStop>
		<onStart line="158"><f a=""><e path="Void"/></f></onStart>
		<onReset line="159"><f a=""><e path="Void"/></f></onReset>
		<onSplit line="160"><f a=""><e path="Void"/></f></onSplit>
		<onUnsplit line="161"><f a=""><e path="Void"/></f></onUnsplit>
		<new public="1" line="73"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="TWatchTime" params="" file="../src-multicore/StopWatch.hx" module="StopWatch"><a>
	<s><c path="Int"/></s>
	<m><c path="Int"/></m>
	<h><c path="Int"/></h>
</a></typedef>
	<class path="Watch" params="" file="../src-multicore/StopWatch.hx" module="StopWatch">
		<doc><d/></doc>
		<watchId><c path="String"/></watchId>
		<hourId><c path="String"/></hourId>
		<minId><c path="String"/></minId>
		<secId><c path="String"/></secId>
		<time public="1" set="setTime"><t path="TWatchTime"/></time>
		<show public="1" set="setShow"><e path="Bool"/></show>
		<setTime line="198"><f a="t">
	<t path="TWatchTime"/>
	<t path="TWatchTime"/>
</f></setTime>
		<setShow line="213"><f a="s">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setShow>
		<new public="1" line="190"><f a="doc:watchId:hourId:minId:secId">
	<d/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Button" params="" file="../src-multicore/StopWatch.hx" module="StopWatch">
		<doc><d/></doc>
		<groupId><c path="String"/></groupId>
		<coverId><c path="String"/></coverId>
		<action><f a=""><e path="Void"/></f></action>
		<enabled public="1" set="setEnabled"><e path="Bool"/></enabled>
		<setHandler line="243"><f a=""><e path="Void"/></f></setHandler>
		<setEnabled line="251"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEnabled>
		<onClick line="261"><f a="e">
	<d/>
	<e path="Void"/>
</f></onClick>
		<new public="1" line="234"><f a="doc:groupId:coverId:action:?enabled">
	<d/>
	<c path="String"/>
	<c path="String"/>
	<f a=""><e path="Void"/></f>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="StopWatchEvent" params="" file="../src-multicore/StopWatch.hx" module="StopWatch">
		<extends path="xinf.event.Event"><c path="StopWatchEvent"/></extends>
		<STOP public="1" line="270" static="1"><c path="xinf.event.EventKind"><c path="StopWatchEvent"/></c></STOP>
		<START public="1" line="271" static="1"><c path="xinf.event.EventKind"><c path="StopWatchEvent"/></c></START>
		<RESET public="1" line="272" static="1"><c path="xinf.event.EventKind"><c path="StopWatchEvent"/></c></RESET>
		<SPLIT public="1" line="273" static="1"><c path="xinf.event.EventKind"><c path="StopWatchEvent"/></c></SPLIT>
		<UNSPLIT public="1" line="274" static="1"><c path="xinf.event.EventKind"><c path="StopWatchEvent"/></c></UNSPLIT>
		<new public="1" line="276"><f a="_type">
	<c path="xinf.event.EventKind"><c path="StopWatchEvent"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.TextArea" params="" file="../../../xinf/src/xinf/ony/erno/TextArea.hx">
		<extends path="xinf.ony.TextArea"/>
		<contents><c path="Array"><e path="xinf.ony.erno.FlowElement"/></c></contents>
		<lines><c path="Array"><t path="xinf.ony.erno.TextLine"/></c></lines>
		<dirty><e path="Bool"/></dirty>
		<format><c path="xinf.erno.TextFormat"/></format>
		<assureFormat line="57"><f a=""><e path="Void"/></f></assureFormat>
		<updateContents line="67"><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></updateContents>
		<new public="1" line="45"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.EditableTextArea" params="" file="../../../xinf/src/xinf/ony/erno/EditableTextArea.hx">
		<extends path="xinf.ony.erno.TextArea"/>
		<sel><a>
	<to><c path="Int"/></to>
	<from><c path="Int"/></from>
</a></sel>
		<keyboardL><d/></keyboardL>
		<mouseL><d/></mouseL>
		<onKeyDown public="1" line="48"><f a="e">
	<c path="xinf.event.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyDown>
		<onMouseDown public="1" line="108"><f a="e">
	<c path="xinf.event.MouseEvent"/>
	<e path="Void"/>
</f></onMouseDown>
		<dragSelect line="130"><f a="e">
	<c path="xinf.event.MouseEvent"/>
	<e path="Void"/>
</f></dragSelect>
		<selectAll public="1" line="138"><f a=""><e path="Void"/></f></selectAll>
		<moveCursor public="1" line="143"><f a="to:extendSelection">
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></moveCursor>
		<replaceSelection public="1" line="152"><f a="str">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelection>
		<findLeftWordBoundary public="1" line="173"><f a=""><c path="Int"/></f></findLeftWordBoundary>
		<findRightWordBoundary public="1" line="183"><f a=""><c path="Int"/></f></findRightWordBoundary>
		<getPositionOfText line="192"><f a="pos">
	<c path="Int"/>
	<t path="xinf.geom.TPoint"/>
</f></getPositionOfText>
		<getTextPositionAt line="212"><f a="pos">
	<t path="xinf.geom.TPoint"/>
	<c path="Int"/>
</f></getTextPositionAt>
		<new public="1" line="28"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.xml.Binding" params="" file="../../../xinf/src/xinf/xml/Binding.hx">
		<implements path="xinf.xml.IBinding"/>
		<marshallers><c path="Hash"><c path="Class"><c path="xinf.xml.Node"/></c></c></marshallers>
		<instantiators><c path="Array"><c path="xinf.xml.Instantiator"><c path="xinf.xml.Node"/></c></c></instantiators>
		<add public="1" line="31">
			<f a="nodeName:cl">
				<c path="String"/>
				<c path="Class"><c path="xinf.xml.Node"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc> Bind the given [nodeName] (or tag name) to the class [cl].
		
		The class must have a constructor with only one, dynamic
		argument, like $xinf.xml.Element$, or instantiation will fail.
	</haxe_doc>
		</add>
		<addInstantiator public="1" line="37">
			<f a="i">
				<c path="xinf.xml.Instantiator"><c path="xinf.xml.Node"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc> Add the given Instantiator [i] to this Binding.
	</haxe_doc>
		</addInstantiator>
		<instantiate public="1" line="57">
			<f a="xml">
				<c path="Xml"/>
				<c path="xinf.xml.Node"/>
			</f>
			<haxe_doc> Instantiate (unmarshal/deserialize) the given [xml],
		and returns the instantiated Node.
	
		Looks through all added Instantiators first, then
		through the list of nodeNames, and tries to construct
		the Object. If nothing is bound to the given xml,
		[null] is returned. If instantiation fails (for example,
		because the bound class' constructor has less or more
		than one argument), an exception is thrown.
		
		The returned Node will yet be empty ([fromXml] is not
		yet called).
		
		You shouldn't use this function directly. Instead,
		use $xinf.xml.Document$.instantiate() or .load().
	</haxe_doc>
		</instantiate>
		<new public="1" line="21">
			<f a=""><e path="Void"/></f>
			<haxe_doc> Create a new, initially empty, Binding
	</haxe_doc>
		</new>
		<haxe_doc>
	Represents a Binding of XML content to instantiated $xinf.xml.Node$s.
	
	Node classes can be bound either by simple 
	TagName-to-Class association ([add()]) or more
	complex $xinf.xml.Instantiator$s ([addInstantiator()]).
	
	Used primarily (if not only) by the $xinf.xml.Document$ class.
</haxe_doc>
	</class>
	<enum path="xinf.inity.GLVGContent" params="" file="../../../xinf/src/xinf/inity/GLObject.hx" module="xinf.inity.GLObject">
		<CRectangle a="l:t:r:b:pad">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
		</CRectangle>
		<CPath a="p:fill:stroke">
			<c path="openvg.Path"/>
			<e path="Bool"/>
			<e path="Bool"/>
		</CPath>
	</enum>
	<class path="xinf.inity.GLObject" params="" file="../../../xinf/src/xinf/inity/GLObject.hx">
		<parent public="1"><c path="xinf.inity.GLObject"/></parent>
		<children public="1"><c path="Array"><c path="xinf.inity.GLObject"/></c></children>
		<boundingBox><c path="xinf.geom.Rectangle"/></boundingBox>
		<transform public="1"><c path="xinf.geom.Matrix"/></transform>
		<transformedBBox><c path="xinf.geom.Rectangle"/></transformedBBox>
		<id public="1"><c path="Int"/></id>
		<inner public="1"><c path="Int"/></inner>
		<contents public="1"><c path="List"><e path="xinf.inity.GLVGContent"/></c></contents>
		<destroy public="1" line="40"><f a=""><e path="Void"/></f></destroy>
		<setTransform public="1" line="45"><f a="transform">
	<c path="xinf.geom.Matrix"/>
	<e path="Void"/>
</f></setTransform>
		<redoTransform public="1" line="51"><f a=""><e path="Void"/></f></redoTransform>
		<localToGlobal public="1" line="77"><f a="p">
	<a>
		<y><c path="Float"/></y>
		<x><c path="Float"/></x>
	</a>
	<a>
		<y><c path="Float"/></y>
		<x><c path="Float"/></x>
	</a>
</f></localToGlobal>
		<addChild public="1" line="84"><f a="child">
	<c path="xinf.inity.GLObject"/>
	<e path="Void"/>
</f></addChild>
		<clear public="1" line="91"><f a=""><e path="Void"/></f></clear>
		<mergeBBox line="97"><f a="bbox">
	<t path="xinf.geom.TRectangle"/>
	<e path="Void"/>
</f></mergeBBox>
		<start public="1" line="103"><f a=""><e path="Void"/></f></start>
		<end public="1" line="107"><f a=""><e path="Void"/></f></end>
		<update public="1" line="119"><f a=""><e path="Void"/></f></update>
		<hit public="1" line="134"><f a="p:found">
	<t path="xinf.geom.TPoint"/>
	<c path="List"><a>
	<p><t path="xinf.geom.TPoint"/></p>
	<o><c path="xinf.inity.GLObject"/></o>
</a></c>
	<e path="Bool"/>
</f></hit>
		<addHitRectangle public="1" line="154"><f a="l:t:r:b:pad">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addHitRectangle>
		<addHitPath public="1" line="159"><f a="path:fill:stroke">
	<c path="openvg.Path"/>
	<e path="Bool"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addHitPath>
		<hitPrecise public="1" line="168"><f a="tp">
	<t path="xinf.geom.TPoint"/>
	<e path="Bool"/>
</f></hitPrecise>
		<toString public="1" line="180"><f a=""><c path="String"/></f></toString>
		<new public="1" line="32"><f a="id">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.xml.Document" params="" file="../../../xinf/src/xinf/xml/Document.hx">
		<extends path="xinf.xml.XMLElement"/>
		<instantiate public="1" params="T" line="137" static="1">
			<f a="data:?base:?parentDocument:?onLoad:?type">
				<c path="String"/>
				<c path="xinf.xml.URL"/>
				<c path="xinf.xml.Document"/>
				<f a="">
					<c path="instantiate.T"/>
					<e path="Void"/>
				</f>
				<c path="Class"><c path="instantiate.T"/></c>
				<c path="xinf.xml.Node"/>
			</f>
			<haxe_doc>
		Instantiate the XML given in [data], and returns the root node.
		
		If [base] is given, it will be set as the document base on the new Element.
		
		If [parentDocument] is given, all new Nodes will be associated to the given
		Document. If not, they will be associated to $xinf.ony.Root$'s Document.
		(This might change a little in the future.)
	</haxe_doc>
		</instantiate>
		<load public="1" params="T" line="161" static="1">
			<f a="url_s:?parentDocument:?onLoad:?onError:?type">
				<c path="String"/>
				<c path="xinf.xml.Document"/>
				<f a="">
					<c path="load.T"/>
					<e path="Void"/>
				</f>
				<f a="">
					<c path="String"/>
					<e path="Void"/>
				</f>
				<c path="Class"><c path="load.T"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Instantiate the XML found at the URL [url_s].
		
		If [onLoad] is given, it will be called with the instantiated root node
		once the document is fully loaded (and after the Element's onLoad function
		has been called).
	</haxe_doc>
		</load>
		<bindings static="1"><c path="Hash"><c path="xinf.xml.IBinding"/></c></bindings>
		<addBinding public="1" line="181" static="1">
			<f a="namespaceURI:binding">
				<c path="String"/>
				<c path="xinf.xml.IBinding"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add a new Binding to this Document.
		
		[namespaceURI] is currently disregarded, but you should pass in the
		proper namespace anyway, to be safe for a future where we support
		namespaces.
	</haxe_doc>
		</addBinding>
		<getBinding public="1" line="186" static="1"><f a="namespaceURI">
	<c path="String"/>
	<c path="xinf.xml.IBinding"/>
</f></getBinding>
		<addToBinding public="1" line="200" static="1">
			<f a="namespaceURI:nodeName:cl">
				<c path="String"/>
				<c path="String"/>
				<c path="Class"><c path="xinf.xml.Node"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Bind the given class cl to the binding for the given namespace.
		Create an empty binding if the namespace is yet unbound.
	</haxe_doc>
		</addToBinding>
		<documentElement public="1" set="null">
			<c path="xinf.xml.XMLElement"/>
			<haxe_doc> The root Element of this Document.
	</haxe_doc>
		</documentElement>
		<elementsById public="1" set="null">
			<c path="Hash"><c path="xinf.xml.XMLElement"/></c>
			<haxe_doc> The id index of this document.
	
		Don't do lookups direcly on this Hash,
		instead use getElementById().
	</haxe_doc>
		</elementsById>
		<styleSheet public="1" set="null">
			<c path="xinf.style.StyleSheet"/>
			<haxe_doc> The Document's StyleSheet.
	</haxe_doc>
		</styleSheet>
		<getElementById public="1" line="45">
			<f a="id">
				<c path="String"/>
				<c path="xinf.xml.XMLElement"/>
			</f>
			<haxe_doc> Return the Element with the specified [id].
	
		An exception will be thrown if no Node
		with the given [id] exists.
	</haxe_doc>
		</getElementById>
		<getTypedElementById public="1" params="T" line="58">
			<f a="id:type">
				<c path="String"/>
				<c path="Class"><c path="getTypedElementById.T"/></c>
				<c path="getTypedElementById.T"/>
			</f>
			<haxe_doc> Return the Element with the specified [id],
		typed to the given [type].
	
		An exception will be thrown if no Node
		with the given [id] exists, or the Node
		is not of the specified [type].
	</haxe_doc>
		</getTypedElementById>
		<getElementByURI public="1" line="74">
			<f a="uri">
				<c path="String"/>
				<c path="xinf.xml.XMLElement"/>
			</f>
			<haxe_doc> Return the Element referenced by [uri].
	
		Currently, this is only good for finding Elements
		by id (uri == "#id"), but in the future this might
		return Elements of external Documents, too.
		
		An exception will be thrown if [uri] references an
		Element in an external document, or the Element
		can not be found.
	</haxe_doc>
		</getElementByURI>
		<getTypedElementByURI public="1" params="T" line="89">
			<f a="uri:cl">
				<c path="String"/>
				<c path="Class"><c path="getTypedElementByURI.T"/></c>
				<c path="getTypedElementByURI.T"/>
			</f>
			<haxe_doc> Return the Element referenced by [uri],
		typed to the given [type].
	
		See also getElementByURI.
		An exception will be thrown if the Element
		is not of the specified [type].
	</haxe_doc>
		</getTypedElementByURI>
		<unmarshal public="1" line="104">
			<f a="xml:?parent">
				<c path="Xml"/>
				<c path="xinf.xml.Node"/>
				<c path="xinf.xml.Node"/>
			</f>
			<haxe_doc> Unmarshal (deserialize) a Node from the given
		[xml], and attaches it to the given [parent] (if specified).
		
		If the Document's $xinf.xml.Binding$s don't support the
		given Xml, [null] will be returned.
		
		Namespaces are currently ignored. This will look though
		all (static) bindings.
	</haxe_doc>
		</unmarshal>
		<new public="1" line="33">
			<f a=""><e path="Void"/></f>
			<haxe_doc> Create a new, empty Document.
	</haxe_doc>
		</new>
		<haxe_doc>
	XML-style Document class.
</haxe_doc>
	</class>
	<class path="xinf.ony.erno.Definitions" params="" file="../../../xinf/src/xinf/ony/erno/Definitions.hx">
		<extends path="xinf.ony.Definitions"/>
		<new public="1" line="8"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.style.StyleParser" params="" file="../../../xinf/src/xinf/style/StyleParser.hx">
		<split line="17" static="1"><c path="EReg"/></split>
		<fromObject public="1" line="24" static="1">
			<f a="s:via:to">
				<d/>
				<c path="xinf.traits.TraitAccess"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc> 
		From a dynamic object with text values as returned by [parseToObject],
		parse individual style properties as defined by [via]'s traits
		definitions, and set the resulting typed values on [to].
	</haxe_doc>
		</fromObject>
		<removeComments public="1" line="35" static="1">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Remove C-style block comments from text.
	</haxe_doc>
		</removeComments>
		<parseToObject public="1" line="58" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Parse a single CSS style definition (as found in a "style" attribute)
		into an dynamic object. The property values are not parsed, but
		retained as Strings (use fromObject to parse/type them).
		
		For example, "[fill:red,stroke:#f00]" will be turned into
		[{ style:"red", stroke:"#f00" }].
	</haxe_doc>
		</parseToObject>
		<cssRules line="76" static="1"><c path="EReg"/></cssRules>
		<parseRules public="1" line="82" static="1">
			<f a="text">
				<c path="String"/>
				<c path="Array"><t path="xinf.style.StyleRule"/></c>
			</f>
			<haxe_doc><![CDATA[ 
		parse CSS style rules, as found in a 
		[<style type="text/css">] element.
	]]></haxe_doc>
		</parseRules>
		<comma_split line="111" static="1"><c path="EReg"/></comma_split>
		<ws_split line="112" static="1"><c path="EReg"/></ws_split>
		<first_s line="113" static="1"><c path="EReg"/></first_s>
		<parseSelectorGroup line="118" static="1">
			<f a="text">
				<c path="String"/>
				<e path="xinf.style.Selector"/>
			</f>
			<haxe_doc>
		Parse a CSS selector
	</haxe_doc>
		</parseSelectorGroup>
		<parseSelector line="130" static="1"><f a="text:?already">
	<c path="String"/>
	<e path="xinf.style.Selector"/>
	<e path="xinf.style.Selector"/>
</f></parseSelector>
		<parseCombinedSelector line="166" static="1"><f a="text">
	<c path="String"/>
	<e path="xinf.style.Selector"/>
</f></parseCombinedSelector>
		<classSel line="178" static="1"><c path="EReg"/></classSel>
		<idSel line="179" static="1"><c path="EReg"/></idSel>
		<parseSingleSelector line="180" static="1"><f a="text:list">
	<c path="String"/>
	<c path="Array"><e path="xinf.style.Selector"/></c>
	<e path="Void"/>
</f></parseSingleSelector>
		<haxe_doc>
	The StyleParser class provides static functions
	to parse CSS-type style definitions, selectors
	and rules into xinf types (and intermediate objects).
</haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.controller.ResetDisplayCommand" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/controller/ResetDisplayCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.command.SimpleCommand"/>
		<new public="1" line="13"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.controller.FreezeDisplayCommand" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/controller/FreezeDisplayCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.command.SimpleCommand"/>
		<new public="1" line="13"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.ony.Ellipse" params="" file="../../../xinf/src/xinf/ony/Ellipse.hx">
		<extends path="xinf.ony.erno.Element"/>
		<tagName line="13" static="1"><c path="String"/></tagName>
		<TRAITS line="15" static="1"><a>
	<ry><c path="xinf.ony.traits.LengthTrait"/></ry>
	<rx><c path="xinf.ony.traits.LengthTrait"/></rx>
	<cy><c path="xinf.ony.traits.LengthTrait"/></cy>
	<cx><c path="xinf.ony.traits.LengthTrait"/></cx>
</a></TRAITS>
		<cx public="1" get="dynamic" set="dynamic"><c path="Float"/></cx>
		<get_cx line="23"><f a=""><c path="Float"/></f></get_cx>
		<set_cx line="24"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_cx>
		<cy public="1" get="dynamic" set="dynamic"><c path="Float"/></cy>
		<get_cy line="27"><f a=""><c path="Float"/></f></get_cy>
		<set_cy line="28"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_cy>
		<rx public="1" get="dynamic" set="dynamic"><c path="Float"/></rx>
		<get_rx line="31"><f a=""><c path="Float"/></f></get_rx>
		<set_rx line="32"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_rx>
		<ry public="1" get="dynamic" set="dynamic"><c path="Float"/></ry>
		<get_ry line="35"><f a=""><c path="Float"/></f></get_ry>
		<set_ry line="36"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_ry>
		<new line="11"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.inity.GLEventSource" params="" file="../../../xinf/src/xinf/inity/GLEventSource.hx">
		<preciseHitTest line="24" static="1"><e path="Bool"/></preciseHitTest>
		<timer static="1"><d/></timer>
		<counter static="1"><c path="Int"/></counter>
		<repeat static="1"><c path="String"/></repeat>
		<frame><c path="Int"/></frame>
		<runtime><c path="xinf.inity.XinfinityRuntime"/></runtime>
		<currentOver><c path="Int"/></currentOver>
		<currentDown><c path="Int"/></currentDown>
		<wheel><c path="Int"/></wheel>
		<attach public="1" line="41"><f a=""><e path="Void"/></f></attach>
		<postKeyRepeat public="1" line="49"><f a="k:code:down">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></postKeyRepeat>
		<handleKey public="1" line="77"><f a="key:down">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></handleKey>
		<handleChar public="1" line="83"><f a="char:down">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></handleChar>
		<postKeyPress public="1" line="88"><f a="key:?code">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></postKeyPress>
		<postKeyRelease public="1" line="96"><f a="key">
	<c path="String"/>
	<e path="Void"/>
</f></postKeyRelease>
		<mouseButton public="1" line="100"><f a="button:state">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></mouseButton>
		<postMouseEventTo line="122"><f a="x:y:type:targetId">
	<c path="Int"/>
	<c path="Int"/>
	<c path="xinf.event.EventKind"><c path="xinf.event.MouseEvent"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></postMouseEventTo>
		<mouseMotion public="1" line="126"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></mouseMotion>
		<mouseWheel public="1" line="138"><f a="wpos">
	<c path="Int"/>
	<e path="Void"/>
</f></mouseWheel>
		<toString public="1" line="152"><f a=""><c path="String"/></f></toString>
		<new public="1" line="36"><f a="runtime">
	<c path="xinf.inity.XinfinityRuntime"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.Root" params="" file="../../../xinf/src/xinf/ony/Root.hx">
		<mRoot static="1"><t path="Svg"/></mRoot>
		<width public="1" line="14" static="1"><c path="Float"/></width>
		<height public="1" line="15" static="1"><c path="Float"/></height>
		<getDocument public="1" line="17" static="1"><f a=""><t path="Document"/></f></getDocument>
		<getRootSvg public="1" line="21" static="1"><f a=""><t path="Svg"/></f></getRootSvg>
		<appendChild public="1" line="44" static="1"><f a="o">
	<t path="Node"/>
	<e path="Void"/>
</f></appendChild>
		<removeChild public="1" line="48" static="1"><f a="o">
	<t path="Node"/>
	<e path="Void"/>
</f></removeChild>
		<addEventListener public="1" params="T" line="52" static="1"><f a="type:h">
	<c path="xinf.event.EventKind"><c path="addEventListener.T"/></c>
	<f a="">
		<c path="addEventListener.T"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="addEventListener.T"/>
		<e path="Void"/>
	</f>
</f></addEventListener>
		<removeEventListener public="1" params="T" line="56" static="1"><f a="type:h">
	<c path="xinf.event.EventKind"><c path="removeEventListener.T"/></c>
	<f a="">
		<c path="removeEventListener.T"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
</f></removeEventListener>
		<postEvent public="1" params="T" line="60" static="1"><f a="e:?pos">
	<c path="xinf.event.Event"><c path="postEvent.T"/></c>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></postEvent>
		<setBackgroundColor public="1" line="64" static="1"><f a="r:g:b:?a">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setBackgroundColor>
		<setFramerate public="1" line="68" static="1"><f a="r">
	<c path="Float"/>
	<e path="Void"/>
</f></setFramerate>
		<getFramerate public="1" line="72" static="1"><f a=""><c path="Float"/></f></getFramerate>
		<getMeasuredFramerate public="1" line="76" static="1"><f a=""><c path="Float"/></f></getMeasuredFramerate>
		<addCSS public="1" line="80" static="1"><f a="css">
	<c path="String"/>
	<e path="Void"/>
</f></addCSS>
		<main public="1" line="84" static="1"><f a=""><e path="Void"/></f></main>
	</class>
	<class path="StringBuf" params="" file="C:\Program Files\Motion-Twin\haxe/std/StringBuf.hx">
		<__make line="98" static="1"><d/></__make>
		<__add line="99" static="1"><d/></__add>
		<__add_char line="100" static="1"><d/></__add_char>
		<__add_sub line="101" static="1"><d/></__add_sub>
		<__string line="102" static="1"><d/></__string>
		<add public="1" line="46">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" line="57">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" line="73">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" line="87">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><d/></b>
		<new public="1" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="neko.Utf8" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/Utf8.hx">
		<encode public="1" line="43" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<decode public="1" line="55" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></decode>
		<iter public="1" line="72" static="1"><f a="s:chars">
	<c path="String"/>
	<f a="">
		<c path="Int"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></iter>
		<charCodeAt public="1" line="76" static="1"><f a="s:index">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
</f></charCodeAt>
		<validate public="1" line="80" static="1"><f a="s">
	<c path="String"/>
	<e path="Bool"/>
</f></validate>
		<length public="1" line="84" static="1"><f a="s">
	<c path="String"/>
	<c path="Int"/>
</f></length>
		<compare public="1" line="88" static="1"><f a="a:b">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
</f></compare>
		<sub public="1" line="92" static="1"><f a="s:pos:len">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></sub>
		<utf8_buf_alloc line="96" static="1"><f a="">
	<c path="Int"/>
	<e path="Void"/>
</f></utf8_buf_alloc>
		<utf8_buf_add line="97" static="1"><f a=":">
	<e path="Void"/>
	<c path="Int"/>
	<unknown/>
</f></utf8_buf_add>
		<utf8_buf_content line="98" static="1"><f a="">
	<e path="Void"/>
	<c path="String"/>
</f></utf8_buf_content>
		<utf8_buf_length line="99" static="1"><unknown/></utf8_buf_length>
		<utf8_iter line="100" static="1"><f a=":">
	<c path="String"/>
	<f a="">
		<c path="Int"/>
		<e path="Void"/>
	</f>
	<unknown/>
</f></utf8_iter>
		<utf8_get line="102" static="1"><f a=":">
	<unknown/>
	<c path="Int"/>
	<c path="Int"/>
</f></utf8_get>
		<utf8_validate line="103" static="1"><f a="">
	<unknown/>
	<e path="Bool"/>
</f></utf8_validate>
		<utf8_length line="104" static="1"><f a="">
	<unknown/>
	<c path="Int"/>
</f></utf8_length>
		<utf8_compare line="105" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<c path="Int"/>
</f></utf8_compare>
		<utf8_sub line="106" static="1"><f a="::">
	<unknown/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></utf8_sub>
		<__b><e path="Void"/></__b>
		<addChar public="1" line="35"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></addChar>
		<toString public="1" line="39"><f a=""><c path="String"/></f></toString>
		<new public="1" line="31"><f a="?size">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.inity.font.TextureGlyph" params="" file="../../../xinf/src/xinf/inity/font/TextureGlyph.hx">
		<extends path="xinf.inity.font.Glyph"/>
		<texture><c path="Int"/></texture>
		<w><c path="Float"/></w>
		<h><c path="Float"/></h>
		<x1><c path="Float"/></x1>
		<y1><c path="Float"/></y1>
		<x2><c path="Float"/></x2>
		<y2><c path="Float"/></y2>
		<setBitmap public="1" line="25"><f a="b:fontHeight">
	<a>
		<y><c path="Int"/></y>
		<x><c path="Int"/></x>
		<width><c path="Int"/></width>
		<height><c path="Int"/></height>
		<bitmap><d/></bitmap>
		<advance><c path="Float"/></advance>
	</a>
	<c path="Int"/>
	<e path="Void"/>
</f></setBitmap>
		<new public="1" line="19"><f a="character:font:size:hint">
	<c path="Int"/>
	<c path="xinf.inity.font.Font"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.Polygon" params="" file="../../../xinf/src/xinf/ony/Polygon.hx">
		<extends path="xinf.ony.erno.Element"/>
		<TRAITS line="12" static="1"><a><points><c path="xinf.ony.traits.PointListTrait"/></points></a></TRAITS>
		<tagName line="16" static="1"><c path="String"/></tagName>
		<points public="1" get="dynamic" set="dynamic"><t path="Iterable"><t path="xinf.geom.TPoint"/></t></points>
		<get_points line="19"><f a=""><t path="Iterable"><t path="xinf.geom.TPoint"/></t></f></get_points>
		<set_points line="22"><f a="v">
	<t path="Iterable"><t path="xinf.geom.TPoint"/></t>
	<t path="Iterable"><t path="xinf.geom.TPoint"/></t>
</f></set_points>
		<new line="10"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.geom.SkewY" params="" file="../../../xinf/src/xinf/geom/SkewY.hx">
		<implements path="xinf.geom.Transform"/>
		<a><c path="Float"/></a>
		<getTranslation public="1" line="15"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getTranslation>
		<getScale public="1" line="18"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getScale>
		<getMatrix public="1" line="21"><f a=""><a>
	<ty><c path="Float"/></ty>
	<tx><c path="Float"/></tx>
	<d><c path="Float"/></d>
	<c><c path="Float"/></c>
	<b><c path="Float"/></b>
	<a><c path="Float"/></a>
</a></f></getMatrix>
		<apply public="1" line="25"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1" line="28"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<interpolateWith public="1" line="32"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1" line="39"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1" line="46"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1" line="50"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
		<toString public="1" line="59"><f a=""><c path="String"/></f></toString>
		<new public="1" line="11"><f a="a">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Polygon" params="" file="../../../xinf/src/xinf/ony/erno/Polygon.hx">
		<extends path="xinf.ony.Polygon"/>
		<new public="1" line="11"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Circle" params="" file="../../../xinf/src/xinf/ony/erno/Circle.hx">
		<extends path="xinf.ony.Circle"/>
		<new public="1" line="10"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="xinf.ony.traits.TRect" params="" file="../../../xinf/src/xinf/ony/traits/PreserveAspectRatioTrait.hx" module="xinf.ony.traits.PreserveAspectRatioTrait"><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
	<w><c path="Float"/></w>
	<h><c path="Float"/></h>
</a></typedef>
	<class path="org.puremvc.haxe.multicore.interfaces.IView" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/interfaces/IView.hx" interface="1">
		<registerObserver public="1">
			<f a="noteName:observer">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IObserver"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register an [IObserver] to be notified of [INotifications] with a given name.
	 </haxe_doc>
		</registerObserver>
		<removeObserver public="1">
			<f a="notificationName:notifyContext">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove a group of observers from the observer list for a given Notification name.
	 </haxe_doc>
		</removeObserver>
		<notifyObservers public="1">
			<f a="note">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Notify the [IObservers] for a particular [INotification].
	 * 
	 * <p>All previously attached [IObservers] for this [INotification]'s
	 * list are notified and are passed a reference to the [INotification] in 
	 * the order in which they were registered.</p>
	 ]]></haxe_doc>
		</notifyObservers>
		<registerMediator public="1">
			<f a="mediator">
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Register an [IMediator] instance with the [View].
	 * 
	 * <p>Registers the [IMediator] so that it can be retrieved by name,
	 * and further interrogates the [IMediator] for its [INotification] interests.</p>
	 *
	 * <p>If the [IMediator] returns any [INotification] 
	 * names to be notified about, an [Observer] is created encapsulating 
	 * the [IMediator] instance's [handleNotification] method 
	 * and registering it as an [Observer] for all [INotifications] the 
	 * [IMediator] is interested in.</p>
	 ]]></haxe_doc>
		</registerMediator>
		<retrieveMediator public="1">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>
	 * Retrieve an [IMediator] from the [View].
	 </haxe_doc>
		</retrieveMediator>
		<removeMediator public="1">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>
	 * Remove an [IMediator] from the [View].
	 </haxe_doc>
		</removeMediator>
		<hasMediator public="1">
			<f a="mediatorName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a [Mediator] is registered or not
	 </haxe_doc>
		</hasMediator>
		<removeView public="1">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove an IView instance
	 </haxe_doc>
		</removeView>
		<haxe_doc><![CDATA[
 * The interface definition for a PureMVC View.
 * 
 * <p>In PureMVC, the [View] class assumes these responsibilities:
 * <ul>
 * <li>Maintain a cache of [IMediator] instances.</li>
 * <li>Provide methods for registering, retrieving, and removing [IMediators].</li>
 * <li>Managing the observer lists for each [INotification] in the application.</li>
 * <li>Providing a method for attaching [IObservers] to an [INotification]'s observer list.</li>
 * <li>Providing a method for broadcasting an [INotification].</li>
 * <li>Notifying the [IObservers] of a given [INotification] when it broadcast.</li>
 * </ul>
 ]]></haxe_doc>
	</class>
	<class path="xinf.geom.Rectangle" params="" file="../../../xinf/src/xinf/geom/Rectangle.hx">
		<createR public="1" line="65" static="1"><f a="r">
	<t path="xinf.geom.TRectangle"/>
	<c path="xinf.geom.Rectangle"/>
</f></createR>
		<createC public="1" line="69" static="1"><f a="l:t:r:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="xinf.geom.Rectangle"/>
</f></createC>
		<l public="1"><c path="Float"/></l>
		<t public="1"><c path="Float"/></t>
		<r public="1"><c path="Float"/></r>
		<b public="1"><c path="Float"/></b>
		<w public="1" line="22"><f a=""><c path="Float"/></f></w>
		<h public="1" line="26"><f a=""><c path="Float"/></f></h>
		<cx public="1" line="30"><f a=""><c path="Float"/></f></cx>
		<cy public="1" line="34"><f a=""><c path="Float"/></f></cy>
		<equal line="38"><f a="a:b:epsilon">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></equal>
		<touches public="1" line="42"><f a="a:e">
	<t path="xinf.geom.TRectangle"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></touches>
		<intersectsRectangle public="1" line="46"><f a="i">
	<t path="xinf.geom.TRectangle"/>
	<e path="Bool"/>
</f></intersectsRectangle>
		<within public="1" line="50"><f a="w">
	<t path="xinf.geom.TRectangle"/>
	<e path="Bool"/>
</f></within>
		<contains public="1" line="54"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<e path="Bool"/>
</f></contains>
		<merge public="1" line="58"><f a="m">
	<t path="xinf.geom.TRectangle"/>
	<e path="Void"/>
</f></merge>
		<toString public="1" line="73"><f a=""><c path="String"/></f></toString>
		<new public="1" line="15"><f a="?c">
	<t path="xinf.geom.TRectangle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Ellipse" params="" file="../../../xinf/src/xinf/ony/erno/Ellipse.hx">
		<extends path="xinf.ony.Ellipse"/>
		<new public="1" line="10"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.geom.Matrix" params="" file="../../../xinf/src/xinf/geom/Matrix.hx">
		<implements path="xinf.geom.Transform"/>
		<a public="1"><c path="Float"/></a>
		<c public="1"><c path="Float"/></c>
		<tx public="1"><c path="Float"/></tx>
		<b public="1"><c path="Float"/></b>
		<d public="1"><c path="Float"/></d>
		<ty public="1"><c path="Float"/></ty>
		<getTranslation public="1" line="35"><f a=""><t path="xinf.geom.TPoint"/></f></getTranslation>
		<getScale public="1" line="38"><f a=""><t path="xinf.geom.TPoint"/></f></getScale>
		<getMatrix public="1" line="41"><f a=""><t path="xinf.geom.TMatrix"/></f></getMatrix>
		<set public="1" line="45"><f a="m">
	<t path="xinf.geom.TMatrix"/>
	<e path="Void"/>
</f></set>
		<apply public="1" line="50"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1" line="57"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<transformBBox public="1" line="63"><f a="r">
	<a>
		<t><c path="Float"/></t>
		<r><c path="Float"/></r>
		<l><c path="Float"/></l>
		<b><c path="Float"/></b>
	</a>
	<a>
		<t><c path="Float"/></t>
		<r><c path="Float"/></r>
		<l><c path="Float"/></l>
		<b><c path="Float"/></b>
	</a>
</f></transformBBox>
		<invert public="1" line="74"><f a=""><c path="xinf.geom.Matrix"/></f></invert>
		<multiply public="1" line="90"><f a="m">
	<t path="xinf.geom.TMatrix"/>
	<c path="xinf.geom.Matrix"/>
</f></multiply>
		<setIdentity public="1" line="104"><f a=""><c path="xinf.geom.Matrix"/></f></setIdentity>
		<translate public="1" line="110"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="xinf.geom.Matrix"/>
</f></translate>
		<setTranslation public="1" line="113"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="xinf.geom.Matrix"/>
</f></setTranslation>
		<scale public="1" line="119"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="xinf.geom.Matrix"/>
</f></scale>
		<setScale public="1" line="122"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="xinf.geom.Matrix"/>
</f></setScale>
		<skew public="1" line="128"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="xinf.geom.Matrix"/>
</f></skew>
		<setSkew public="1" line="131"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="xinf.geom.Matrix"/>
</f></setSkew>
		<rotate public="1" line="137"><f a="a">
	<c path="Float"/>
	<c path="xinf.geom.Matrix"/>
</f></rotate>
		<setRotation public="1" line="140"><f a="angle">
	<c path="Float"/>
	<c path="xinf.geom.Matrix"/>
</f></setRotation>
		<interpolateWith public="1" line="148"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1" line="152"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1" line="156"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1" line="162"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
		<toString public="1" line="169"><f a=""><c path="String"/></f></toString>
		<new public="1" line="27"><f a="?m">
	<t path="xinf.geom.TMatrix"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/BytesData.hx"><c path="neko.NativeString"/></typedef>
	<class path="xinf.event.KeyboardEvent" params="" file="../../../xinf/src/xinf/event/KeyboardEvent.hx">
		<extends path="xinf.event.Event"><c path="xinf.event.KeyboardEvent"/></extends>
		<KEY_DOWN public="1" line="8" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.KeyboardEvent"/></c></KEY_DOWN>
		<KEY_UP public="1" line="9" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.KeyboardEvent"/></c></KEY_UP>
		<code public="1"><c path="Int"/></code>
		<key public="1"><c path="String"/></key>
		<shiftMod public="1"><e path="Bool"/></shiftMod>
		<altMod public="1"><e path="Bool"/></altMod>
		<ctrlMod public="1"><e path="Bool"/></ctrlMod>
		<new public="1" line="17"><f a="_type:code:key:?shiftMod:?altMod:?ctrlMod">
	<c path="xinf.event.EventKind"><c path="xinf.event.KeyboardEvent"/></c>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.Text" params="" file="../../../xinf/src/xinf/ony/Text.hx">
		<extends path="xinf.ony.erno.Element"/>
		<tagName line="14" static="1"><c path="String"/></tagName>
		<TRAITS line="16" static="1"><a>
	<y><c path="xinf.ony.traits.LengthTrait"/></y>
	<x><c path="xinf.ony.traits.LengthTrait"/></x>
	<text><c path="xinf.traits.StringTrait"/></text>
</a></TRAITS>
		<xmlUnescape public="1" line="64" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape XML special characters of the string.
	</haxe_doc>
		</xmlUnescape>
		<x public="1" get="dynamic" set="dynamic"><c path="Float"/></x>
		<get_x line="23"><f a=""><c path="Float"/></f></get_x>
		<set_x line="24"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x>
		<y public="1" get="dynamic" set="dynamic"><c path="Float"/></y>
		<get_y line="27"><f a=""><c path="Float"/></f></get_y>
		<set_y line="28"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y>
		<text public="1" get="dynamic" set="dynamic"><c path="String"/></text>
		<get_text line="31"><f a=""><c path="String"/></f></get_text>
		<set_text line="32"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_text>
		<textContent line="47"><f a="xml">
	<c path="Xml"/>
	<c path="String"/>
</f></textContent>
		<new line="12"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="xinf.inity.GLRenderer" params="" file="../../../xinf/src/xinf/inity/GLRenderer.hx">
		<extends path="xinf.erno.ObjectModelRenderer"/>
		<matrixForGL public="1" line="248" static="1"><f a="m">
	<c path="xinf.geom.Matrix"/>
	<d/>
</f></matrixForGL>
		<applyFill line="26"><f a=""><e path="Bool"/></f></applyFill>
		<applyFillGL line="30"><f a=""><e path="Bool"/></f></applyFillGL>
		<applyStroke line="41"><f a=""><e path="Bool"/></f></applyStroke>
		<applyStrokeGL line="45"><f a=""><e path="Bool"/></f></applyStrokeGL>
		<new public="1" line="22"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.inity.GLVGRenderer" params="" file="../../../xinf/src/xinf/inity/GLVGRenderer.hx">
		<extends path="xinf.inity.GLRenderer"/>
		<matrixForVG public="1" line="308" static="1"><f a="m">
	<t path="xinf.geom.TMatrix"/>
	<d/>
</f></matrixForVG>
		<path><c path="openvg.Path"/></path>
		<fill><c path="openvg.Paint"/></fill>
		<stroke><c path="openvg.Paint"/></stroke>
		<rotatePoint line="35"><f a="p:phi">
	<a>
		<y><c path="Float"/></y>
		<x><c path="Float"/></x>
	</a>
	<c path="Float"/>
	<a>
		<y><c path="Float"/></y>
		<x><c path="Float"/></x>
	</a>
</f></rotatePoint>
		<setGradientParameters line="40"><f a="paint:_stops:spread">
	<c path="openvg.Paint"/>
	<t path="Iterable"><t path="xinf.erno.TGradientStop"/></t>
	<c path="Int"/>
	<e path="Void"/>
</f></setGradientParameters>
		<setFillPaintTransform line="63"><f a="transform">
	<c path="xinf.geom.Transform"/>
	<e path="Void"/>
</f></setFillPaintTransform>
		<setStrokePaintTransform line="69"><f a="transform">
	<c path="xinf.geom.Transform"/>
	<e path="Void"/>
</f></setStrokePaintTransform>
		<makePaint line="75"><f a="givenPaint:fill">
	<e path="xinf.erno.Paint"/>
	<e path="Bool"/>
	<c path="openvg.Paint"/>
</f></makePaint>
		<drawPath line="174"><f a="f">
	<f a="">
		<c path="openvg.Path"/>
		<e path="Void"/>
	</f>
	<c path="openvg.Path"/>
</f></drawPath>
		<applyPath line="185"><f a="path">
	<c path="openvg.Path"/>
	<c path="openvg.Path"/>
</f></applyPath>
		<append line="210"><f a="type:data">
	<c path="Int"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Void"/>
</f></append>
		<new public="1" line="28"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.facade.Facade" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/patterns/facade/Facade.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IFacade"/>
		<getInstance public="1" line="58" static="1">
			<f a="key">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IFacade"/>
			</f>
			<haxe_doc>
	 * Facade Multiton Factory method
	 </haxe_doc>
		</getInstance>
		<instanceMap static="1"><c path="Hash"><c path="org.puremvc.haxe.multicore.interfaces.IFacade"/></c></instanceMap>
		<initializeFacade line="48">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Initialize the Multiton [Facade] instance.
	 * 
	 * <p>Called automatically by the constructor. Override in your
	 * subclass to do any subclass specific initializations. Be
	 * sure to call [super.initializeFacade()], though.</p>
	 ]]></haxe_doc>
		</initializeFacade>
		<initializeController line="78">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Initialize the [Controller].
	 * 
	 * <p>Called by the [initializeFacade] method. Override this method in your subclass of [Facade] 
	 * if one or both of the following are true:</p>
	 * <ul>
	 * <li> You wish to initialize a different [IController].</li>
	 * <li> You have [Commands] to register with the [Controller] at startup.</li>		  
	 * </ul>
	 * <p>If you don't want to initialize a different [IController], 
	 * call [super.initializeController()] at the beginning of your
	 * method, then register [Command]s.</p>
	 ]]></haxe_doc>
		</initializeController>
		<initializeModel line="105">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Initialize the [Model].
	 * 
	 * <p>Called by the [initializeFacade] method. Override this method in your subclass of [Facade] 
	 * if one or both of the following are true:</p>
	 * <ul>
	 * <li> You wish to initialize a different [IModel].</li>
	 * <li> You have [Proxy]s to register with the Model that do not 
	 * retrieve a reference to the Facade at construction time.]</li> 
	 * </ul>
	 *
	 * <p>If you don't want to initialize a different [IModel], 
	 * call [super.initializeModel()] at the beginning of your
	 * method, then register [Proxy]s.
	 * Note: This method is <em>rarely</em> overridden; in practice you are more
	 * likely to use a [Command] to create and register [Proxy]s
	 * with the [Model], since [Proxy]s with mutable data will likely
	 * need to send [INotification]s and thus will likely want to fetch a reference to 
	 * the [Facade] during their construction. 
	 * </P>
	 ]]></haxe_doc>
		</initializeModel>
		<initializeView line="129">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Initialize the [View].
	 * 
	 * <p>Called by the [initializeFacade] method.
	 * Override this method in your subclass of [Facade] 
	 * if one or both of the following are true:</p>
	 * <ul>
	 * <li> You wish to initialize a different [IView].</li>
	 * <li> You have [Observers] to register with the [View]</li>
	 * </ul>
	 * If you don't want to initialize a different [IView], 
	 * call [super.initializeView()] at the beginning of your method, then register [IMediator] instances.
	 * <p>Note: This method is <i>rarely</i> overridden; in practice you are more
	 * likely to use a [Command] to create and register [Mediator]s
	 * with the [View], since [IMediator] instances will need to send 
	 * [INotification]s and thus will likely want to fetch a reference 
	 * to the [Facade] during their construction. </p>
	 ]]></haxe_doc>
		</initializeView>
		<registerCommand public="1" line="138">
			<f a="notificationName:commandClassRef">
				<c path="String"/>
				<c path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register an [ICommand] with the [Controller] by [Notification] name.
	 </haxe_doc>
		</registerCommand>
		<removeCommand public="1" line="146">
			<f a="notificationName">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove a previously registered [ICommand] to [INotification] mapping from the [Controller].
	 </haxe_doc>
		</removeCommand>
		<hasCommand public="1" line="154">
			<f a="notificationName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a [Command] is registered for a given [Notification] 
	 </haxe_doc>
		</hasCommand>
		<registerProxy public="1" line="162">
			<f a="proxy">
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register an [IProxy] with the [Model] by name.
	 </haxe_doc>
		</registerProxy>
		<retrieveProxy public="1" line="170">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>
	 * Retrieve an [IProxy] from the [Model] by name.
	 </haxe_doc>
		</retrieveProxy>
		<removeProxy public="1" line="178">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>
	 * Remove an [IProxy] from the [Model] by name.
	 </haxe_doc>
		</removeProxy>
		<hasProxy public="1" line="188">
			<f a="proxyName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a [Proxy] is registered
	 </haxe_doc>
		</hasProxy>
		<registerMediator public="1" line="196">
			<f a="mediator">
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register a [IMediator] with the [View].
	 </haxe_doc>
		</registerMediator>
		<retrieveMediator public="1" line="204">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>
	 * Retrieve an [IMediator] from the [View].
	 </haxe_doc>
		</retrieveMediator>
		<removeMediator public="1" line="212">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>
	 * Remove an [IMediator] from the [View].
	 </haxe_doc>
		</removeMediator>
		<hasMediator public="1" line="222">
			<f a="mediatorName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a [Mediator] is registered or not
	 </haxe_doc>
		</hasMediator>
		<sendNotification public="1" line="233">
			<f a="notificationName:?body:?type">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Create and send an [INotification].
	 * 
	 * <P>Keeps us from having to construct new notification 
	 * instances in our implementation code.
	 ]]></haxe_doc>
		</sendNotification>
		<notifyObservers public="1" line="241">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Notify [Observer]s.
	 </haxe_doc>
		</notifyObservers>
		<initializeNotifier public="1" line="254">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ 
	 * Set the Multiton key for this facade instance.
	 * 
	 * <p>Not called directly, but instead from the 
	 * constructor when getInstance is invoked. 
	 * It is necessary to be public in order to 
	 * implement INotifier.</p>
	 ]]></haxe_doc>
		</initializeNotifier>
		<removeCore public="1" line="262">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove a Core 
	 </haxe_doc>
		</removeCore>
		<controller><c path="org.puremvc.haxe.multicore.interfaces.IController"/></controller>
		<model><c path="org.puremvc.haxe.multicore.interfaces.IModel"/></model>
		<view><c path="org.puremvc.haxe.multicore.interfaces.IView"/></view>
		<multitonKey><c path="String"/></multitonKey>
		<new line="34">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Constructor. 
	 * 
	 * <p>This [IFacade] implementation is a Multiton, so you should not call the constructor 
	 * directly, but instead call the static Factory method
	 * passing the unique key for this instance
	 * [Facade.getInstance( multitonKey )]</p>
	 ]]></haxe_doc>
		</new>
		<haxe_doc>
 * A base Multiton [IFacade] implementation.
 </haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.ApplicationFacade" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/ApplicationFacade.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.facade.Facade"/>
		<STARTUP public="1" line="17" static="1"><c path="String"/></STARTUP>
		<ENSURE_TIMER public="1" line="18" static="1"><c path="String"/></ENSURE_TIMER>
		<RESET_DISPLAY public="1" line="19" static="1"><c path="String"/></RESET_DISPLAY>
		<FREEZE_DISPLAY public="1" line="20" static="1"><c path="String"/></FREEZE_DISPLAY>
		<STOP_TIMER public="1" line="21" static="1"><c path="String"/></STOP_TIMER>
		<getInstance public="1" line="28" static="1"><f a="key">
	<c path="String"/>
	<c path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.ApplicationFacade"/>
</f></getInstance>
		<startup public="1" line="36"><f a="app">
	<c path="StopWatch"/>
	<e path="Void"/>
</f></startup>
		<new public="1" line="23"><f a="key">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.Polyline" params="" file="../../../xinf/src/xinf/ony/Polyline.hx">
		<extends path="xinf.ony.erno.Element"/>
		<TRAITS line="12" static="1"><a><points><c path="xinf.ony.traits.PointListTrait"/></points></a></TRAITS>
		<tagName line="16" static="1"><c path="String"/></tagName>
		<points public="1" get="dynamic" set="dynamic"><t path="Iterable"><t path="xinf.geom.TPoint"/></t></points>
		<get_points line="19"><f a=""><t path="Iterable"><t path="xinf.geom.TPoint"/></t></f></get_points>
		<set_points line="22"><f a="v">
	<t path="Iterable"><t path="xinf.geom.TPoint"/></t>
	<t path="Iterable"><t path="xinf.geom.TPoint"/></t>
</f></set_points>
		<new line="10"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Polyline" params="" file="../../../xinf/src/xinf/ony/erno/Polyline.hx">
		<extends path="xinf.ony.Polyline"/>
		<new public="1" line="11"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.controller.PrepViewCommand" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/controller/PrepViewCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.command.SimpleCommand"/>
		<new public="1" line="12"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.patterns.observer.Observer" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/patterns/observer/Observer.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IObserver"/>
		<notify><f a="">
	<d/>
	<e path="Void"/>
</f></notify>
		<context><d/></context>
		<setNotifyMethod public="1" line="49">
			<f a="notifyMethod">
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Set the notification method.
	 * 
	 * <p>The notification method should take one parameter of type [INotification].</p>
	 ]]></haxe_doc>
		</setNotifyMethod>
		<setNotifyContext public="1" line="57">
			<f a="notifyContext">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set the notification context.
	 </haxe_doc>
		</setNotifyContext>
		<getNotifyMethod line="65">
			<f a=""><f a="">
	<d/>
	<e path="Void"/>
</f></f>
			<haxe_doc>
	 * Get the notification method.
	 </haxe_doc>
		</getNotifyMethod>
		<getNotifyContext line="73">
			<f a=""><d/></f>
			<haxe_doc>
	 * Get the notification context.
	 </haxe_doc>
		</getNotifyContext>
		<notifyObserver public="1" line="81">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Notify the interested object.
	 </haxe_doc>
		</notifyObserver>
		<compareNotifyContext public="1" line="89">
			<f a="object">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Compare an object to the notification context. 
	 </haxe_doc>
		</compareNotifyContext>
		<new public="1" line="38">
			<f a="notifyMethod:notifyContext">
				<f a="">
					<d/>
					<e path="Void"/>
				</f>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Constructor. 
	 * 
	 * <p>The notification method on the interested object should take 
	 * one parameter of type [INotification]</p>
	 ]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * A base [IObserver] implementation.
 * 
 * <p>An [Observer] is an object that encapsulates information
 * about an interested object with a method that should 
 * be called when a particular [INotification] is broadcast.</p>
 * 
 * <p>In PureMVC, the [Observer] class assumes these responsibilities:</p>
 * <ul>
 * <li>Encapsulate the notification (callback) method of the interested object.</li>
 * <li>Encapsulate the notification context (this) of the interested object.</li>
 * <li>Provide methods for setting the notification method and context.</li>
 * <li>Provide a method for notifying the interested object.</li>
 * </ul>
 ]]></haxe_doc>
	</class>
	<class path="xinf.ony.Crop" params="" file="../../../xinf/src/xinf/ony/Crop.hx">
		<extends path="xinf.ony.erno.Group"/>
		<TRAITS line="13" static="1"><a>
	<width><c path="xinf.traits.FloatTrait"/></width>
	<height><c path="xinf.traits.FloatTrait"/></height>
</a></TRAITS>
		<width public="1" get="dynamic" set="dynamic"><c path="Float"/></width>
		<get_width line="19"><f a=""><c path="Float"/></f></get_width>
		<set_width line="20"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_width>
		<height public="1" get="dynamic" set="dynamic"><c path="Float"/></height>
		<get_height line="23"><f a=""><c path="Float"/></f></get_height>
		<set_height line="24"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_height>
		<new line="26"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neko.net.SocketOutput" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/net/SocketOutput.hx">
		<extends path="haxe.io.Output"/>
		<socket_close line="64" static="1"><f a="">
	<e path="neko.net.SocketHandle"/>
	<unknown/>
</f></socket_close>
		<socket_send_char line="65" static="1"><f a=":">
	<e path="neko.net.SocketHandle"/>
	<c path="Int"/>
	<unknown/>
</f></socket_send_char>
		<socket_send line="66" static="1"><f a=":::">
	<e path="neko.net.SocketHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></socket_send>
		<__s><e path="neko.net.SocketHandle"/></__s>
		<new public="1" line="33"><f a="s">
	<e path="neko.net.SocketHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="openvg.VGU" params="" file="../../../xinf/src/libs/openvg/api/openvg/VGU.hx" extern="1">
		<NO_ERROR public="1" static="1"><c path="Int"/></NO_ERROR>
		<BAD_HANDLE_ERROR public="1" static="1"><c path="Int"/></BAD_HANDLE_ERROR>
		<ILLEGAL_ARGUMENT_ERROR public="1" static="1"><c path="Int"/></ILLEGAL_ARGUMENT_ERROR>
		<OUT_OF_MEMORY_ERROR public="1" static="1"><c path="Int"/></OUT_OF_MEMORY_ERROR>
		<PATH_CAPABILITY_ERROR public="1" static="1"><c path="Int"/></PATH_CAPABILITY_ERROR>
		<BAD_WARP_ERROR public="1" static="1"><c path="Int"/></BAD_WARP_ERROR>
		<ARC_OPEN public="1" static="1"><c path="Int"/></ARC_OPEN>
		<ARC_CHORD public="1" static="1"><c path="Int"/></ARC_CHORD>
		<ARC_PIE public="1" static="1"><c path="Int"/></ARC_PIE>
		<line public="1" static="1"><f a="path:x0:y0:x1:y1">
	<c path="openvg.Path"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></line>
		<polygon public="1" static="1">
			<f a="path:points:count:closed">
				<c path="openvg.Path"/>
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="points" type="float" min-size="val_int(n_count)"/></nekobind> ]]></haxe_doc>
		</polygon>
		<rect public="1" static="1"><f a="path:x:y:width:height">
	<c path="openvg.Path"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></rect>
		<roundRect public="1" static="1"><f a="path:x:y:width:height:rx:ry">
	<c path="openvg.Path"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></roundRect>
		<ellipse public="1" static="1"><f a="path:cx:cy:width:height">
	<c path="openvg.Path"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></ellipse>
		<arc public="1" static="1"><f a="path:x:y:width:height:startAngle:angleExtent:type">
	<c path="openvg.Path"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
</f></arc>
		<haxe_doc><![CDATA[
	Global OpenVG functions. 
	Make sure you create (and makeCurrent) a Display before using any of these.
	
	<nekobind 
		prefix="vgu"
		module="openvg"
		global="true"
		translator="Capitalize"
		globalFinderPrefix="VGU_"
		globalFinderCCFlags="-lOpenVG -lGL -lGLU"
		
		friends="openvg.Path:VGPath>__h,
				openvg.Handle:VGHandle>__h"
		/>
	<nekobind:cHeader>
		#include &lt;vg/openvg.h&gt;
		#include &lt;vg/vgu.h&gt;
	</nekobind:cHeader>
]]></haxe_doc>
	</class>
	<class path="openvg.Path" params="" file="../../../xinf/src/libs/openvg/api/openvg/Path.hx" extern="1">
		<create public="1" static="1">
			<f a="format:datatype:scale:bias:segmentCapacityHint:coordCapacityHint:capabilities">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="openvg.Path"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind ctor="true" suffix="Path"/> ]]></haxe_doc>
		</create>
		<draw public="1">
			<f a="paintModes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="Path"/> ]]></haxe_doc>
		</draw>
		<clear public="1">
			<f a="capabilities">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="Path"/> ]]></haxe_doc>
		</clear>
		<removePathCapabilities public="1"><f a="capabilities">
	<c path="Int"/>
	<e path="Void"/>
</f></removePathCapabilities>
		<getPathCapabilities public="1"><f a=""><c path="Int"/></f></getPathCapabilities>
		<appendPath public="1"><f a="src">
	<c path="openvg.Path"/>
	<e path="Void"/>
</f></appendPath>
		<appendData public="1">
			<f a="numSegments:pathSegments:pathData">
				<c path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind functionName="appendPathData">
		<cptr name="pathSegments" type="unsigned char" min-size="numSegments"/>
		<cptr name="values" type="float" min-size="0"/></nekobind> ]]></haxe_doc>
		</appendData>
		<modifyCoords public="1">
			<f a="startIndex:numSegments:pathData">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind functionName="modifyPathCoords">
		<cptr name="values" type="float" min-size="0"/></nekobind> ]]></haxe_doc>
		</modifyCoords>
		<transform public="1">
			<f a="srcpath">
				<c path="openvg.Path"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="Path"/> ]]></haxe_doc>
		</transform>
		<interpolate public="1">
			<f a="startpath:endpath:amount">
				<c path="openvg.Path"/>
				<c path="openvg.Path"/>
				<c path="Float"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind suffix="Path"/> ]]></haxe_doc>
		</interpolate>
		<pathTransformedBounds public="1">
			<f a="minX:minY:width:height">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind>
		<cptr name="minX" type="float" min-size="1"/>
		<cptr name="minY" type="float" min-size="1"/>
		<cptr name="width" type="float" min-size="1"/>
		<cptr name="height" type="float" min-size="1"/>
		</nekobind> ]]></haxe_doc>
		</pathTransformedBounds>
		<getPathBounds public="1"><f a=""><a>
	<t><c path="Float"/></t>
	<r><c path="Float"/></r>
	<l><c path="Float"/></l>
	<b><c path="Float"/></b>
</a></f></getPathBounds>
		<pathHit public="1"><f a="x:y:testFill:testStroke">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></pathHit>
		<new><f a="format:datatype:scale:bias:segmentCapacityHint:coordCapacityHint:capabilities">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
	<nekobind 
		translator="Capitalize"
		prefix="vg"
		nekoAbstract="__h"
		cStruct="VGPath"
		dtor="destroyPath"
		dtorLock="true"
		module="openvg"
		/>
	<nekobind:cHeader>
		#include &lt;vg/openvg.h&gt;
		#include "helper.h"
	</nekobind:cHeader>
]]></haxe_doc>
	</class>
	<class path="neko.NativeString" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/NativeString.hx">
		<ofString public="1" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="neko.NativeString"/>
</f></ofString>
		<toString public="1" line="33" static="1"><f a="s">
	<c path="neko.NativeString"/>
	<c path="String"/>
</f></toString>
		<length public="1" line="37" static="1"><f a="s">
	<c path="neko.NativeString"/>
	<c path="Int"/>
</f></length>
	</class>
	<class path="xinf.ony.GradientStop" params="" file="../../../xinf/src/xinf/ony/GradientStop.hx">
		<extends path="xinf.style.StyledElement"/>
		<TRAITS line="17" static="1"><a>
	<stop_opacity><c path="xinf.traits.BoundedFloatTrait"/></stop_opacity>
	<stop_color><c path="xinf.ony.traits.PaintTrait"/></stop_color>
	<offset><c path="xinf.ony.traits.LengthTrait"/></offset>
</a></TRAITS>
		<stopOpacity public="1" get="get_stop_opacity" set="set_stop_opacity"><t path="Null"><c path="Float"/></t></stopOpacity>
		<get_stop_opacity line="24"><f a=""><t path="Null"><c path="Float"/></t></f></get_stop_opacity>
		<set_stop_opacity line="25"><f a="v">
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Float"/></t>
</f></set_stop_opacity>
		<stopColor public="1" get="get_stop_color" set="set_stop_color"><e path="xinf.ony.type.Paint"/></stopColor>
		<get_stop_color line="28"><f a=""><e path="xinf.ony.type.Paint"/></f></get_stop_color>
		<set_stop_color line="29"><f a="v">
	<e path="xinf.ony.type.Paint"/>
	<e path="xinf.ony.type.Paint"/>
</f></set_stop_color>
		<r public="1"><c path="Float"/></r>
		<g public="1"><c path="Float"/></g>
		<b public="1"><c path="Float"/></b>
		<a public="1"><c path="Float"/></a>
		<offset public="1"><c path="Float"/></offset>
		<new public="1" line="37"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Float" params="" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<enum path="Bool" params="" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<enum path="Void" params="" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Std" params="" file="C:\Program Files\Motion-Twin\haxe/std/Std.hx">
		<is public="1" line="34" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" line="52" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" line="70" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" line="84" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" line="122" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" line="142" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<typedef path="xinf.support.FTIterateCallbacks" params="" file="../../../xinf/src/libs/xinfinity-support/api/xinf/support/Font.hx" module="xinf.support.Font"><a>
	<startContour><f a=":">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></startContour>
	<lineTo><f a=":">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></lineTo>
	<endGlyph><f a=":">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></endGlyph>
	<endContour><f a=""><e path="Void"/></f></endContour>
	<curveTo><f a=":::">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></curveTo>
</a></typedef>
	<class path="xinf.traits.SpecialTraitValue" params="" file="../../../xinf/src/xinf/traits/SpecialTraitValue.hx">
		<get public="1" line="13"><f a="name:type:c">
	<c path="String"/>
	<d/>
	<c path="xinf.xml.XMLElement"/>
	<d/>
</f></get>
		<new public="1" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.traits.Inherit" params="" file="../../../xinf/src/xinf/traits/SpecialTraitValue.hx" module="xinf.traits.SpecialTraitValue">
		<extends path="xinf.traits.SpecialTraitValue"/>
		<inherit public="1" line="19" static="1"><c path="xinf.traits.Inherit"/></inherit>
		<toString public="1" line="27"><f a=""><c path="String"/></f></toString>
		<new public="1" line="18"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.traits.CurrentColor" params="" file="../../../xinf/src/xinf/traits/SpecialTraitValue.hx" module="xinf.traits.SpecialTraitValue">
		<extends path="xinf.traits.SpecialTraitValue"/>
		<currentColor public="1" line="33" static="1"><c path="xinf.traits.CurrentColor"/></currentColor>
		<toString public="1" line="45"><f a=""><c path="String"/></f></toString>
		<new public="1" line="32"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.ony.erno.Crop" params="" file="../../../xinf/src/xinf/ony/erno/Crop.hx">
		<extends path="xinf.ony.Crop"/>
		<new public="1" line="10"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="TPoint" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><t path="xinf.geom.TPoint"/></typedef>
	<typedef path="Translate" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.geom.Translate"/></typedef>
	<typedef path="Identity" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.geom.Identity"/></typedef>
	<typedef path="Scale" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.geom.Scale"/></typedef>
	<typedef path="Rotate" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.geom.Rotate"/></typedef>
	<typedef path="Concatenate" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.geom.Concatenate"/></typedef>
	<typedef path="Matrix" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.geom.Matrix"/></typedef>
	<typedef path="Transform" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.geom.TransformList"/></typedef>
	<typedef path="TransformList" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.geom.TransformList"/></typedef>
	<typedef path="MouseEvent" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.event.MouseEvent"/></typedef>
	<typedef path="KeyboardEvent" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.event.KeyboardEvent"/></typedef>
	<typedef path="FrameEvent" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.event.FrameEvent"/></typedef>
	<typedef path="GeometryEvent" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.event.GeometryEvent"/></typedef>
	<typedef path="SimpleEvent" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.event.SimpleEvent"/></typedef>
	<typedef path="ScrollEvent" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.event.ScrollEvent"/></typedef>
	<typedef path="UIEvent" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.event.UIEvent"/></typedef>
	<typedef path="LinkEvent" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.event.LinkEvent"/></typedef>
	<typedef path="Document" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.xml.Document"/></typedef>
	<typedef path="Node" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.xml.Node"/></typedef>
	<typedef path="Root" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.Root"/></typedef>
	<typedef path="Svg" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Svg"/></typedef>
	<typedef path="Element" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Element"/></typedef>
	<typedef path="Group" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Group"/></typedef>
	<typedef path="Rectangle" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Rectangle"/></typedef>
	<typedef path="Ellipse" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Ellipse"/></typedef>
	<typedef path="Circle" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Circle"/></typedef>
	<typedef path="Image" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Image"/></typedef>
	<typedef path="Path" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Path"/></typedef>
	<typedef path="Line" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Line"/></typedef>
	<typedef path="Polygon" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Polygon"/></typedef>
	<typedef path="Polyline" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Polyline"/></typedef>
	<typedef path="Text" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Text"/></typedef>
	<typedef path="TextArea" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.EditableTextArea"/></typedef>
	<typedef path="Use" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Use"/></typedef>
	<typedef path="Definitions" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Definitions"/></typedef>
	<typedef path="Link" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.Link"/></typedef>
	<typedef path="Crop" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.erno.Crop"/></typedef>
	<typedef path="TraitAccess" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.traits.TraitAccess"/></typedef>
	<typedef path="FloatTrait" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.traits.FloatTrait"/></typedef>
	<typedef path="IntTrait" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.traits.IntTrait"/></typedef>
	<typedef path="StringTrait" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.traits.StringTrait"/></typedef>
	<typedef path="LengthTrait" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.traits.LengthTrait"/></typedef>
	<typedef path="Length" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><c path="xinf.ony.type.Length"/></typedef>
	<typedef path="Paint" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><e path="xinf.ony.type.Paint"/></typedef>
	<typedef path="PreserveAspectRatio" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><e path="xinf.ony.type.PreserveAspectRatio"/></typedef>
	<typedef path="TextAnchor" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><e path="xinf.ony.type.TextAnchor"/></typedef>
	<typedef path="Display" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><e path="xinf.ony.type.Display"/></typedef>
	<typedef path="Visibility" params="" file="../../../xinf/src/Xinf.hx" module="Xinf"><e path="xinf.ony.type.Visibility"/></typedef>
	<class path="xinf.erno.ImageData" params="" file="../../../xinf/src/xinf/erno/ImageData.hx">
		<extends path="xinf.event.SimpleEventDispatcher"/>
		<load public="1" line="82" static="1">
			<f a="url">
				<c path="xinf.xml.URL"/>
				<c path="xinf.erno.ImageData"/>
			</f>
			<haxe_doc><![CDATA[
		load this ImageData from the given URL. What kind of URLs are accepted
		differs from runtime to runtime:
		<ul>
			<li>Xinfinity: [file://] for local files, [http://] for remote files,
				or [resource://] for images embedded as haXe resources.
				Xinfinity uses the gdk-pixbuf library to decode image data,
				so it supports any of the formats supported by that, most notably,
				JPEG, PNG and GIF.</li>
			<li>Flash9: any URL accepted for flash.display.Loader,
				but the url must return an Bitmap image. Additionally,
				[resource://] urls are accepted to load images from
				the asset library of the current SWF (not from haXe resources!)</li>
			<li>JavaScript: any URL accepted for normal image URLs.</li>
		</ul>
	]]></haxe_doc>
		</load>
		<texture public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
			Xinfinity only: the OpenGL-ID of the texture that contains the image data.
		</haxe_doc>
		</texture>
		<twidth public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
			Xinfinity only: the allocated width of the texture that contains the image data,
			must be a power of two.
		</haxe_doc>
		</twidth>
		<theight public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
			Xinfinity only: the allocated height of the texture that contains the image data,
			must be a power of two.
		</haxe_doc>
		</theight>
		<width public="1" set="null">
			<t path="Null"><c path="Float"/></t>
			<haxe_doc>
		The width of the image, set only after the image is (at least partly) loaded.
	</haxe_doc>
		</width>
		<height public="1" set="null">
			<t path="Null"><c path="Float"/></t>
			<haxe_doc>
		The height of the image, set only after the image is (at least partly) loaded.
	</haxe_doc>
		</height>
		<frameAvailable line="54"><f a="?data:?pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></frameAvailable>
		<partLoaded line="58"><f a="?pos">
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></partLoaded>
		<loaded line="62"><f a="?data:?pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></loaded>
		<new public="1" line="20"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
	DOCME: out of date!
	
	ImageData represents the data of a bitmap image. It can be passed to a
	<a href="Renderer.html">Renderer</a>'s [image()] function to draw (part of) an image.
	<p>
		ImageData is also a SimpleEventDispatcher and dispatches
		<a href="../event/ImageLoadEvent.html">ImageLoadEvents</a>
	</p>
]]></haxe_doc>
	</class>
	<class path="xinf.inity.Texture" params="" file="../../../xinf/src/xinf/inity/Texture.hx">
		<extends path="xinf.erno.ImageData"/>
		<cache public="1" line="112" static="1"><c path="Hash"><c path="xinf.inity.Texture"/></c></cache>
		<newByName public="1" line="114" static="1"><f a="url">
	<c path="xinf.xml.URL"/>
	<c path="xinf.inity.Texture"/>
</f></newByName>
		<newFromPixbuf public="1" line="152" static="1"><f a="pixbuf">
	<c path="xinf.support.Pixbuf"/>
	<c path="xinf.inity.Texture"/>
</f></newFromPixbuf>
		<initialize public="1" line="24"><f a="w:stride:h:cspace">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="xinf.inity.ColorSpace"/>
	<e path="Void"/>
</f></initialize>
		<setData public="1" line="73"><f a="data:pos:size:stride:?cspace">
	<d/>
	<a>
		<y><c path="Int"/></y>
		<x><c path="Int"/></x>
	</a>
	<a>
		<y><c path="Int"/></y>
		<x><c path="Int"/></x>
	</a>
	<c path="Int"/>
	<e path="xinf.inity.ColorSpace"/>
	<e path="Void"/>
</f></setData>
		<new public="1" line="19"><f a=""><e path="Void"/></f></new>
		<haxe_doc> strictly any neko ImageData is already a texture. This class manages the texture though,
  ImageData only stores some values for direct access by the GLGraphicsContext </haxe_doc>
	</class>
	<class path="xinf.geom.Rotate" params="" file="../../../xinf/src/xinf/geom/Rotate.hx">
		<implements path="xinf.geom.Transform"/>
		<a><c path="Float"/></a>
		<getTranslation public="1" line="15"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getTranslation>
		<getScale public="1" line="18"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getScale>
		<getMatrix public="1" line="21"><f a=""><a>
	<ty><c path="Float"/></ty>
	<tx><c path="Float"/></tx>
	<d><c path="Float"/></d>
	<c><c path="Float"/></c>
	<b><c path="Float"/></b>
	<a><c path="Float"/></a>
</a></f></getMatrix>
		<apply public="1" line="27"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1" line="30"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<interpolateWith public="1" line="34"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1" line="41"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1" line="48"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1" line="52"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
		<toString public="1" line="60"><f a=""><c path="String"/></f></toString>
		<new public="1" line="11"><f a="a">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.event.UIEvent" params="" file="../../../xinf/src/xinf/event/UIEvent.hx">
		<extends path="xinf.event.Event"><c path="xinf.event.UIEvent"/></extends>
		<ACTIVATE public="1" line="11" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.UIEvent"/></c></ACTIVATE>
		<targetId public="1"><t path="Null"><c path="Int"/></t></targetId>
		<new public="1" line="15"><f a="_type:?targetId">
	<c path="xinf.event.EventKind"><c path="xinf.event.UIEvent"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	
</haxe_doc>
	</class>
	<enum path="neko.net.SocketHandle" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/net/Socket.hx" module="neko.net.Socket"/>
	<class path="neko.net.Socket" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/net/Socket.hx">
		<newUdpSocket public="1" line="116" static="1"><f a=""><c path="neko.net.Socket"/></f></newUdpSocket>
		<select public="1" line="121" static="1"><f a="read:write:others:timeout">
	<c path="Array"><c path="neko.net.Socket"/></c>
	<c path="Array"><c path="neko.net.Socket"/></c>
	<c path="Array"><c path="neko.net.Socket"/></c>
	<c path="Float"/>
	<a>
		<write><c path="Array"><c path="neko.net.Socket"/></c></write>
		<read><c path="Array"><c path="neko.net.Socket"/></c></read>
		<others><c path="Array"><c path="neko.net.Socket"/></c></others>
	</a>
</f></select>
		<socket_new line="159" static="1"><f a="">
	<e path="Bool"/>
	<e path="neko.net.SocketHandle"/>
</f></socket_new>
		<socket_close line="160" static="1"><f a="">
	<e path="neko.net.SocketHandle"/>
	<unknown/>
</f></socket_close>
		<socket_write line="161" static="1"><f a=":">
	<e path="neko.net.SocketHandle"/>
	<unknown/>
	<unknown/>
</f></socket_write>
		<socket_read line="162" static="1"><f a="">
	<e path="neko.net.SocketHandle"/>
	<c path="String"/>
</f></socket_read>
		<socket_connect line="163" static="1"><f a="::">
	<e path="neko.net.SocketHandle"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<unknown/>
</f></socket_connect>
		<socket_listen line="164" static="1"><f a=":">
	<e path="neko.net.SocketHandle"/>
	<c path="Int"/>
	<unknown/>
</f></socket_listen>
		<socket_select line="165" static="1"><f a=":::">
	<c path="Array"><e path="neko.net.SocketHandle"/></c>
	<c path="Array"><e path="neko.net.SocketHandle"/></c>
	<c path="Array"><e path="neko.net.SocketHandle"/></c>
	<c path="Float"/>
	<c path="Array"><c path="Array"><unknown/></c></c>
</f></socket_select>
		<socket_bind line="166" static="1"><f a="::">
	<e path="neko.net.SocketHandle"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<unknown/>
</f></socket_bind>
		<socket_accept line="167" static="1"><f a="">
	<e path="neko.net.SocketHandle"/>
	<e path="neko.net.SocketHandle"/>
</f></socket_accept>
		<socket_peer line="168" static="1"><f a="">
	<e path="neko.net.SocketHandle"/>
	<unknown/>
</f></socket_peer>
		<socket_host line="169" static="1"><f a="">
	<e path="neko.net.SocketHandle"/>
	<unknown/>
</f></socket_host>
		<socket_set_timeout line="170" static="1"><f a=":">
	<e path="neko.net.SocketHandle"/>
	<c path="Float"/>
	<unknown/>
</f></socket_set_timeout>
		<socket_shutdown line="171" static="1"><f a="::">
	<e path="neko.net.SocketHandle"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<unknown/>
</f></socket_shutdown>
		<socket_set_blocking line="172" static="1"><f a=":">
	<e path="neko.net.SocketHandle"/>
	<e path="Bool"/>
	<unknown/>
</f></socket_set_blocking>
		<__s><e path="neko.net.SocketHandle"/></__s>
		<input public="1" set="null"><c path="neko.net.SocketInput"/></input>
		<output public="1" set="null"><c path="neko.net.SocketOutput"/></output>
		<custom public="1"><d/></custom>
		<close public="1" line="45"><f a=""><e path="Void"/></f></close>
		<read public="1" line="55"><f a=""><c path="String"/></f></read>
		<write public="1" line="59"><f a="content">
	<c path="String"/>
	<e path="Void"/>
</f></write>
		<connect public="1" line="63"><f a="host:port">
	<c path="neko.net.Host"/>
	<c path="Int"/>
	<e path="Void"/>
</f></connect>
		<listen public="1" line="74"><f a="connections">
	<c path="Int"/>
	<e path="Void"/>
</f></listen>
		<shutdown public="1" line="78"><f a="read:write">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></shutdown>
		<bind public="1" line="82"><f a="host:port">
	<c path="neko.net.Host"/>
	<c path="Int"/>
	<e path="Void"/>
</f></bind>
		<accept public="1" line="86"><f a=""><c path="neko.net.Socket"/></f></accept>
		<peer public="1" line="90"><f a=""><a>
	<port><c path="Int"/></port>
	<host><c path="neko.net.Host"/></host>
</a></f></peer>
		<host public="1" line="97"><f a=""><a>
	<port><c path="Int"/></port>
	<host><c path="neko.net.Host"/></host>
</a></f></host>
		<setTimeout public="1" line="104"><f a="timeout">
	<c path="Float"/>
	<e path="Void"/>
</f></setTimeout>
		<waitForRead public="1" line="108"><f a=""><e path="Void"/></f></waitForRead>
		<setBlocking public="1" line="112"><f a="b">
	<e path="Bool"/>
	<e path="Void"/>
</f></setBlocking>
		<new public="1" line="39"><f a="?s">
	<e path="neko.net.SocketHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.geom.TransformList" params="" file="../../../xinf/src/xinf/geom/TransformList.hx">
		<implements path="xinf.geom.Transform"/>
		<l><c path="List"><c path="xinf.geom.Transform"/></c></l>
		<m><c path="xinf.geom.Matrix"/></m>
		<cache line="19"><f a=""><e path="Void"/></f></cache>
		<getTranslation public="1" line="26"><f a=""><t path="xinf.geom.TPoint"/></f></getTranslation>
		<getScale public="1" line="29"><f a=""><t path="xinf.geom.TPoint"/></f></getScale>
		<getMatrix public="1" line="32"><f a=""><t path="xinf.geom.TMatrix"/></f></getMatrix>
		<apply public="1" line="36"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1" line="39"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<interpolateWith public="1" line="43"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1" line="47"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1" line="51"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1" line="58"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
		<toString public="1" line="65"><f a=""><c path="String"/></f></toString>
		<new public="1" line="12"><f a="?list">
	<t path="Iterable"><c path="xinf.geom.Transform"/></t>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Rectangle" params="" file="../../../xinf/src/xinf/ony/erno/Rectangle.hx">
		<extends path="xinf.ony.Rectangle"/>
		<new public="1" line="10"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.event.LinkEvent" params="" file="../../../xinf/src/xinf/event/LinkEvent.hx">
		<extends path="xinf.event.Event"><c path="xinf.event.LinkEvent"/></extends>
		<ACTUATE public="1" line="11" static="1"><c path="xinf.event.EventKind"><c path="xinf.event.LinkEvent"/></c></ACTUATE>
		<href public="1"><c path="String"/></href>
		<new public="1" line="15"><f a="_type:href">
	<c path="xinf.event.EventKind"><c path="xinf.event.LinkEvent"/></c>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	
</haxe_doc>
	</class>
	<typedef path="xinf.inity.Primitive" params="" file="../../../xinf/src/xinf/inity/GLRenderer.hx" module="xinf.inity.GLRenderer"><c path="xinf.inity.GLObject"/></typedef>
	<class path="neko.io.FileInput" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_read line="74" static="1"><f a=":::">
	<e path="neko.io.FileHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_read>
		<file_read_char line="75" static="1"><f a="">
	<e path="neko.io.FileHandle"/>
	<c path="Int"/>
</f></file_read_char>
		<file_close line="77" static="1"><f a="">
	<e path="neko.io.FileHandle"/>
	<unknown/>
</f></file_close>
		<file_seek line="78" static="1"><f a="::">
	<e path="neko.io.FileHandle"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="79" static="1"><f a="">
	<e path="neko.io.FileHandle"/>
	<c path="Int"/>
</f></file_tell>
		<__f><e path="neko.io.FileHandle"/></__f>
		<seek public="1" line="66"><f a="p:pos">
	<c path="Int"/>
	<e path="neko.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" line="70"><f a=""><c path="Int"/></f></tell>
		<new public="1" line="35"><f a="f">
	<e path="neko.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [neko.io.File.read] to create a [FileInput]
</haxe_doc>
	</class>
	<enum path="neko.vm.ModuleHandle" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/vm/Module.hx" module="neko.vm.Module"><haxe_doc>
	The abstract Neko module handle.
</haxe_doc></enum>
	<class path="neko.vm.Module" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/vm/Module.hx">
		<local public="1" line="138" static="1">
			<f a=""><c path="neko.vm.Module"/></f>
			<haxe_doc>
		Returns the local Module, which is the one in which this
		method is included.
	</haxe_doc>
		</local>
		<read public="1" line="146" static="1">
			<f a="i:l">
				<c path="haxe.io.Input"/>
				<c path="neko.vm.Loader"/>
				<c path="neko.vm.Module"/>
			</f>
			<haxe_doc>
		Reads a module from an Input by using the given Loader.
		The module is initialized but has not yet been executed.
	</haxe_doc>
		</read>
		<readBytes public="1" line="157" static="1">
			<f a="b:loader">
				<c path="haxe.io.Bytes"/>
				<c path="neko.vm.Loader"/>
				<c path="neko.vm.Module"/>
			</f>
			<haxe_doc>
		Reads a module from Bytes using the given Loader.
		The module is initialized but has not yet been executed.
	</haxe_doc>
		</readBytes>
		<readPath public="1" line="165" static="1">
			<f a="name:path:loader">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="neko.vm.Loader"/>
				<c path="neko.vm.Module"/>
			</f>
			<haxe_doc>
		Reads a module from a name and using the specified seach path and loader.
		The module is initialized but has not yet been executed.
	</haxe_doc>
		</readPath>
		<_module_read line="178" static="1"><f a=":">
	<f a="buf:pos:len">
		<t path="haxe.io.BytesData"/>
		<c path="Int"/>
		<c path="Int"/>
		<c path="Int"/>
	</f>
	<e path="neko.vm.LoaderHandle"/>
	<e path="neko.vm.ModuleHandle"/>
</f></_module_read>
		<_module_read_path line="179" static="1"><f a="::">
	<unknown/>
	<unknown/>
	<e path="neko.vm.LoaderHandle"/>
	<e path="neko.vm.ModuleHandle"/>
</f></_module_read_path>
		<_module_exec line="180" static="1"><f a="">
	<e path="neko.vm.ModuleHandle"/>
	<unknown/>
</f></_module_exec>
		<_module_name line="181" static="1"><f a="">
	<e path="neko.vm.ModuleHandle"/>
	<c path="String"/>
</f></_module_name>
		<_module_exports line="182" static="1"><f a="">
	<e path="neko.vm.ModuleHandle"/>
	<unknown/>
</f></_module_exports>
		<_module_loader line="183" static="1"><f a="">
	<e path="neko.vm.ModuleHandle"/>
	<e path="neko.vm.LoaderHandle"/>
</f></_module_loader>
		<_module_code_size line="184" static="1"><f a="">
	<e path="neko.vm.ModuleHandle"/>
	<c path="Int"/>
</f></_module_code_size>
		<_module_nglobals line="185" static="1"><f a="">
	<e path="neko.vm.ModuleHandle"/>
	<c path="Int"/>
</f></_module_nglobals>
		<_module_global_get line="186" static="1"><f a=":">
	<e path="neko.vm.ModuleHandle"/>
	<c path="Int"/>
	<unknown/>
</f></_module_global_get>
		<_module_global_set line="187" static="1"><f a="::">
	<e path="neko.vm.ModuleHandle"/>
	<c path="Int"/>
	<d/>
	<unknown/>
</f></_module_global_set>
		<_module_read_string line="188" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<e path="neko.vm.LoaderHandle"/>
	<e path="neko.vm.ModuleHandle"/>
</f></_module_read_string>
		<_module_set_name line="189" static="1"><f a=":">
	<e path="neko.vm.ModuleHandle"/>
	<unknown/>
	<unknown/>
</f></_module_set_name>
		<m public="1">
			<e path="neko.vm.ModuleHandle"/>
			<haxe_doc>
		The abstract handle.
	</haxe_doc>
		</m>
		<name public="1" get="getName" set="setName"><c path="String"/></name>
		<execute public="1" line="54">
			<f a=""><d/></f>
			<haxe_doc>
		Execute a module and returns its result (the latest evaluated expression).
		A module can be executed several times but its globals are only initialized once
		the first time the Module is loaded.
	</haxe_doc>
		</execute>
		<getName line="58"><f a=""><c path="String"/></f></getName>
		<setName line="62"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setName>
		<loader public="1" line="71">
			<f a=""><c path="neko.vm.Loader"/></f>
			<haxe_doc>
		Returns the Loader that this Module was loaded with.s
	</haxe_doc>
		</loader>
		<codeSize public="1" line="78">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the codeSize of the Module.
	</haxe_doc>
		</codeSize>
		<globalsCount public="1" line="85">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the number of globals in this Module global table.
	</haxe_doc>
		</globalsCount>
		<getGlobal public="1" line="92">
			<f a="n">
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
		Get a Module global value.
	</haxe_doc>
		</getGlobal>
		<setGlobal public="1" line="99">
			<f a="n:v">
				<c path="Int"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a Module global value.
	</haxe_doc>
		</setGlobal>
		<toString public="1" line="103"><f a=""><c path="String"/></f></toString>
		<getExports public="1" line="111">
			<f a=""><c path="Hash"><d/></c></f>
			<haxe_doc>
		Each Module has an export table which can be useful to transfert
		values between modules.
	</haxe_doc>
		</getExports>
		<exportsTable public="1" line="122">
			<f a=""><d/></f>
			<haxe_doc>
		The raw export table.
	</haxe_doc>
		</exportsTable>
		<setExport public="1" line="129">
			<f a="name:value">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value in the Module export table.
	</haxe_doc>
		</setExport>
		<__compare line="174"><f a="other">
	<c path="neko.vm.Module"/>
	<unknown/>
</f></__compare>
		<new public="1" line="45"><f a="m">
	<e path="neko.vm.ModuleHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	A Neko Module represent a execution unit for the Neko Virtual Machine. Each compiled [.n] bytecode
	file is a module once loaded by the NekoVM.
</haxe_doc>
	</class>
	<class path="xinf.ony.erno.Root" params="" file="../../../xinf/src/xinf/ony/erno/Root.hx">
		<extends path="xinf.ony.erno.Embed"/>
		<stageScaled line="32"><f a="e">
	<c path="xinf.event.GeometryEvent"/>
	<e path="Void"/>
</f></stageScaled>
		<new public="1" line="27">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
		Constructor; creates a new Root. This should only ever be called once
		for every Application (if you need multiple Roots, use <a href="Embed.html">Embed</a>).
		There is nothing checking this, so take care. If you instantiate an
		<a href="Application.html">Application</a>, the Root will be created for you,
		access it with Application.root.
	]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[
	Root represents the Runtime-default root Object, i.e., the Stage in Flash,
	the Document in JS, or the (main) Window in Xinfinity.
	<p>
		Root is  an <a href="Embed.html">Embed</a> Object that uses the 
		Runtime's default root to embed its display hierarchy. It also watches
		for STAGE_SCALED events to update it's size.
	</p>
]]></haxe_doc>
	</class>
	<class path="opengl.GLU" params="" file="../../../xinf/src/libs/opengl/api/opengl/GLU.hx" extern="1">
		<perspective public="1" static="1"><f a="fovy:aspect:zNear:zFar">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></perspective>
		<pickMatrix public="1" static="1">
			<f a="x:y:delX:delY:viewport">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="viewport" type="GLint" min-size="2"/></nekobind> ]]></haxe_doc>
		</pickMatrix>
		<errorString public="1" static="1"><f a="error">
	<c path="Int"/>
	<c path="String"/>
</f></errorString>
		<lookAt public="1" static="1"><f a="eyeX:eyeY:eyeZ:centerX:centerY:centerZ:upX:upY:upZ">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lookAt>
		<ortho2D public="1" static="1"><f a="left:right:bottom:top">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></ortho2D>
		<haxe_doc><![CDATA[
	Global OpenGL libGLU functions. 
	
	<nekobind 
		prefix="glu"
		module="opengl"
		global="true"
		translator="Capitalize"
		globalFinderPrefix="GLU_"
		globalFinderCCFlags="-lGL -lGLU"
		/>
	<nekobind:cHeader>
	#ifdef NEKO_OSX
		#include &lt;OpenGL/gl.h&gt;
		#include &lt;OpenGL/glu.h&gt;
	#else
		#include &lt;GL/gl.h&gt;
		#include &lt;GL/glu.h&gt;
	#endif
	</nekobind:cHeader>
]]></haxe_doc>
	</class>
	<typedef path="xinf.style.StyleRule" params="" file="../../../xinf/src/xinf/style/StyleSheet.hx" module="xinf.style.StyleSheet">
		<a>
			<style><d/></style>
			<selector><e path="xinf.style.Selector"/></selector>
		</a>
		<haxe_doc>
	A single style rule of a CSS stylesheet.
	
	[style] has values still as text, 
	as returned by $xinf.style.StyleParser$.parseToObject.
</haxe_doc>
	</typedef>
	<typedef path="xinf.style.Stylable" params="" file="../../../xinf/src/xinf/style/StyleSheet.hx" module="xinf.style.StyleSheet">
		<a><matchSelector><f a="s">
	<e path="xinf.style.Selector"/>
	<e path="Bool"/>
</f></matchSelector></a>
		<haxe_doc>
	Typedef for "stylable" objects, used only
	for $xinf.style.StyleSheet::match$.
	
	$xinf.style.StyledElement$ fits the description.
</haxe_doc>
	</typedef>
	<class path="xinf.style.StyleSheet" params="" file="../../../xinf/src/xinf/style/StyleSheet.hx">
		<DEFAULT public="1" line="46" static="1">
			<c path="xinf.style.StyleSheet"/>
			<haxe_doc>
		The default stylesheet. It is always applied,
		with lowest priority.
	</haxe_doc>
		</DEFAULT>
		<rules><c path="Array"><t path="xinf.style.StyleRule"/></c></rules>
		<parseCSS public="1" line="63">
			<f a="data">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Parse a textual CSS stylesheet to the end 
		of this StyleSheet.
	</haxe_doc>
		</parseCSS>
		<add public="1" line="70">
			<f a="rule">
				<t path="xinf.style.StyleRule"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add a single StyleRule to the end of this StyleSheet.
	</haxe_doc>
		</add>
		<addMany public="1" line="82">
			<f a="_rules">
				<t path="Iterable"><t path="xinf.style.StyleRule"/></t>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add a number of StyleRules to the end of this StyleSheet.
	</haxe_doc>
		</addMany>
		<match public="1" line="101">
			<f a="e">
				<t path="xinf.style.Stylable"/>
				<d/>
			</f>
			<haxe_doc>
		Match the given object [e] against the rules found
		in this, or the default, StyleSheet.
		
		Matching styles are aggregated into a single dynamic
		object, with the property values still unparsed text
		(as returned by $xinf.style.StyleParser::parseToObject$.
		
		Priorities are not as elaborate as stipulated by CSS2: 
		simply, rules that come last always have higher priority.
		
		Rules from the DEFAULT StyleSheet are also applied (with
		lower priority than the ones found in this StyleSheet).
	</haxe_doc>
		</match>
		<new public="1" line="54">
			<f a="?_rules">
				<t path="Iterable"><t path="xinf.style.StyleRule"/></t>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Create a new StyleSheet, either empty or filled
		with the rules given in [rules]. 
	</haxe_doc>
		</new>
		<haxe_doc>
	A CSS-like stylesheet.
	
	DOCME:
	Best, describe where xinf (still) lacks from CSS-2.
	
	$CSS cover CSS 2 Specification$
</haxe_doc>
	</class>
	<class path="xinf.erno.Pen" params="" file="../../../xinf/src/xinf/erno/PenRenderer.hx" module="xinf.erno.PenRenderer">
		<fill public="1">
			<e path="xinf.erno.Paint"/>
			<haxe_doc>
		current fill color, may be [null].
	</haxe_doc>
		</fill>
		<stroke public="1"><e path="xinf.erno.Paint"/></stroke>
		<width public="1"><c path="Float"/></width>
		<caps public="1"><c path="Int"/></caps>
		<join public="1"><c path="Int"/></join>
		<miterLimit public="1"><c path="Float"/></miterLimit>
		<dashArray public="1"><c path="Array"><c path="Int"/></c></dashArray>
		<dashOffset public="1"><c path="Int"/></dashOffset>
		<clone public="1" line="37">
			<f a=""><c path="xinf.erno.Pen"/></f>
			<haxe_doc>
		return a new Pen structure with the same properties as this Pen.
	</haxe_doc>
		</clone>
		<new public="1" line="31">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		constructor, initializes a new Pen structure with default values.
	</haxe_doc>
		</new>
		<haxe_doc>
	A Pen structure keeps the style with which to draw graphic objects
	for a $xinf.erno.PenRenderer$. There should
	be no need to use this structure, except if you implement
	your own Renderer that derives from PenRenderer.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<typedef path="Iterator" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next><f a=""><c path="Iterator.T"/></f></next>
			<hasNext><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Program Files\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<typedef path="neko.FileStat" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/FileSystem.hx" module="neko.FileSystem"><a>
	<uid><c path="Int"/></uid>
	<size><c path="Int"/></size>
	<rdev><c path="Int"/></rdev>
	<nlink><c path="Int"/></nlink>
	<mtime><c path="Date"/></mtime>
	<mode><c path="Int"/></mode>
	<ino><c path="Int"/></ino>
	<gid><c path="Int"/></gid>
	<dev><c path="Int"/></dev>
	<ctime><c path="Date"/></ctime>
	<atime><c path="Date"/></atime>
</a></typedef>
	<enum path="neko.FileKind" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/FileSystem.hx" module="neko.FileSystem">
		<kother a="k"><c path="String"/></kother>
		<kfile/>
		<kdir/>
	</enum>
	<class path="xinf.ony.erno.LinearGradient" params="" file="../../../xinf/src/xinf/ony/erno/LinearGradient.hx">
		<extends path="xinf.ony.LinearGradient"/>
		<implements path="xinf.ony.erno.PaintServer"/>
		<getPaint public="1" line="19"><f a="target">
	<c path="xinf.ony.Element"/>
	<e path="xinf.erno.Paint"/>
</f></getPaint>
		<new public="1" line="17"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.geom.Identity" params="" file="../../../xinf/src/xinf/geom/Identity.hx">
		<implements path="xinf.geom.Transform"/>
		<getTranslation public="1" line="13"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getTranslation>
		<getScale public="1" line="16"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getScale>
		<getMatrix public="1" line="19"><f a=""><a>
	<ty><c path="Float"/></ty>
	<tx><c path="Float"/></tx>
	<d><c path="Float"/></d>
	<c><c path="Float"/></c>
	<b><c path="Float"/></b>
	<a><c path="Float"/></a>
</a></f></getMatrix>
		<apply public="1" line="23"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1" line="26"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<interpolateWith public="1" line="30"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1" line="35"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1" line="40"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1" line="44"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
		<toString public="1" line="48"><f a=""><c path="String"/></f></toString>
		<new public="1" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="haxe.io.Error" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="xinf.geom.Concatenate" params="" file="../../../xinf/src/xinf/geom/Concatenate.hx">
		<implements path="xinf.geom.Transform"/>
		<a><c path="xinf.geom.Transform"/></a>
		<b><c path="xinf.geom.Transform"/></b>
		<getTranslation public="1" line="17"><f a=""><t path="xinf.geom.TPoint"/></f></getTranslation>
		<getScale public="1" line="20"><f a=""><t path="xinf.geom.TPoint"/></f></getScale>
		<getMatrix public="1" line="23"><f a=""><t path="xinf.geom.TMatrix"/></f></getMatrix>
		<apply public="1" line="28"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1" line="31"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<interpolateWith public="1" line="35"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1" line="39"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1" line="43"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1" line="47"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
		<toString public="1" line="52"><f a=""><c path="String"/></f></toString>
		<new public="1" line="12"><f a="a:b">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neko.net.Host" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/net/Host.hx">
		<localhost public="1" line="45" static="1"><f a=""><c path="String"/></f></localhost>
		<host_resolve line="53" static="1"><f a="">
	<unknown/>
	<c path="haxe.Int32"/>
</f></host_resolve>
		<host_reverse line="54" static="1"><f a="">
	<c path="haxe.Int32"/>
	<c path="String"/>
</f></host_reverse>
		<host_to_string line="55" static="1"><f a="">
	<c path="haxe.Int32"/>
	<c path="String"/>
</f></host_to_string>
		<host_local line="56" static="1"><f a=""><c path="String"/></f></host_local>
		<ip public="1" set="null"><c path="haxe.Int32"/></ip>
		<toString public="1" line="37"><f a=""><c path="String"/></f></toString>
		<reverse public="1" line="41"><f a=""><c path="String"/></f></reverse>
		<new public="1" line="33"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Text" params="" file="../../../xinf/src/xinf/ony/erno/Text.hx">
		<extends path="xinf.ony.Text"/>
		<format><c path="xinf.erno.TextFormat"/></format>
		<assureFormat line="24"><f a=""><e path="Void"/></f></assureFormat>
		<alignment line="52"><f a=""><c path="Float"/></f></alignment>
		<new public="1" line="15"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="xinf.inity.ColorSpace" params="" file="../../../xinf/src/xinf/inity/ColorSpace.hx">
		<RGBA/>
		<RGB/>
		<Other a="depth:channels">
			<c path="Int"/>
			<c path="Int"/>
		</Other>
		<GRAY/>
		<BGRA/>
		<BGR/>
		<ALPHA/>
	</enum>
	<class path="xinf.inity.ColorSpaceTools" params="" file="../../../xinf/src/xinf/inity/ColorSpace.hx" module="xinf.inity.ColorSpace"><defaultBytesPerRow public="1" line="18" static="1"><f a="cs:width">
	<e path="xinf.inity.ColorSpace"/>
	<c path="Int"/>
	<c path="Int"/>
</f></defaultBytesPerRow></class>
	<class path="org.puremvc.haxe.multicore.core.Model" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/core/Model.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IModel"/>
		<getInstance public="1" line="57" static="1">
			<f a="key">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IModel"/>
			</f>
			<haxe_doc>
	 * [Model] Multiton Factory method.
	 </haxe_doc>
		</getInstance>
		<instanceMap static="1"><c path="Hash"><c path="org.puremvc.haxe.multicore.interfaces.IModel"/></c></instanceMap>
		<initializeModel line="50">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Initialize the Singleton [Model] instance.
	 * 
	 * <p>Called automatically by the constructor, this is your opportunity to initialize the Singleton
	 * instance in your subclass without overriding the constructor.</p>
	 ]]></haxe_doc>
		</initializeModel>
		<registerProxy public="1" line="67">
			<f a="proxy">
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register an [IProxy] with the [Model].
	 </haxe_doc>
		</registerProxy>
		<retrieveProxy public="1" line="77">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>
	 * Retrieve an [IProxy] from the [Model].
	 </haxe_doc>
		</retrieveProxy>
		<hasProxy public="1" line="85">
			<f a="proxyName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a [Proxy] is registered
	 </haxe_doc>
		</hasProxy>
		<removeProxy public="1" line="93">
			<f a="proxyName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IProxy"/>
			</f>
			<haxe_doc>
	 * Remove an [IProxy] from the [Model].
	 </haxe_doc>
		</removeProxy>
		<removeModel public="1" line="107">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove an IModel instance
	 </haxe_doc>
		</removeModel>
		<proxyMap><c path="Hash"><c path="org.puremvc.haxe.multicore.interfaces.IProxy"/></c></proxyMap>
		<multitonKey><c path="String"/></multitonKey>
		<new line="36">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Constructor. 
	 * 
	 * <p>This [IModel] implementation is a Multiton,
	 * so you should not call the constructor 
	 * directly, but instead call the static Multiton
	 * Factory method [Model.getInstance( multitonKey )]</p>
	 ]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * A Singleton [IModel] implementation.
 * 
 * <p>In PureMVC, the [Model] class provides access to model objects (Proxies) by named lookup.</p> 
 * 
 * <p>The [Model] assumes these responsibilities:</p>
 * <ul>
 * <li>Maintain a cache of [IProxy] instances.</li>
 * <li>Provide methods for registering, retrieving, and removing [IProxy] instances.</li>
 * </ul>
 * 
 * <p>Your application must register [IProxy] instances with the [Model]. Typically, you use an 
 * [ICommand] to create and register [IProxy] instances once the [Facade] has initialized the Core 
 * actors.</p>
 ]]></haxe_doc>
	</class>
	<class path="xinf.ony.Svg" params="" file="../../../xinf/src/xinf/ony/Svg.hx">
		<extends path="xinf.ony.erno.Group"/>
		<TRAITS line="17" static="1"><a>
	<y><c path="xinf.traits.FloatTrait"/></y>
	<x><c path="xinf.traits.FloatTrait"/></x>
	<width><c path="xinf.ony.traits.LengthTrait"/></width>
	<height><c path="xinf.ony.traits.LengthTrait"/></height>
</a></TRAITS>
		<tagName line="24" static="1"><c path="String"/></tagName>
		<x public="1" get="dynamic" set="dynamic"><c path="Float"/></x>
		<get_x line="27"><f a=""><c path="Float"/></f></get_x>
		<set_x line="28"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_x>
		<y public="1" get="dynamic" set="dynamic"><c path="Float"/></y>
		<get_y line="31"><f a=""><c path="Float"/></f></get_y>
		<set_y line="32"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_y>
		<width public="1" get="dynamic" set="dynamic"><c path="Float"/></width>
		<get_width line="35"><f a=""><c path="Float"/></f></get_width>
		<set_width line="36"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_width>
		<height public="1" get="dynamic" set="dynamic"><c path="Float"/></height>
		<get_height line="39"><f a=""><c path="Float"/></f></get_height>
		<set_height line="40"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></set_height>
		<new public="1" line="15"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe._Http.AbstractSocket" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/Http.hx" private="1" module="haxe.Http"><a>
	<write><f a="str">
	<c path="String"/>
	<e path="Void"/>
</f></write>
	<shutdown><f a="read:write">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></shutdown>
	<setTimeout><f a="t">
	<c path="Float"/>
	<e path="Void"/>
</f></setTimeout>
	<output><c path="haxe.io.Output"/></output>
	<input><c path="haxe.io.Input"/></input>
	<connect><f a="host:port">
	<c path="neko.net.Host"/>
	<c path="Int"/>
	<e path="Void"/>
</f></connect>
	<close><f a=""><e path="Void"/></f></close>
</a></typedef>
	<class path="haxe.Http" params="" file="C:\Program Files\Motion-Twin\haxe/std/haxe/Http.hx">
		<PROXY public="1" line="66" static="1"><a>
	<port><c path="Int"/></port>
	<host><c path="String"/></host>
	<auth><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></auth>
</a></PROXY>
		<request public="1" line="613" static="1"><f a="url">
	<c path="String"/>
	<c path="String"/>
</f></request>
		<url public="1"><c path="String"/></url>
		<noShutdown public="1"><e path="Bool"/></noShutdown>
		<cnxTimeout public="1"><c path="Float"/></cnxTimeout>
		<responseHeaders><c path="Hash"><c path="String"/></c></responseHeaders>
		<postData><c path="String"/></postData>
		<chunk_size><c path="Int"/></chunk_size>
		<chunk_buf><c path="haxe.io.Bytes"/></chunk_buf>
		<file><a>
	<size><c path="Int"/></size>
	<param><c path="String"/></param>
	<io><c path="haxe.io.Input"/></io>
	<filename><c path="String"/></filename>
</a></file>
		<headers><c path="Hash"><c path="String"/></c></headers>
		<params><c path="Hash"><c path="String"/></c></params>
		<setHeader public="1" line="83"><f a="header:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setHeader>
		<setParameter public="1" line="87"><f a="param:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setParameter>
		<setPostData public="1" line="92"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></setPostData>
		<request public="1" line="97"><f a="post">
	<e path="Bool"/>
	<e path="Void"/>
</f></request>
		<fileTransfert public="1" line="259"><f a="argname:filename:file:size">
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></fileTransfert>
		<customRequest public="1" line="263"><f a="post:api:?sock:?method">
	<e path="Bool"/>
	<c path="haxe.io.Output"/>
	<t path="haxe._Http.AbstractSocket"/>
	<c path="String"/>
	<e path="Void"/>
</f></customRequest>
		<readHttpResponse line="408"><f a="api:sock">
	<c path="haxe.io.Output"/>
	<t path="haxe._Http.AbstractSocket"/>
	<e path="Void"/>
</f></readHttpResponse>
		<readChunk line="541"><f a="chunk_re:api:buf:len">
	<c path="EReg"/>
	<c path="haxe.io.Output"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></readChunk>
		<onData public="1" line="600"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></onData>
		<onError public="1" line="603"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></onError>
		<onStatus public="1" line="606"><f a="status">
	<c path="Int"/>
	<e path="Void"/>
</f></onStatus>
		<new public="1" line="69"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.geom.SkewX" params="" file="../../../xinf/src/xinf/geom/SkewX.hx">
		<implements path="xinf.geom.Transform"/>
		<a><c path="Float"/></a>
		<getTranslation public="1" line="15"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getTranslation>
		<getScale public="1" line="18"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getScale>
		<getMatrix public="1" line="21"><f a=""><a>
	<ty><c path="Float"/></ty>
	<tx><c path="Float"/></tx>
	<d><c path="Float"/></d>
	<c><c path="Float"/></c>
	<b><c path="Float"/></b>
	<a><c path="Float"/></a>
</a></f></getMatrix>
		<apply public="1" line="25"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1" line="28"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<interpolateWith public="1" line="32"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1" line="39"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1" line="46"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1" line="50"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
		<toString public="1" line="58"><f a=""><c path="String"/></f></toString>
		<new public="1" line="11"><f a="a">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.demos.xinf.stopwatch.controller.StopTimerCommand" params="" file="../src-multicore/org/puremvc/haxe/multicore/demos/xinf/stopwatch/controller/StopTimerCommand.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.command.SimpleCommand"/>
		<new public="1" line="13"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="xinf.ony.erno.Use" params="" file="../../../xinf/src/xinf/ony/erno/Use.hx">
		<extends path="xinf.ony.Use"/>
		<clone><t path="xinf.ony.ElementImpl"/></clone>
		<wrapper><t path="Null"><c path="Int"/></t></wrapper>
		<cycleLock><e path="Bool"/></cycleLock>
		<new public="1" line="15"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.Link" params="" file="../../../xinf/src/xinf/ony/Link.hx">
		<extends path="xinf.ony.erno.Group"/>
		<tagName line="13" static="1"><c path="String"/></tagName>
		<TRAITS line="15" static="1"><a><href><c path="xinf.traits.StringTrait"/></href></a></TRAITS>
		<href public="1" get="dynamic" set="dynamic"><c path="String"/></href>
		<get_href line="20"><f a=""><c path="String"/></f></get_href>
		<set_href line="21"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></set_href>
		<onActivate public="1" line="28"><f a="e">
	<c path="xinf.event.UIEvent"/>
	<e path="Void"/>
</f></onActivate>
		<new public="1" line="23"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="xinf.ony.erno.Svg" params="" file="../../../xinf/src/xinf/ony/erno/Svg.hx">
		<extends path="xinf.ony.Svg"/>
		<new public="1" line="16"><f a="?traits">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="xinf.ony.erno.FlowElement" params="" file="../../../xinf/src/xinf/ony/erno/TextArea.hx" module="xinf.ony.erno.TextArea">
		<Word a="t"><c path="String"/></Word>
		<Whitespace a="t"><c path="String"/></Whitespace>
		<Return/>
		<FormatChange a="f"><c path="xinf.erno.TextFormat"/></FormatChange>
	</enum>
	<typedef path="xinf.ony.erno.TextLine" params="" file="../../../xinf/src/xinf/ony/erno/TextArea.hx" module="xinf.ony.erno.TextArea"><a>
	<text><c path="String"/></text>
	<offset><c path="Int"/></offset>
</a></typedef>
	<enum path="neko.vm.LoaderHandle" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/vm/Loader.hx" module="neko.vm.Loader"><haxe_doc>
	The Neko object that implements the loader.
</haxe_doc></enum>
	<class path="neko.vm.Loader" params="" file="C:\Program Files\Motion-Twin\haxe/std/neko/vm/Loader.hx">
		<local public="1" line="140" static="1">
			<f a=""><c path="neko.vm.Loader"/></f>
			<haxe_doc>
		Returns the local Loader. This is the loader that was used to load the
		module in which the code is defined.
	</haxe_doc>
		</local>
		<make public="1" line="148" static="1">
			<f a="loadPrim:loadModule">
				<f a=":">
					<c path="String"/>
					<c path="Int"/>
					<d/>
				</f>
				<f a=":">
					<c path="String"/>
					<c path="neko.vm.Loader"/>
					<c path="neko.vm.Module"/>
				</f>
				<c path="neko.vm.Loader"/>
			</f>
			<haxe_doc>
		Creates a loader using two methods. This loader will not have an accessible cache or path,
		although you can implement such mecanism in the methods body.
	</haxe_doc>
		</make>
		<l public="1">
			<e path="neko.vm.LoaderHandle"/>
			<haxe_doc>
		The abstract handle.
	</haxe_doc>
		</l>
		<getPath public="1" line="64">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>
		The default loader contains a search path in its [path] field. It's a
		linked list of Neko strings that is a parsed version of the [NEKOPATH].
		This path is used to lookup for modules and libraries.
	</haxe_doc>
		</getPath>
		<addPath public="1" line="77">
			<f a="s">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a directory to the search path. See [getPath]
	</haxe_doc>
		</addPath>
		<getCache public="1" line="88">
			<f a=""><c path="Hash"><c path="neko.vm.Module"/></c></f>
			<haxe_doc>
		The default loader contains a cache of already loaded modules. It's
		ensuring that the same module does not get loaded twice when circular
		references are occuring. The same module can eventually be loaded twice
		but with different names, for example with two relatives paths reprensenting
		the same file, since the cache is done on a by-name basic.
	</haxe_doc>
		</getCache>
		<setCache public="1" line="99">
			<f a="name:m">
				<c path="String"/>
				<c path="neko.vm.Module"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a module in the loader cache.
	</haxe_doc>
		</setCache>
		<backupCache public="1" line="107">
			<f a="c">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Change the cache value and returns the old value. This can be used
		to backup the loader cache and restore it later.
	</haxe_doc>
		</backupCache>
		<__compare line="113"><f a="other">
	<c path="neko.vm.Loader"/>
	<unknown/>
</f></__compare>
		<loadPrimitive public="1" line="122">
			<f a="prim:nargs">
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
		Loads a neko primitive. By default, the name is of the form [library@method].
		The primitive might not be used directly in haXe since some of the Neko values
		needs an object wrapper in haXe.
	</haxe_doc>
		</loadPrimitive>
		<loadModule public="1" line="131">
			<f a="modName:?loader">
				<c path="String"/>
				<c path="neko.vm.Loader"/>
				<c path="neko.vm.Module"/>
			</f>
			<haxe_doc>
		Loads a Module with the given name. If [loader] is defined, this will be
		this Module loader, else this loader will be inherited. When loaded this
		way, the module is directly executed.
	</haxe_doc>
		</loadModule>
		<new public="1" line="55"><f a="l">
	<e path="neko.vm.LoaderHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Loaders can be used to dynamicly load Neko primitives stored in NDLL libraries.


	Loaders can be used to dynamicly load other Neko modules (.n bytecode files).
	Modules are referenced by names. To lookup the corresponding bytecode file, the
	default loader first look in its cache, then eventually adds the .n extension
	to the name and lookup the bytecode in its path.


	Loaders can be used for sandbox security. When a Module is loaded with a given
	Loader, this loader can manager the module security by filtering which
	primitives can be loaded by this module or by rewrapping them at loading-time
	with custom securized versions. Loaders are inherited in loaded submodules.
</haxe_doc>
	</class>
	<class path="openvg.VG" params="" file="../../../xinf/src/libs/openvg/api/openvg/VG.hx" extern="1">
		<NO_ERROR public="1" static="1"><c path="Int"/></NO_ERROR>
		<BAD_HANDLE_ERROR public="1" static="1"><c path="Int"/></BAD_HANDLE_ERROR>
		<ILLEGAL_ARGUMENT_ERROR public="1" static="1"><c path="Int"/></ILLEGAL_ARGUMENT_ERROR>
		<OUT_OF_MEMORY_ERROR public="1" static="1"><c path="Int"/></OUT_OF_MEMORY_ERROR>
		<PATH_CAPABILITY_ERROR public="1" static="1"><c path="Int"/></PATH_CAPABILITY_ERROR>
		<UNSUPPORTED_IMAGE_FORMAT_ERROR public="1" static="1"><c path="Int"/></UNSUPPORTED_IMAGE_FORMAT_ERROR>
		<UNSUPPORTED_PATH_FORMAT_ERROR public="1" static="1"><c path="Int"/></UNSUPPORTED_PATH_FORMAT_ERROR>
		<IMAGE_IN_USE_ERROR public="1" static="1"><c path="Int"/></IMAGE_IN_USE_ERROR>
		<NO_CONTEXT_ERROR public="1" static="1"><c path="Int"/></NO_CONTEXT_ERROR>
		<MATRIX_MODE public="1" static="1"><c path="Int"/></MATRIX_MODE>
		<FILL_RULE public="1" static="1"><c path="Int"/></FILL_RULE>
		<IMAGE_QUALITY public="1" static="1"><c path="Int"/></IMAGE_QUALITY>
		<RENDERING_QUALITY public="1" static="1"><c path="Int"/></RENDERING_QUALITY>
		<BLEND_MODE public="1" static="1"><c path="Int"/></BLEND_MODE>
		<IMAGE_MODE public="1" static="1"><c path="Int"/></IMAGE_MODE>
		<SCISSOR_RECTS public="1" static="1"><c path="Int"/></SCISSOR_RECTS>
		<STROKE_LINE_WIDTH public="1" static="1"><c path="Int"/></STROKE_LINE_WIDTH>
		<STROKE_CAP_STYLE public="1" static="1"><c path="Int"/></STROKE_CAP_STYLE>
		<STROKE_JOIN_STYLE public="1" static="1"><c path="Int"/></STROKE_JOIN_STYLE>
		<STROKE_MITER_LIMIT public="1" static="1"><c path="Int"/></STROKE_MITER_LIMIT>
		<STROKE_DASH_PATTERN public="1" static="1"><c path="Int"/></STROKE_DASH_PATTERN>
		<STROKE_DASH_PHASE public="1" static="1"><c path="Int"/></STROKE_DASH_PHASE>
		<STROKE_DASH_PHASE_RESET public="1" static="1"><c path="Int"/></STROKE_DASH_PHASE_RESET>
		<TILE_FILL_COLOR public="1" static="1"><c path="Int"/></TILE_FILL_COLOR>
		<CLEAR_COLOR public="1" static="1"><c path="Int"/></CLEAR_COLOR>
		<MASKING public="1" static="1"><c path="Int"/></MASKING>
		<SCISSORING public="1" static="1"><c path="Int"/></SCISSORING>
		<PIXEL_LAYOUT public="1" static="1"><c path="Int"/></PIXEL_LAYOUT>
		<SCREEN_LAYOUT public="1" static="1"><c path="Int"/></SCREEN_LAYOUT>
		<FILTER_FORMAT_LINEAR public="1" static="1"><c path="Int"/></FILTER_FORMAT_LINEAR>
		<FILTER_FORMAT_PREMULTIPLIED public="1" static="1"><c path="Int"/></FILTER_FORMAT_PREMULTIPLIED>
		<FILTER_CHANNEL_MASK public="1" static="1"><c path="Int"/></FILTER_CHANNEL_MASK>
		<MAX_SCISSOR_RECTS public="1" static="1"><c path="Int"/></MAX_SCISSOR_RECTS>
		<MAX_DASH_COUNT public="1" static="1"><c path="Int"/></MAX_DASH_COUNT>
		<MAX_KERNEL_SIZE public="1" static="1"><c path="Int"/></MAX_KERNEL_SIZE>
		<MAX_SEPARABLE_KERNEL_SIZE public="1" static="1"><c path="Int"/></MAX_SEPARABLE_KERNEL_SIZE>
		<MAX_COLOR_RAMP_STOPS public="1" static="1"><c path="Int"/></MAX_COLOR_RAMP_STOPS>
		<MAX_IMAGE_WIDTH public="1" static="1"><c path="Int"/></MAX_IMAGE_WIDTH>
		<MAX_IMAGE_HEIGHT public="1" static="1"><c path="Int"/></MAX_IMAGE_HEIGHT>
		<MAX_IMAGE_PIXELS public="1" static="1"><c path="Int"/></MAX_IMAGE_PIXELS>
		<MAX_IMAGE_BYTES public="1" static="1"><c path="Int"/></MAX_IMAGE_BYTES>
		<MAX_FLOAT public="1" static="1"><c path="Int"/></MAX_FLOAT>
		<MAX_GAUSSIAN_STD_DEVIATION public="1" static="1"><c path="Int"/></MAX_GAUSSIAN_STD_DEVIATION>
		<RENDERING_QUALITY_NONANTIALIASED public="1" static="1"><c path="Int"/></RENDERING_QUALITY_NONANTIALIASED>
		<RENDERING_QUALITY_FASTER public="1" static="1"><c path="Int"/></RENDERING_QUALITY_FASTER>
		<RENDERING_QUALITY_BETTER public="1" static="1"><c path="Int"/></RENDERING_QUALITY_BETTER>
		<PIXEL_LAYOUT_UNKNOWN public="1" static="1"><c path="Int"/></PIXEL_LAYOUT_UNKNOWN>
		<PIXEL_LAYOUT_RGB_VERTICAL public="1" static="1"><c path="Int"/></PIXEL_LAYOUT_RGB_VERTICAL>
		<PIXEL_LAYOUT_BGR_VERTICAL public="1" static="1"><c path="Int"/></PIXEL_LAYOUT_BGR_VERTICAL>
		<PIXEL_LAYOUT_RGB_HORIZONTAL public="1" static="1"><c path="Int"/></PIXEL_LAYOUT_RGB_HORIZONTAL>
		<PIXEL_LAYOUT_BGR_HORIZONTAL public="1" static="1"><c path="Int"/></PIXEL_LAYOUT_BGR_HORIZONTAL>
		<MATRIX_PATH_USER_TO_SURFACE public="1" static="1"><c path="Int"/></MATRIX_PATH_USER_TO_SURFACE>
		<MATRIX_IMAGE_USER_TO_SURFACE public="1" static="1"><c path="Int"/></MATRIX_IMAGE_USER_TO_SURFACE>
		<MATRIX_STROKE_PAINT_TO_USER public="1" static="1"><c path="Int"/></MATRIX_STROKE_PAINT_TO_USER>
		<MATRIX_FILL_PAINT_TO_USER public="1" static="1"><c path="Int"/></MATRIX_FILL_PAINT_TO_USER>
		<CLEAR_MASK public="1" static="1"><c path="Int"/></CLEAR_MASK>
		<FILL_MASK public="1" static="1"><c path="Int"/></FILL_MASK>
		<SET_MASK public="1" static="1"><c path="Int"/></SET_MASK>
		<UNION_MASK public="1" static="1"><c path="Int"/></UNION_MASK>
		<INTERSECT_MASK public="1" static="1"><c path="Int"/></INTERSECT_MASK>
		<SUBTRACT_MASK public="1" static="1"><c path="Int"/></SUBTRACT_MASK>
		<PATH_DATATYPE_S_8 public="1" static="1"><c path="Int"/></PATH_DATATYPE_S_8>
		<PATH_DATATYPE_S_16 public="1" static="1"><c path="Int"/></PATH_DATATYPE_S_16>
		<PATH_DATATYPE_S_32 public="1" static="1"><c path="Int"/></PATH_DATATYPE_S_32>
		<PATH_DATATYPE_F public="1" static="1"><c path="Int"/></PATH_DATATYPE_F>
		<ABSOLUTE public="1" static="1"><c path="Int"/></ABSOLUTE>
		<RELATIVE public="1" static="1"><c path="Int"/></RELATIVE>
		<CLOSE_PATH public="1" static="1"><c path="Int"/></CLOSE_PATH>
		<MOVE_TO public="1" static="1"><c path="Int"/></MOVE_TO>
		<LINE_TO public="1" static="1"><c path="Int"/></LINE_TO>
		<HLINE_TO public="1" static="1"><c path="Int"/></HLINE_TO>
		<VLINE_TO public="1" static="1"><c path="Int"/></VLINE_TO>
		<QUAD_TO public="1" static="1"><c path="Int"/></QUAD_TO>
		<CUBIC_TO public="1" static="1"><c path="Int"/></CUBIC_TO>
		<SQUAD_TO public="1" static="1"><c path="Int"/></SQUAD_TO>
		<SCUBIC_TO public="1" static="1"><c path="Int"/></SCUBIC_TO>
		<SCCWARC_TO public="1" static="1"><c path="Int"/></SCCWARC_TO>
		<SCWARC_TO public="1" static="1"><c path="Int"/></SCWARC_TO>
		<LCCWARC_TO public="1" static="1"><c path="Int"/></LCCWARC_TO>
		<LCWARC_TO public="1" static="1"><c path="Int"/></LCWARC_TO>
		<MOVE_TO_ABS public="1" static="1"><c path="Int"/></MOVE_TO_ABS>
		<MOVE_TO_REL public="1" static="1"><c path="Int"/></MOVE_TO_REL>
		<LINE_TO_ABS public="1" static="1"><c path="Int"/></LINE_TO_ABS>
		<LINE_TO_REL public="1" static="1"><c path="Int"/></LINE_TO_REL>
		<HLINE_TO_ABS public="1" static="1"><c path="Int"/></HLINE_TO_ABS>
		<HLINE_TO_REL public="1" static="1"><c path="Int"/></HLINE_TO_REL>
		<VLINE_TO_ABS public="1" static="1"><c path="Int"/></VLINE_TO_ABS>
		<VLINE_TO_REL public="1" static="1"><c path="Int"/></VLINE_TO_REL>
		<QUAD_TO_ABS public="1" static="1"><c path="Int"/></QUAD_TO_ABS>
		<QUAD_TO_REL public="1" static="1"><c path="Int"/></QUAD_TO_REL>
		<CUBIC_TO_ABS public="1" static="1"><c path="Int"/></CUBIC_TO_ABS>
		<CUBIC_TO_REL public="1" static="1"><c path="Int"/></CUBIC_TO_REL>
		<SQUAD_TO_ABS public="1" static="1"><c path="Int"/></SQUAD_TO_ABS>
		<SQUAD_TO_REL public="1" static="1"><c path="Int"/></SQUAD_TO_REL>
		<SCUBIC_TO_ABS public="1" static="1"><c path="Int"/></SCUBIC_TO_ABS>
		<SCUBIC_TO_REL public="1" static="1"><c path="Int"/></SCUBIC_TO_REL>
		<SCCWARC_TO_ABS public="1" static="1"><c path="Int"/></SCCWARC_TO_ABS>
		<SCCWARC_TO_REL public="1" static="1"><c path="Int"/></SCCWARC_TO_REL>
		<SCWARC_TO_ABS public="1" static="1"><c path="Int"/></SCWARC_TO_ABS>
		<SCWARC_TO_REL public="1" static="1"><c path="Int"/></SCWARC_TO_REL>
		<LCCWARC_TO_ABS public="1" static="1"><c path="Int"/></LCCWARC_TO_ABS>
		<LCCWARC_TO_REL public="1" static="1"><c path="Int"/></LCCWARC_TO_REL>
		<LCWARC_TO_ABS public="1" static="1"><c path="Int"/></LCWARC_TO_ABS>
		<LCWARC_TO_REL public="1" static="1"><c path="Int"/></LCWARC_TO_REL>
		<PATH_CAPABILITY_APPEND_FROM public="1" static="1"><c path="Int"/></PATH_CAPABILITY_APPEND_FROM>
		<PATH_CAPABILITY_APPEND_TO public="1" static="1"><c path="Int"/></PATH_CAPABILITY_APPEND_TO>
		<PATH_CAPABILITY_MODIFY public="1" static="1"><c path="Int"/></PATH_CAPABILITY_MODIFY>
		<PATH_CAPABILITY_TRANSFORM_FROM public="1" static="1"><c path="Int"/></PATH_CAPABILITY_TRANSFORM_FROM>
		<PATH_CAPABILITY_TRANSFORM_TO public="1" static="1"><c path="Int"/></PATH_CAPABILITY_TRANSFORM_TO>
		<PATH_CAPABILITY_INTERPOLATE_FROM public="1" static="1"><c path="Int"/></PATH_CAPABILITY_INTERPOLATE_FROM>
		<PATH_CAPABILITY_INTERPOLATE_TO public="1" static="1"><c path="Int"/></PATH_CAPABILITY_INTERPOLATE_TO>
		<PATH_CAPABILITY_PATH_LENGTH public="1" static="1"><c path="Int"/></PATH_CAPABILITY_PATH_LENGTH>
		<PATH_CAPABILITY_POINT_ALONG_PATH public="1" static="1"><c path="Int"/></PATH_CAPABILITY_POINT_ALONG_PATH>
		<PATH_CAPABILITY_TANGENT_ALONG_PATH public="1" static="1"><c path="Int"/></PATH_CAPABILITY_TANGENT_ALONG_PATH>
		<PATH_CAPABILITY_PATH_BOUNDS public="1" static="1"><c path="Int"/></PATH_CAPABILITY_PATH_BOUNDS>
		<PATH_CAPABILITY_PATH_TRANSFORMED_BOUNDS public="1" static="1"><c path="Int"/></PATH_CAPABILITY_PATH_TRANSFORMED_BOUNDS>
		<PATH_CAPABILITY_ALL public="1" static="1"><c path="Int"/></PATH_CAPABILITY_ALL>
		<PATH_FORMAT public="1" static="1"><c path="Int"/></PATH_FORMAT>
		<PATH_DATATYPE public="1" static="1"><c path="Int"/></PATH_DATATYPE>
		<PATH_SCALE public="1" static="1"><c path="Int"/></PATH_SCALE>
		<PATH_BIAS public="1" static="1"><c path="Int"/></PATH_BIAS>
		<PATH_NUM_SEGMENTS public="1" static="1"><c path="Int"/></PATH_NUM_SEGMENTS>
		<PATH_NUM_COORDS public="1" static="1"><c path="Int"/></PATH_NUM_COORDS>
		<CAP_BUTT public="1" static="1"><c path="Int"/></CAP_BUTT>
		<CAP_ROUND public="1" static="1"><c path="Int"/></CAP_ROUND>
		<CAP_SQUARE public="1" static="1"><c path="Int"/></CAP_SQUARE>
		<JOIN_MITER public="1" static="1"><c path="Int"/></JOIN_MITER>
		<JOIN_ROUND public="1" static="1"><c path="Int"/></JOIN_ROUND>
		<JOIN_BEVEL public="1" static="1"><c path="Int"/></JOIN_BEVEL>
		<EVEN_ODD public="1" static="1"><c path="Int"/></EVEN_ODD>
		<NON_ZERO public="1" static="1"><c path="Int"/></NON_ZERO>
		<STROKE_PATH public="1" static="1"><c path="Int"/></STROKE_PATH>
		<FILL_PATH public="1" static="1"><c path="Int"/></FILL_PATH>
		<PAINT_TYPE public="1" static="1"><c path="Int"/></PAINT_TYPE>
		<PAINT_COLOR public="1" static="1"><c path="Int"/></PAINT_COLOR>
		<PAINT_COLOR_RAMP_SPREAD_MODE public="1" static="1"><c path="Int"/></PAINT_COLOR_RAMP_SPREAD_MODE>
		<PAINT_COLOR_RAMP_PREMULTIPLIED public="1" static="1"><c path="Int"/></PAINT_COLOR_RAMP_PREMULTIPLIED>
		<PAINT_COLOR_RAMP_STOPS public="1" static="1"><c path="Int"/></PAINT_COLOR_RAMP_STOPS>
		<PAINT_LINEAR_GRADIENT public="1" static="1"><c path="Int"/></PAINT_LINEAR_GRADIENT>
		<PAINT_RADIAL_GRADIENT public="1" static="1"><c path="Int"/></PAINT_RADIAL_GRADIENT>
		<PAINT_PATTERN_TILING_MODE public="1" static="1"><c path="Int"/></PAINT_PATTERN_TILING_MODE>
		<PAINT_TYPE_COLOR public="1" static="1"><c path="Int"/></PAINT_TYPE_COLOR>
		<PAINT_TYPE_LINEAR_GRADIENT public="1" static="1"><c path="Int"/></PAINT_TYPE_LINEAR_GRADIENT>
		<PAINT_TYPE_RADIAL_GRADIENT public="1" static="1"><c path="Int"/></PAINT_TYPE_RADIAL_GRADIENT>
		<PAINT_TYPE_PATTERN public="1" static="1"><c path="Int"/></PAINT_TYPE_PATTERN>
		<COLOR_RAMP_SPREAD_PAD public="1" static="1"><c path="Int"/></COLOR_RAMP_SPREAD_PAD>
		<COLOR_RAMP_SPREAD_REPEAT public="1" static="1"><c path="Int"/></COLOR_RAMP_SPREAD_REPEAT>
		<COLOR_RAMP_SPREAD_REFLECT public="1" static="1"><c path="Int"/></COLOR_RAMP_SPREAD_REFLECT>
		<TILE_FILL public="1" static="1"><c path="Int"/></TILE_FILL>
		<TILE_PAD public="1" static="1"><c path="Int"/></TILE_PAD>
		<TILE_REPEAT public="1" static="1"><c path="Int"/></TILE_REPEAT>
		<TILE_REFLECT public="1" static="1"><c path="Int"/></TILE_REFLECT>
		<sRGBX_8888 public="1" static="1"><c path="Int"/></sRGBX_8888>
		<sRGBA_8888 public="1" static="1"><c path="Int"/></sRGBA_8888>
		<sRGBA_8888_PRE public="1" static="1"><c path="Int"/></sRGBA_8888_PRE>
		<sRGB_565 public="1" static="1"><c path="Int"/></sRGB_565>
		<sRGBA_5551 public="1" static="1"><c path="Int"/></sRGBA_5551>
		<sRGBA_4444 public="1" static="1"><c path="Int"/></sRGBA_4444>
		<sL_8 public="1" static="1"><c path="Int"/></sL_8>
		<lRGBX_8888 public="1" static="1"><c path="Int"/></lRGBX_8888>
		<lRGBA_8888 public="1" static="1"><c path="Int"/></lRGBA_8888>
		<lRGBA_8888_PRE public="1" static="1"><c path="Int"/></lRGBA_8888_PRE>
		<lL_8 public="1" static="1"><c path="Int"/></lL_8>
		<A_8 public="1" static="1"><c path="Int"/></A_8>
		<BW_1 public="1" static="1"><c path="Int"/></BW_1>
		<sXRGB_8888 public="1" static="1"><c path="Int"/></sXRGB_8888>
		<sARGB_8888 public="1" static="1"><c path="Int"/></sARGB_8888>
		<sARGB_8888_PRE public="1" static="1"><c path="Int"/></sARGB_8888_PRE>
		<sARGB_1555 public="1" static="1"><c path="Int"/></sARGB_1555>
		<sARGB_4444 public="1" static="1"><c path="Int"/></sARGB_4444>
		<lXRGB_8888 public="1" static="1"><c path="Int"/></lXRGB_8888>
		<lARGB_8888 public="1" static="1"><c path="Int"/></lARGB_8888>
		<lARGB_8888_PRE public="1" static="1"><c path="Int"/></lARGB_8888_PRE>
		<sBGRX_8888 public="1" static="1"><c path="Int"/></sBGRX_8888>
		<sBGRA_8888 public="1" static="1"><c path="Int"/></sBGRA_8888>
		<sBGRA_8888_PRE public="1" static="1"><c path="Int"/></sBGRA_8888_PRE>
		<sBGR_565 public="1" static="1"><c path="Int"/></sBGR_565>
		<sBGRA_5551 public="1" static="1"><c path="Int"/></sBGRA_5551>
		<sBGRA_4444 public="1" static="1"><c path="Int"/></sBGRA_4444>
		<lBGRX_8888 public="1" static="1"><c path="Int"/></lBGRX_8888>
		<lBGRA_8888 public="1" static="1"><c path="Int"/></lBGRA_8888>
		<lBGRA_8888_PRE public="1" static="1"><c path="Int"/></lBGRA_8888_PRE>
		<sXBGR_8888 public="1" static="1"><c path="Int"/></sXBGR_8888>
		<sABGR_8888 public="1" static="1"><c path="Int"/></sABGR_8888>
		<sABGR_8888_PRE public="1" static="1"><c path="Int"/></sABGR_8888_PRE>
		<sABGR_1555 public="1" static="1"><c path="Int"/></sABGR_1555>
		<sABGR_4444 public="1" static="1"><c path="Int"/></sABGR_4444>
		<lXBGR_8888 public="1" static="1"><c path="Int"/></lXBGR_8888>
		<lABGR_8888 public="1" static="1"><c path="Int"/></lABGR_8888>
		<lABGR_8888_PRE public="1" static="1"><c path="Int"/></lABGR_8888_PRE>
		<IMAGE_QUALITY_NONANTIALIASED public="1" static="1"><c path="Int"/></IMAGE_QUALITY_NONANTIALIASED>
		<IMAGE_QUALITY_FASTER public="1" static="1"><c path="Int"/></IMAGE_QUALITY_FASTER>
		<IMAGE_QUALITY_BETTER public="1" static="1"><c path="Int"/></IMAGE_QUALITY_BETTER>
		<IMAGE_FORMAT public="1" static="1"><c path="Int"/></IMAGE_FORMAT>
		<IMAGE_WIDTH public="1" static="1"><c path="Int"/></IMAGE_WIDTH>
		<IMAGE_HEIGHT public="1" static="1"><c path="Int"/></IMAGE_HEIGHT>
		<DRAW_IMAGE_NORMAL public="1" static="1"><c path="Int"/></DRAW_IMAGE_NORMAL>
		<DRAW_IMAGE_MULTIPLY public="1" static="1"><c path="Int"/></DRAW_IMAGE_MULTIPLY>
		<DRAW_IMAGE_STENCIL public="1" static="1"><c path="Int"/></DRAW_IMAGE_STENCIL>
		<RED public="1" static="1"><c path="Int"/></RED>
		<GREEN public="1" static="1"><c path="Int"/></GREEN>
		<BLUE public="1" static="1"><c path="Int"/></BLUE>
		<ALPHA public="1" static="1"><c path="Int"/></ALPHA>
		<BLEND_SRC public="1" static="1"><c path="Int"/></BLEND_SRC>
		<BLEND_SRC_OVER public="1" static="1"><c path="Int"/></BLEND_SRC_OVER>
		<BLEND_DST_OVER public="1" static="1"><c path="Int"/></BLEND_DST_OVER>
		<BLEND_SRC_IN public="1" static="1"><c path="Int"/></BLEND_SRC_IN>
		<BLEND_DST_IN public="1" static="1"><c path="Int"/></BLEND_DST_IN>
		<BLEND_MULTIPLY public="1" static="1"><c path="Int"/></BLEND_MULTIPLY>
		<BLEND_SCREEN public="1" static="1"><c path="Int"/></BLEND_SCREEN>
		<BLEND_DARKEN public="1" static="1"><c path="Int"/></BLEND_DARKEN>
		<BLEND_LIGHTEN public="1" static="1"><c path="Int"/></BLEND_LIGHTEN>
		<BLEND_ADDITIVE public="1" static="1"><c path="Int"/></BLEND_ADDITIVE>
		<BLEND_SRC_OUT_SH public="1" static="1"><c path="Int"/></BLEND_SRC_OUT_SH>
		<BLEND_DST_OUT_SH public="1" static="1"><c path="Int"/></BLEND_DST_OUT_SH>
		<BLEND_SRC_ATOP_SH public="1" static="1"><c path="Int"/></BLEND_SRC_ATOP_SH>
		<BLEND_DST_ATOP_SH public="1" static="1"><c path="Int"/></BLEND_DST_ATOP_SH>
		<IMAGE_FORMAT_QUERY public="1" static="1"><c path="Int"/></IMAGE_FORMAT_QUERY>
		<PATH_DATATYPE_QUERY public="1" static="1"><c path="Int"/></PATH_DATATYPE_QUERY>
		<HARDWARE_ACCELERATED public="1" static="1"><c path="Int"/></HARDWARE_ACCELERATED>
		<HARDWARE_UNACCELERATED public="1" static="1"><c path="Int"/></HARDWARE_UNACCELERATED>
		<VENDOR public="1" static="1"><c path="Int"/></VENDOR>
		<RENDERER public="1" static="1"><c path="Int"/></RENDERER>
		<VERSION public="1" static="1"><c path="Int"/></VERSION>
		<EXTENSIONS public="1" static="1"><c path="Int"/></EXTENSIONS>
		<PATH_FORMAT_STANDARD public="1" static="1"><c path="Int"/></PATH_FORMAT_STANDARD>
		<getError public="1" static="1"><f a=""><c path="Int"/></f></getError>
		<flush public="1" static="1"><f a=""><e path="Void"/></f></flush>
		<finish public="1" static="1"><f a=""><e path="Void"/></f></finish>
		<setf public="1" static="1"><f a="type:value">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setf>
		<seti public="1" static="1"><f a="type:value">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></seti>
		<setfv public="1" static="1">
			<f a="type:count:values">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="values" type="float" min-size="count"/></nekobind> ]]></haxe_doc>
		</setfv>
		<setiv public="1" static="1">
			<f a="type:count:values">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="values" type="int" min-size="count"/></nekobind> ]]></haxe_doc>
		</setiv>
		<getf public="1" static="1"><f a="type">
	<c path="Int"/>
	<c path="Float"/>
</f></getf>
		<geti public="1" static="1"><f a="type">
	<c path="Int"/>
	<c path="Int"/>
</f></geti>
		<getVectorSize public="1" static="1"><f a="type">
	<c path="Int"/>
	<c path="Int"/>
</f></getVectorSize>
		<getfv public="1" static="1">
			<f a="type:count:values">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="values" type="float" min-size="count"/></nekobind> ]]></haxe_doc>
		</getfv>
		<getiv public="1" static="1">
			<f a="type:count:values">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="values" type="int" min-size="count"/></nekobind> ]]></haxe_doc>
		</getiv>
		<getParameterf public="1" static="1"><f a="object:type">
	<c path="openvg.Handle"/>
	<c path="Int"/>
	<c path="Float"/>
</f></getParameterf>
		<getParameteri public="1" static="1"><f a="object:type">
	<c path="openvg.Handle"/>
	<c path="Int"/>
	<c path="Int"/>
</f></getParameteri>
		<getParameterVectorSize public="1" static="1"><f a="object:type">
	<c path="openvg.Handle"/>
	<c path="Int"/>
	<c path="Int"/>
</f></getParameterVectorSize>
		<getParameterfv public="1" static="1">
			<f a="object:type:count:values">
				<c path="openvg.Handle"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="values" type="float" min-size="count"/></nekobind> ]]></haxe_doc>
		</getParameterfv>
		<getParameteriv public="1" static="1">
			<f a="object:type:count:values">
				<c path="openvg.Handle"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="values" type="int" min-size="count"/></nekobind> ]]></haxe_doc>
		</getParameteriv>
		<loadIdentity public="1" static="1"><f a=""><e path="Void"/></f></loadIdentity>
		<loadMatrix public="1" static="1">
			<f a="m">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="m" type="float" min-size="9"/></nekobind> ]]></haxe_doc>
		</loadMatrix>
		<getMatrix public="1" static="1">
			<f a="m">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="m" type="float" min-size="9"/></nekobind> ]]></haxe_doc>
		</getMatrix>
		<multMatrix public="1" static="1">
			<f a="m">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ <nekobind><cptr name="m" type="float" min-size="9"/></nekobind> ]]></haxe_doc>
		</multMatrix>
		<translate public="1" static="1"><f a="tx:ty">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<scale public="1" static="1"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<shear public="1" static="1"><f a="shx:shy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></shear>
		<rotate public="1" static="1"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<clear public="1" static="1"><f a="x:y:width:height">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></clear>
		<createContextSH public="1" static="1"><f a="width:height">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></createContextSH>
		<resizeSurfaceSH public="1" static="1"><f a="width:height">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></resizeSurfaceSH>
		<destroyContextSH public="1" static="1"><f a=""><e path="Void"/></f></destroyContextSH>
		<haxe_doc><![CDATA[
	Global OpenVG functions. 
	Make sure you create (and makeCurrent) a Display before using any of these.
	
	<nekobind 
		prefix="vg"
		module="openvg"
		global="true"
		translator="Capitalize"
		globalFinderPrefix="VG_"
		globalFinderCCFlags="-lOpenVG -lGL -lGLU"
		
		friends="openvg.Handle:VGHandle>__h,
				openvg.Path:VGPath>__h,
				openvg.Paint:VGPaint>__h"
		/>
	<nekobind:cHeader>
		#include &lt;vg/openvg.h&gt;
	</nekobind:cHeader>
]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.core.Controller" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/core/Controller.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IController"/>
		<getInstance public="1" line="69" static="1">
			<f a="key">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IController"/>
			</f>
			<haxe_doc>
	 * [Controller] Multiton Factory method.
	 </haxe_doc>
		</getInstance>
		<instanceMap static="1"><c path="Hash"><c path="org.puremvc.haxe.multicore.interfaces.IController"/></c></instanceMap>
		<initializeController line="61">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Initialize the Singleton [Controller] instance.
	 * 
	 * <p>Called automatically by the constructor.</p> 
	 * 
	 * <p>Note that if you are using a subclass of [View]
	 * in your application, you should <em>also</em> subclass [Controller]
	 * and override the [initializeController] method.
	 ]]></haxe_doc>
		</initializeController>
		<executeCommand public="1" line="80">
			<f a="note">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * If an [ICommand] has previously been registered 
	 * to handle a the given [INotification], then it is executed.
	 </haxe_doc>
		</executeCommand>
		<registerCommand public="1" line="100">
			<f a="notificationName:commandClassRef">
				<c path="String"/>
				<c path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Register a particular [ICommand] class as the handler for a particular [INotification].
	 * 
	 * <p>If an [ICommand] has already been registered to 
	 * handle [INotification]s with this name, it is no longer
	 * used, the new [ICommand] is used instead.</p>
	 * 
	 * <p>The Observer for the new ICommand is only created if this the 
	 * first time an ICommand has been regisered for this Notification name.</p>
	 ]]></haxe_doc>
		</registerCommand>
		<hasCommand public="1" line="110">
			<f a="notificationName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a Command is registered for a given Notification 
	 </haxe_doc>
		</hasCommand>
		<removeCommand public="1" line="118">
			<f a="notificationName">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove a previously registered [ICommand] to [INotification] mapping.
	 </haxe_doc>
		</removeCommand>
		<removeController public="1" line="133">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove an IController instance
	 </haxe_doc>
		</removeController>
		<view><c path="org.puremvc.haxe.multicore.interfaces.IView"/></view>
		<commandMap><c path="Hash"><c path="Class"><c path="org.puremvc.haxe.multicore.interfaces.ICommand"/></c></c></commandMap>
		<multitonKey><c path="String"/></multitonKey>
		<new line="44">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Constructor. 
	 * 
	 * <p>This [IController] implementation is a Multiton, so you cannot
	 * call the constructor directly, but instead call the static 
	 * Factory method passing the unique key for this instance
	 * [Controller.getInstance( multitonKey )]</p>
	 ]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * A Multiton [IController] implementation.
 * 
 * <p>In PureMVC, the [Controller] class follows the
 * 'Command and Controller' strategy, and assumes these responsibilities:</p>
 * <ul>
 * <li> Remembering which [ICommand]s are intended to handle which [INotifications].</li>
 * <li> Registering itself as an [IObserver] with the [View] for each [INotification] 
 * that it has an [ICommand] mapping for.</li>
 * <li> Creating a new instance of the proper [ICommand] to handle a given [INotification]
 * when notified by the [View].</li>
 * <li> Calling the [ICommand]'s [execute] method, passing in the [INotification].</li> 
 * </ul>
 * 
 * <p>Your application must register [ICommands] with the Controller.
 * The simplest way is to subclass [Facade], 
 * and use its [initializeController] method to add your registrations.</p>
 ]]></haxe_doc>
	</class>
	<class path="org.puremvc.haxe.multicore.utilities.statemachine.FSMInjector" params="" file="../../../pmvc_haxe_multicore_utilities_statemachine/src/org/puremvc/haxe/multicore/utilities/statemachine/FSMInjector.hx">
		<extends path="org.puremvc.haxe.multicore.patterns.observer.Notifier"/>
		<inject public="1" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Inject the [StateMachine] into the PureMVC apparatus.
	 * 
	 * <p>Creates the [StateMachine] instance, registers all the states
	 * and registers the [StateMachine] with the [IFacade].</p>
	 ]]></haxe_doc>
		</inject>
		<getStates line="60">
			<f a=""><c path="List"><c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/></c></f>
			<haxe_doc><![CDATA[
	 * Get the state definitions.
	 *
	 * <p>Creates and returns the array of State objects 
	 * from the FSM on first call, subsequently returns
	 * the existing array.</p>
	 ]]></haxe_doc>
		</getStates>
		<states public="1" get="getStates" set="null"><c path="List"><c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/></c></states>
		<createState line="78">
			<f a="stateDef">
				<c path="Xml"/>
				<c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/>
			</f>
			<haxe_doc>
	 * Creates a [State] instance from its Xml definition.
	 </haxe_doc>
		</createState>
		<isInitial line="97">
			<f a="stateName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Is the given state the initial state?
	 </haxe_doc>
		</isInitial>
		<fsm><c path="Xml"/></fsm>
		<stateList><c path="List"><c path="org.puremvc.haxe.multicore.utilities.statemachine.State"/></c></stateList>
		<new public="1" line="25">
			<f a="fsm">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * Creates and registers a StateMachine described in Xml.
 * 
 * <p>This allows reconfiguration of the StateMachine 
 * without changing any code, as well as making it 
 * easier than creating all the [State] 
 * instances and registering them with the 
 * [StateMachine] at startup time.</p>
 ]]></haxe_doc>
	</class>
	<class path="xinf.ony.type.IntList" params="" file="../../../xinf/src/xinf/ony/type/IntList.hx">
		<list public="1"><c path="Array"><c path="Int"/></c></list>
		<toString public="1" line="18"><f a=""><c path="String"/></f></toString>
		<new public="1" line="14"><f a="l">
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Defines a list of Int values.
	
	Used mainly for the stroke-dasharray property.
</haxe_doc>
	</class>
	<typedef path="xinf.erno.TGradientStop" params="" file="../../../xinf/src/xinf/erno/TGradientStop.hx">
		<a>
			<r><c path="Float"/></r>
			<offset><c path="Float"/></offset>
			<g><c path="Float"/></g>
			<b><c path="Float"/></b>
			<a><c path="Float"/></a>
		</a>
		<haxe_doc>
	Defines a color stop for a Gradient.
	
	[r], [g], [b] and [a] define the RGBA color to be used at the stop,
	with values from 0.0 to 1.0.
	
	[offset] defines the offset of the stop, 0 to 1.
	
	See $xinf.type.Paint$.
	
	$SVG painting#StopElement The "stop" element in SVG$
</haxe_doc>
	</typedef>
	<enum path="XmlType" params="" file="C:\Program Files\Motion-Twin\haxe/std/Xml.hx" module="Xml"><haxe_doc>
	An abstract type representing the type of the Xml
	Node. You can compare it to [Xml] statics and can
	use [Std.string(t)] to get a string reprensation
	of the type.
</haxe_doc></enum>
	<class path="Xml" params="" file="C:\Program Files\Motion-Twin\haxe/std/Xml.hx" extern="1">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<parse public="1" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<getNodeName><f a=""><c path="String"/></f></getNodeName>
		<setNodeName><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<getNodeValue><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<get public="1">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<getParent><f a=""><c path="Xml"/></f></getParent>
		<iterator public="1">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<class path="xinf.geom.Scale" params="" file="../../../xinf/src/xinf/geom/Scale.hx">
		<implements path="xinf.geom.Transform"/>
		<x><c path="Float"/></x>
		<y><c path="Float"/></y>
		<getTranslation public="1" line="17"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getTranslation>
		<getScale public="1" line="20"><f a=""><a>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></f></getScale>
		<getMatrix public="1" line="23"><f a=""><a>
	<ty><c path="Float"/></ty>
	<tx><c path="Float"/></tx>
	<d><c path="Float"/></d>
	<c><c path="Float"/></c>
	<b><c path="Float"/></b>
	<a><c path="Float"/></a>
</a></f></getMatrix>
		<apply public="1" line="27"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></apply>
		<applyInverse public="1" line="30"><f a="p">
	<t path="xinf.geom.TPoint"/>
	<t path="xinf.geom.TPoint"/>
</f></applyInverse>
		<interpolateWith public="1" line="34"><f a="p:f">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
	<c path="xinf.geom.Transform"/>
</f></interpolateWith>
		<distanceTo public="1" line="42"><f a="p">
	<c path="xinf.geom.Transform"/>
	<c path="Float"/>
</f></distanceTo>
		<isIdentity public="1" line="48"><f a=""><e path="Bool"/></f></isIdentity>
		<add public="1" line="52"><f a="t">
	<c path="xinf.geom.Transform"/>
	<c path="xinf.geom.Transform"/>
</f></add>
		<toString public="1" line="60"><f a=""><c path="String"/></f></toString>
		<new public="1" line="12"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.puremvc.haxe.multicore.core.View" params="" file="../../../pmvc_haxe_multicore/src/org/puremvc/haxe/multicore/core/View.hx">
		<implements path="org.puremvc.haxe.multicore.interfaces.IView"/>
		<getInstance public="1" line="62" static="1">
			<f a="key">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IView"/>
			</f>
			<haxe_doc>
	 * View Singleton Factory method.
	 </haxe_doc>
		</getInstance>
		<instanceMap static="1"><c path="Hash"><c path="org.puremvc.haxe.multicore.interfaces.IView"/></c></instanceMap>
		<initializeView line="55">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Initialize the Singleton [View] instance.
	 * 
	 * <p>Called automatically by the constructor, this is your opportunity to initialize the Singleton
	 * instance in your subclass without overriding the constructor.</p>
	 ]]></haxe_doc>
		</initializeView>
		<registerObserver public="1" line="72">
			<f a="notificationName:observer">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IObserver"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Register an [IObserver] to be notified of [INotifications] with a given name.
	 </haxe_doc>
		</registerObserver>
		<notifyObservers public="1" line="86">
			<f a="notification">
				<c path="org.puremvc.haxe.multicore.interfaces.INotification"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Notify the [IObservers] for a particular [INotification].
	 * 
	 * <p>All previously attached [IObservers] for this [INotification]'s
	 * list are notified and are passed a reference to the [INotification] in 
	 * the order in which they were registered.</p>
	 ]]></haxe_doc>
		</notifyObservers>
		<removeObserver public="1" line="99">
			<f a="notificationName:notifyContext">
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
 	* Remove the observer for a given notifyContext from an observer list for a given Notification name.
 	</haxe_doc>
		</removeObserver>
		<registerMediator public="1" line="136">
			<f a="mediator">
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Register an [IMediator] instance with the [View].
	 * 
	 * <p>Registers the [IMediator] so that it can be retrieved by name,
	 * and further interrogates the [IMediator] for its [INotification] interests.</p>
	 * <p>
	 * If the [IMediator] returns any [INotification] 
	 * names to be notified about, an [Observer] is created encapsulating 
	 * the [IMediator] instance's [handleNotification] method 
	 * and registering it as an [Observer] for all [INotifications] the 
	 * [IMediator] is interested in.</p>
	 ]]></haxe_doc>
		</registerMediator>
		<retrieveMediator public="1" line="161">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>
	 * Retrieve an [IMediator] from the [View].
	 </haxe_doc>
		</retrieveMediator>
		<removeMediator public="1" line="169">
			<f a="mediatorName">
				<c path="String"/>
				<c path="org.puremvc.haxe.multicore.interfaces.IMediator"/>
			</f>
			<haxe_doc>
 	* Remove an [IMediator] from the [View].
 	</haxe_doc>
		</removeMediator>
		<hasMediator public="1" line="198">
			<f a="mediatorName">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check if a Mediator is registered or not
	 </haxe_doc>
		</hasMediator>
		<removeView public="1" line="206">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Remove an IView instance
	 </haxe_doc>
		</removeView>
		<mediatorMap><c path="Hash"><c path="org.puremvc.haxe.multicore.interfaces.IMediator"/></c></mediatorMap>
		<observerMap><c path="Hash"><c path="List"><c path="org.puremvc.haxe.multicore.interfaces.IObserver"/></c></c></observerMap>
		<multitonKey><c path="String"/></multitonKey>
		<new public="1" line="40">
			<f a="key">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Constructor. 
	 * 
	 * <p>This [IView] implementation is a Multiton, 
	 * so you should not call the constructor 
	 * directly, but instead call the static Multiton 
	 * Factory method [View.getInstance( multitonKey )]</p>
	 ]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * A Multiton [IView] implementation.
 * 
 * <p>In PureMVC, the [View] class assumes these responsibilities:</p>
 * <ul>
 * <li>Maintain a cache of [IMediator] instances.</li>
 * <li>Provide methods for registering, retrieving, and removing [IMediators].</li>
 * <li>Notifiying [IMediators] when they are registered or removed.</li>
 * <li>Managing the observer lists for each [INotification] in the application.</li>
 * <li>Providing a method for attaching [IObservers] to an [INotification]'s observer list.</li>
 * <li>Providing a method for broadcasting an [INotification].</li>
 * <li>Notifying the [IObservers] of a given [INotification] when it broadcast.</li>
 * </ul>
 ]]></haxe_doc>
	</class>
	<class path="xinf.xml.URL" params="" file="../../../xinf/src/xinf/xml/URL.hx">
		<BASE64 line="181" static="1"><c path="String"/></BASE64>
		<protocol public="1">
			<c path="String"/>
			<haxe_doc> the protocol part of the URI, mostly "http" or "file" </haxe_doc>
		</protocol>
		<host public="1">
			<c path="String"/>
			<haxe_doc> the host part of the URI.
		if the URI describes a file:// reference,
		this is the first part of the path. </haxe_doc>
		</host>
		<port public="1">
			<c path="Int"/>
			<haxe_doc> the port, if omitted it is automatically
		set for some protocols: 80 for http, 443 for https and 21 for ftp.
	</haxe_doc>
		</port>
		<path public="1">
			<c path="String"/>
			<haxe_doc> the path part of the URI</haxe_doc>
		</path>
		<filename public="1">
			<c path="String"/>
			<haxe_doc> the filename part of the URI </haxe_doc>
		</filename>
		<parse line="44"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></parse>
		<getRelativeURL public="1" line="96">
			<f a="rel">
				<c path="String"/>
				<c path="xinf.xml.URL"/>
			</f>
			<haxe_doc>
		Return a new URL that is the result of appending
		[rel] to this URL.
		
		Currently, this actually just appends it, leaving
		away the filename. A future	version should "compress" 
		[foo/../bar] into [bar], and also handle absolute
		URLs for rel. (TODO)
	</haxe_doc>
		</getRelativeURL>
		<isAbsolute public="1" line="104"><f a=""><e path="Bool"/></f></isAbsolute>
		<fetch public="1" line="117">
			<f a="onData:?onError">
				<f a="">
					<c path="String"/>
					<e path="Void"/>
				</f>
				<f a="">
					<c path="String"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Load the file referenced by this resource
		(potentially asynchronously), and call [onData] with the
		loaded text. If [onError] is given, it will be called in
		case of an error.
		
		On neko (Xinfinity), this also handles file:// URLs
		(by using neko.io.File.getContent).
	</haxe_doc>
		</fetch>
		<pathString public="1" line="164">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Return a string representation of this URL up to but not including
		the filename part.
	</haxe_doc>
		</pathString>
		<getData public="1" line="185">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Return data, if this is a "data:" URL.
	</haxe_doc>
		</getData>
		<toString public="1" line="202">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Return a complete string representation of this URL.
	</haxe_doc>
		</toString>
		<new public="1" line="40">
			<f a="s">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc> create a new URL by parsing from [s] </haxe_doc>
		</new>
		<haxe_doc><![CDATA[
	A URL/URI/IRI.
	
	Describes a "universal|internationalized resource locator|identifier".
	If you don't know (roughly) what that is, you're in the wrong movie.
	
	In terms of this class, a URL is built like: <br/>
	[<protocol>://<host>:<port>/<path>/<filename>]

	Fragments (#foo) and GET parameters (?foo=bar) are just part of the [filename] for now.

	$SVG linking#IRIReference$
]]></haxe_doc>
	</class>
</haxe>